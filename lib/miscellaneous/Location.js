'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var constants = require('../constants'),
    vectorMaths = require('../maths/vector'),
    arrayUtilities = require('../utilities/array');

var first = arrayUtilities.first,
    second = arrayUtilities.second,
    add3 = vectorMaths.add3,
    subtract2 = vectorMaths.subtract2,
    scale2 = vectorMaths.scale2,
    OFFSET_SCALAR = constants.OFFSET_SCALAR,
    INITIAL_MOUSE_COORDINATES = constants.INITIAL_MOUSE_COORDINATES;

var Location = function () {
  function Location(offset, previousOffset, mouseCoordinates, previousMouseCoordinates) {
    _classCallCheck(this, Location);

    this.offset = offset;
    this.previousOffset = previousOffset;
    this.mouseCoordinates = mouseCoordinates;
    this.previousMouseCoordinates = previousMouseCoordinates;
  }

  _createClass(Location, [{
    key: 'getOffset',
    value: function getOffset() {
      return this.offset;
    }
  }, {
    key: 'setMouseCoordinates',
    value: function setMouseCoordinates(mouseCoordinates) {
      this.mouseCoordinates = mouseCoordinates;
    }
  }, {
    key: 'updatePreviousMouseCoordinates',
    value: function updatePreviousMouseCoordinates() {
      this.previousMouseCoordinates = this.mouseCoordinates;
    }
  }, {
    key: 'updatePreviousOffset',
    value: function updatePreviousOffset() {
      this.previousOffset = this.offset;
    }
  }, {
    key: 'updateOffset',
    value: function updateOffset(tilt) {
      var xAngle = tilt.getXAngle(),
          yAngle = tilt.getYAngle(),
          scalar = OFFSET_SCALAR,
          ///
      relativeMouseCoordinates = subtract2(this.mouseCoordinates, this.previousMouseCoordinates),
          relativeOffset = scale2(relativeMouseCoordinates, scalar),
          yAngleOffset = calculateYAngleOffset(yAngle, relativeOffset),
          xAngleOffset = calculateXAngleOffset(xAngle, yAngle, relativeOffset);

      this.offset = add3(add3(this.previousOffset, yAngleOffset), xAngleOffset); ///
    }
  }], [{
    key: 'fromInitialOffset',
    value: function fromInitialOffset(initialOffset) {
      var offset = initialOffset,
          ///
      previousOffset = offset,
          ///
      mouseCoordinates = INITIAL_MOUSE_COORDINATES,
          ///
      previousMouseCoordinates = mouseCoordinates,
          ///
      location = new Location(offset, previousOffset, mouseCoordinates, previousMouseCoordinates);

      return location;
    }
  }]);

  return Location;
}();

module.exports = Location;

function calculateYAngleOffset(yAngle, relativeOffset) {
  var relativeOffsetComponents = relativeOffset,
      ///
  firstRelativeOffsetComponent = first(relativeOffsetComponents),
      yAngleOffset = [-Math.cos(yAngle) * firstRelativeOffsetComponent, +0, -Math.sin(yAngle) * firstRelativeOffsetComponent];

  return yAngleOffset;
}

function calculateXAngleOffset(xAngle, yAngle, relativeOffset) {
  var relativeOffsetComponents = relativeOffset,
      ///
  secondRelativeOffsetComponent = second(relativeOffsetComponents),
      xAngleOffset = [-Math.sin(xAngle) * Math.sin(yAngle) * secondRelativeOffsetComponent, -Math.cos(xAngle) * secondRelativeOffsetComponent, +Math.sin(xAngle) * Math.cos(yAngle) * secondRelativeOffsetComponent];

  return xAngleOffset;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2VzNi9taXNjZWxsYW5lb3VzL0xvY2F0aW9uLmpzIl0sIm5hbWVzIjpbImNvbnN0YW50cyIsInJlcXVpcmUiLCJ2ZWN0b3JNYXRocyIsImFycmF5VXRpbGl0aWVzIiwiZmlyc3QiLCJzZWNvbmQiLCJhZGQzIiwic3VidHJhY3QyIiwic2NhbGUyIiwiT0ZGU0VUX1NDQUxBUiIsIklOSVRJQUxfTU9VU0VfQ09PUkRJTkFURVMiLCJMb2NhdGlvbiIsIm9mZnNldCIsInByZXZpb3VzT2Zmc2V0IiwibW91c2VDb29yZGluYXRlcyIsInByZXZpb3VzTW91c2VDb29yZGluYXRlcyIsInRpbHQiLCJ4QW5nbGUiLCJnZXRYQW5nbGUiLCJ5QW5nbGUiLCJnZXRZQW5nbGUiLCJzY2FsYXIiLCJyZWxhdGl2ZU1vdXNlQ29vcmRpbmF0ZXMiLCJyZWxhdGl2ZU9mZnNldCIsInlBbmdsZU9mZnNldCIsImNhbGN1bGF0ZVlBbmdsZU9mZnNldCIsInhBbmdsZU9mZnNldCIsImNhbGN1bGF0ZVhBbmdsZU9mZnNldCIsImluaXRpYWxPZmZzZXQiLCJsb2NhdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZWxhdGl2ZU9mZnNldENvbXBvbmVudHMiLCJmaXJzdFJlbGF0aXZlT2Zmc2V0Q29tcG9uZW50IiwiTWF0aCIsImNvcyIsInNpbiIsInNlY29uZFJlbGF0aXZlT2Zmc2V0Q29tcG9uZW50Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUEsSUFBTUEsWUFBWUMsUUFBUSxjQUFSLENBQWxCO0FBQUEsSUFDSUMsY0FBY0QsUUFBUSxpQkFBUixDQURsQjtBQUFBLElBRUlFLGlCQUFpQkYsUUFBUSxvQkFBUixDQUZyQjs7SUFJUUcsSyxHQUFrQkQsYyxDQUFsQkMsSztJQUFPQyxNLEdBQVdGLGMsQ0FBWEUsTTtJQUNQQyxJLEdBQTRCSixXLENBQTVCSSxJO0lBQU1DLFMsR0FBc0JMLFcsQ0FBdEJLLFM7SUFBV0MsTSxHQUFXTixXLENBQVhNLE07SUFDakJDLGEsR0FBNkNU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Q0FBU2hCLE1BQVQsQ0FBcEIsR0FBdUNrQiw2QkFIMUIsQ0FGbkI7O0FBUUEsU0FBT1gsWUFBUDtBQUNEIiwiZmlsZSI6IkxvY2F0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKSxcbiAgICB2ZWN0b3JNYXRocyA9IHJlcXVpcmUoJy4uL21hdGhzL3ZlY3RvcicpLFxuICAgIGFycmF5VXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2FycmF5Jyk7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IGFkZDMsIHN1YnRyYWN0Miwgc2NhbGUyIH0gPSB2ZWN0b3JNYXRocyxcbiAgICAgIHsgT0ZGU0VUX1NDQUxBUiwgSU5JVElBTF9NT1VTRV9DT09SRElOQVRFUyB9ID0gY29uc3RhbnRzO1xuXG5jbGFzcyBMb2NhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9mZnNldCwgcHJldmlvdXNPZmZzZXQsIG1vdXNlQ29vcmRpbmF0ZXMsIHByZXZpb3VzTW91c2VDb29yZGluYXRlcykge1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMucHJldmlvdXNPZmZzZXQgPSBwcmV2aW91c09mZnNldDtcbiAgICB0aGlzLm1vdXNlQ29vcmRpbmF0ZXMgPSBtb3VzZUNvb3JkaW5hdGVzO1xuICAgIHRoaXMucHJldmlvdXNNb3VzZUNvb3JkaW5hdGVzID0gcHJldmlvdXNNb3VzZUNvb3JkaW5hdGVzO1xuICB9XG5cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldDtcbiAgfVxuXG4gIHNldE1vdXNlQ29vcmRpbmF0ZXMobW91c2VDb29yZGluYXRlcykge1xuICAgIHRoaXMubW91c2VDb29yZGluYXRlcyA9IG1vdXNlQ29vcmRpbmF0ZXM7XG4gIH1cblxuICB1cGRhdGVQcmV2aW91c01vdXNlQ29vcmRpbmF0ZXMoKSB7XG4gICAgdGhpcy5wcmV2aW91c01vdXNlQ29vcmRpbmF0ZXMgPSB0aGlzLm1vdXNlQ29vcmRpbmF0ZXM7XG4gIH1cblxuICB1cGRhdGVQcmV2aW91c09mZnNldCgpIHtcbiAgICB0aGlzLnByZXZpb3VzT2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gIH1cblxuICB1cGRhdGVPZmZzZXQodGlsdCkge1xuICAgIGNvbnN0IHhBbmdsZSA9IHRpbHQuZ2V0WEFuZ2xlKCksXG4gICAgICAgICAgeUFuZ2xlID0gdGlsdC5nZXRZQW5nbGUoKSxcbiAgICAgICAgICBzY2FsYXIgPSBPRkZTRVRfU0NBTEFSLCAvLy9cbiAgICAgICAgICByZWxhdGl2ZU1vdXNlQ29vcmRpbmF0ZXMgPSBzdWJ0cmFjdDIodGhpcy5tb3VzZUNvb3JkaW5hdGVzLCB0aGlzLnByZXZpb3VzTW91c2VDb29yZGluYXRlcyksXG4gICAgICAgICAgcmVsYXRpdmVPZmZzZXQgPSBzY2FsZTIocmVsYXRpdmVNb3VzZUNvb3JkaW5hdGVzLCBzY2FsYXIpLFxuICAgICAgICAgIHlBbmdsZU9mZnNldCA9IGNhbGN1bGF0ZVlBbmdsZU9mZnNldCh5QW5nbGUsIHJlbGF0aXZlT2Zmc2V0KSxcbiAgICAgICAgICB4QW5nbGVPZmZzZXQgPSBjYWxjdWxhdGVYQW5nbGVPZmZzZXQoeEFuZ2xlLCB5QW5nbGUsIHJlbGF0aXZlT2Zmc2V0KTtcblxuICAgIHRoaXMub2Zmc2V0ID0gYWRkMyhhZGQzKHRoaXMucHJldmlvdXNPZmZzZXQsIHlBbmdsZU9mZnNldCksIHhBbmdsZU9mZnNldCk7ICAvLy9cbiAgfVxuXG4gIHN0YXRpYyBmcm9tSW5pdGlhbE9mZnNldChpbml0aWFsT2Zmc2V0KSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaW5pdGlhbE9mZnNldCwgLy8vXG4gICAgICAgICAgcHJldmlvdXNPZmZzZXQgPSBvZmZzZXQsICAvLy9cbiAgICAgICAgICBtb3VzZUNvb3JkaW5hdGVzID0gSU5JVElBTF9NT1VTRV9DT09SRElOQVRFUywgLy8vXG4gICAgICAgICAgcHJldmlvdXNNb3VzZUNvb3JkaW5hdGVzID0gbW91c2VDb29yZGluYXRlcywgIC8vL1xuICAgICAgICAgIGxvY2F0aW9uID0gbmV3IExvY2F0aW9uKG9mZnNldCwgcHJldmlvdXNPZmZzZXQsIG1vdXNlQ29vcmRpbmF0ZXMsIHByZXZpb3VzTW91c2VDb29yZGluYXRlcyk7XG5cbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhdGlvbjtcblxuZnVuY3Rpb24gY2FsY3VsYXRlWUFuZ2xlT2Zmc2V0KHlBbmdsZSwgcmVsYXRpdmVPZmZzZXQpIHtcbiAgY29uc3QgcmVsYXRpdmVPZmZzZXRDb21wb25lbnRzID0gcmVsYXRpdmVPZmZzZXQsICAvLy9cbiAgICAgIGZpcnN0UmVsYXRpdmVPZmZzZXRDb21wb25lbnQgPSBmaXJzdChyZWxhdGl2ZU9mZnNldENvbXBvbmVudHMpLFxuICAgICAgeUFuZ2xlT2Zmc2V0ID0gW1xuICAgICAgICAtTWF0aC5jb3MoeUFuZ2xlKSAqIGZpcnN0UmVsYXRpdmVPZmZzZXRDb21wb25lbnQsXG4gICAgICAgICswLFxuICAgICAgICAtTWF0aC5zaW4oeUFuZ2xlKSAqIGZpcnN0UmVsYXRpdmVPZmZzZXRDb21wb25lbnRcbiAgICAgIF07XG5cbiAgcmV0dXJuIHlBbmdsZU9mZnNldDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlWEFuZ2xlT2Zmc2V0KHhBbmdsZSwgeUFuZ2xlLCByZWxhdGl2ZU9mZnNldCkge1xuICBjb25zdCByZWxhdGl2ZU9mZnNldENvbXBvbmVudHMgPSByZWxhdGl2ZU9mZnNldCwgIC8vL1xuICAgICAgc2Vjb25kUmVsYXRpdmVPZmZzZXRDb21wb25lbnQgPSBzZWNvbmQocmVsYXRpdmVPZmZzZXRDb21wb25lbnRzKSxcbiAgICAgIHhBbmdsZU9mZnNldCA9IFtcbiAgICAgICAgLU1hdGguc2luKHhBbmdsZSkgKiBNYXRoLnNpbih5QW5nbGUpICogc2Vjb25kUmVsYXRpdmVPZmZzZXRDb21wb25lbnQsXG4gICAgICAgIC1NYXRoLmNvcyh4QW5nbGUpICogc2Vjb25kUmVsYXRpdmVPZmZzZXRDb21wb25lbnQsXG4gICAgICAgICtNYXRoLnNpbih4QW5nbGUpICogTWF0aC5jb3MoeUFuZ2xlKSAqIHNlY29uZFJlbGF0aXZlT2Zmc2V0Q29tcG9uZW50XG4gICAgICBdO1xuXG4gIHJldHVybiB4QW5nbGVPZmZzZXQ7XG59XG4iXX0=
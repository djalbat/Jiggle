"use strict";

var _constants = require("../constants");

var _array = require("../utilities/array");

var _vector = require("../maths/vector");

function cloneEdges(edges) {
  edges = edges.map(function (edge) {
    return edge.clone();
  });
  return edges;
}

function cloneNormal(normal) {
  normal = normal.clone();
  return normal;
}

function cloneVertices(vertices) {
  vertices = vertices.map(function (vertex) {
    return vertex.clone();
  });
  return vertices;
}

function calculateEdges(vertices, Edge) {
  var edges = vertices.map(function (vertex, index) {
    var startIndex = index,
        ///
    endIndex = (startIndex + 1) % _constants.VERTICES_LENGTH,
        startVertex = vertices[startIndex],
        endVertex = vertices[endIndex],
        edge = Edge.fromStartVertexAndEndVertex(startVertex, endVertex);
    return edge;
  });
  return edges;
}

function calculateNormal(vertices, Normal) {
  var normal = Normal.fromVertices(vertices);
  return normal;
}

function calculateArea(vertices) {
  var firstVertex = (0, _array.first)(vertices),
      secondVertex = (0, _array.second)(vertices),
      thirdVertex = (0, _array.third)(vertices),
      firstVertexPosition = firstVertex.getPosition(),
      secondVertexPosition = secondVertex.getPosition(),
      thirdVertexPosition = thirdVertex.getPosition(),
      firstExtent = (0, _vector.subtract3)(secondVertexPosition, firstVertexPosition),
      secondExtent = (0, _vector.subtract3)(thirdVertexPosition, firstVertexPosition),
      area = (0, _vector.length3)((0, _vector.cross3)(firstExtent, secondExtent)) / 2;
  return area;
}

module.exports = {
  cloneEdges: cloneEdges,
  cloneNormal: cloneNormal,
  cloneVertices: cloneVertices,
  calculateEdges: calculateEdges,
  calculateNormal: calculateNormal,
  calculateArea: calculateArea
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZhY2V0LmpzIl0sIm5hbWVzIjpbImNsb25lRWRnZXMiLCJlZGdlcyIsIm1hcCIsImVkZ2UiLCJjbG9uZSIsImNsb25lTm9ybWFsIiwibm9ybWFsIiwiY2xvbmVWZXJ0aWNlcyIsInZlcnRpY2VzIiwidmVydGV4IiwiY2FsY3VsYXRlRWRnZXMiLCJFZGdlIiwiaW5kZXgiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJWRVJUSUNFU19MRU5HVEgiLCJzdGFydFZlcnRleCIsImVuZFZlcnRleCIsImZyb21TdGFydFZlcnRleEFuZEVuZFZlcnRleCIsImNhbGN1bGF0ZU5vcm1hbCIsIk5vcm1hbCIsImZyb21WZXJ0aWNlcyIsImNhbGN1bGF0ZUFyZWEiLCJmaXJzdFZlcnRleCIsInNlY29uZFZlcnRleCIsInRoaXJkVmVydGV4IiwiZmlyc3RWZXJ0ZXhQb3NpdGlvbiIsImdldFBvc2l0aW9uIiwic2Vjb25kVmVydGV4UG9zaXRpb24iLCJ0aGlyZFZlcnRleFBvc2l0aW9uIiwiZmlyc3RFeHRlbnQiLCJzZWNvbmRFeHRlbnQiLCJhcmVhIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUEsU0FBU0EsVUFBVCxDQUFvQkMsS0FBcEIsRUFBMkI7QUFDekJBLEVBQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDQyxHQUFOLENBQVUsVUFBQ0MsSUFBRDtBQUFBLFdBQVVBLElBQUksQ0FBQ0MsS0FBTCxFQUFWO0FBQUEsR0FBVixDQUFSO0FBRUEsU0FBT0gsS0FBUDtBQUNEOztBQUVELFNBQVNJLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTZCO0FBQzNCQSxFQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ0YsS0FBUCxFQUFUO0FBRUEsU0FBT0UsTUFBUDtBQUNEOztBQUVELFNBQVNDLGFBQVQsQ0FBdUJDLFFBQXZCLEVBQWlDO0FBQy9CQSxFQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQ04sR0FBVCxDQUFhLFVBQUNPLE1BQUQ7QUFBQSxXQUFZQSxNQUFNLENBQUNMLEtBQVAsRUFBWjtBQUFBLEdBQWIsQ0FBWDtBQUVBLFNBQU9JLFFBQVA7QUFDRDs7QUFFRCxTQUFTRSxjQUFULENBQXdCRixRQUF4QixFQUFrQ0csSUFBbEMsRUFBd0M7QUFDdEMsTUFBTVYsS0FBSyxHQUFHTyxRQUFRLENBQUNOLEdBQVQsQ0FBYSxVQUFDTyxNQUFELEVBQVNHLEtBQVQsRUFBbUI7QUFDNUMsUUFBTUMsVUFBVSxHQUFHRCxLQUFuQjtBQUFBLFFBQTBCO0FBQ3BCRSxJQUFBQSxRQUFRLEdBQUcsQ0FBQ0QsVUFBVSxHQUFHLENBQWQsSUFBbUJFLDBCQURwQztBQUFBLFFBRU1DLFdBQVcsR0FBR1IsUUFBUSxDQUFDSyxVQUFELENBRjVCO0FBQUEsUUFHTUksU0FBUyxHQUFHVCxRQUFRLENBQUNNLFFBQUQsQ0FIMUI7QUFBQSxRQUlNWCxJQUFJLEdBQUdRLElBQUksQ0FBQ08sMkJBQUwsQ0FBaUNGLFdBQWpDLEVBQThDQyxTQUE5QyxDQUpiO0FBTUEsV0FBT2QsSUFBUDtBQUNELEdBUmEsQ0FBZDtBQVVBLFNBQU9GLEtBQVA7QUFDRDs7QUFFRCxTQUFTa0IsZUFBVCxDQUF5QlgsUUFBekIsRUFBbUNZLE1BQW5DLEVBQTJDO0FBQ3pDLE1BQU1kLE1BQU0sR0FBR2MsTUFBTSxDQUFDQyxZQUFQLENBQW9CYixRQUFwQixDQUFmO0FBRUEsU0FBT0YsTUFBUDtBQUNEOztBQUVELFNBQVNnQixhQUFULENBQXVCZCxRQUF2QixFQUFpQztBQUMvQixNQUFNZSxXQUFXLEdBQUcsa0JBQU1mLFFBQU4sQ0FBcEI7QUFBQSxNQUNNZ0IsWUFBWSxHQUFHLG1CQUFPaEIsUUFBUCxDQURyQjtBQUFBLE1BRU1pQixXQUFXLEdBQUcsa0JBQU1qQixRQUFOLENBRnBCO0FBQUEsTUFHTWtCLG1CQUFtQixHQUFHSCxXQUFXLENBQUNJLFdBQVosRUFINUI7QUFBQSxNQUlNQyxvQkFBb0IsR0FBR0osWUFBWSxDQUFDRyxXQUFiLEVBSjdCO0FBQUEsTUFLTUUsbUJBQW1CLEdBQUdKLFdBQVcsQ0FBQ0UsV0FBWixFQUw1QjtBQUFBLE1BTU1HLFdBQVcsR0FBRyx1QkFBVUYsb0JBQVYsRUFBZ0NGLG1CQUFoQyxDQU5wQjtBQUFBLE1BT01LLFlBQVksR0FBRyx1QkFBVUYsbUJBQVYsRUFBK0JILG1CQUEvQixDQVByQjtBQUFBLE1BUU1NLElBQUksR0FBRyxxQkFBUSxvQkFBT0YsV0FBUCxFQUFvQkMsWUFBcEIsQ0FBUixJQUE2QyxDQVIxRDtBQVVBLFNBQU9DLElBQVA7QUFDRDs7QUFFREMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2ZsQyxFQUFBQSxVQUFVLEVBQVZBLFVBRGU7QUFFZkssRUFBQUEsV0FBVyxFQUFYQSxXQUZlO0FBR2ZFLEVBQUFBLGFBQWEsRUFBYkEsYUFIZTtBQUlmRyxFQUFBQSxjQUFjLEVBQWRBLGNBSmU7QUFLZlMsRUFBQUEsZUFBZSxFQUFmQSxlQUxlO0FBTWZHLEVBQUFBLGFBQWEsRUFBYkE7QUFOZSxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBWRVJUSUNFU19MRU5HVEggfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBmaXJzdCwgc2Vjb25kLCB0aGlyZCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IHN1YnRyYWN0MywgY3Jvc3MzLCBsZW5ndGgzIH0gZnJvbSBcIi4uL21hdGhzL3ZlY3RvclwiO1xuXG5mdW5jdGlvbiBjbG9uZUVkZ2VzKGVkZ2VzKSB7XG4gIGVkZ2VzID0gZWRnZXMubWFwKChlZGdlKSA9PiBlZGdlLmNsb25lKCkpO1xuXG4gIHJldHVybiBlZGdlcztcbn1cblxuZnVuY3Rpb24gY2xvbmVOb3JtYWwobm9ybWFsKSB7XG4gIG5vcm1hbCA9IG5vcm1hbC5jbG9uZSgpO1xuICBcbiAgcmV0dXJuIG5vcm1hbDtcbn1cblxuZnVuY3Rpb24gY2xvbmVWZXJ0aWNlcyh2ZXJ0aWNlcykge1xuICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcCgodmVydGV4KSA9PiB2ZXJ0ZXguY2xvbmUoKSk7XG5cbiAgcmV0dXJuIHZlcnRpY2VzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVFZGdlcyh2ZXJ0aWNlcywgRWRnZSkge1xuICBjb25zdCBlZGdlcyA9IHZlcnRpY2VzLm1hcCgodmVydGV4LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleCwgLy8vXG4gICAgICAgICAgZW5kSW5kZXggPSAoc3RhcnRJbmRleCArIDEpICUgVkVSVElDRVNfTEVOR1RILFxuICAgICAgICAgIHN0YXJ0VmVydGV4ID0gdmVydGljZXNbc3RhcnRJbmRleF0sXG4gICAgICAgICAgZW5kVmVydGV4ID0gdmVydGljZXNbZW5kSW5kZXhdLFxuICAgICAgICAgIGVkZ2UgPSBFZGdlLmZyb21TdGFydFZlcnRleEFuZEVuZFZlcnRleChzdGFydFZlcnRleCwgZW5kVmVydGV4KTtcblxuICAgIHJldHVybiBlZGdlO1xuICB9KTtcblxuICByZXR1cm4gZWRnZXM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vcm1hbCh2ZXJ0aWNlcywgTm9ybWFsKSB7XG4gIGNvbnN0IG5vcm1hbCA9IE5vcm1hbC5mcm9tVmVydGljZXModmVydGljZXMpO1xuXG4gIHJldHVybiBub3JtYWw7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFyZWEodmVydGljZXMpIHtcbiAgY29uc3QgZmlyc3RWZXJ0ZXggPSBmaXJzdCh2ZXJ0aWNlcyksXG4gICAgICAgIHNlY29uZFZlcnRleCA9IHNlY29uZCh2ZXJ0aWNlcyksXG4gICAgICAgIHRoaXJkVmVydGV4ID0gdGhpcmQodmVydGljZXMpLFxuICAgICAgICBmaXJzdFZlcnRleFBvc2l0aW9uID0gZmlyc3RWZXJ0ZXguZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgc2Vjb25kVmVydGV4UG9zaXRpb24gPSBzZWNvbmRWZXJ0ZXguZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgdGhpcmRWZXJ0ZXhQb3NpdGlvbiA9IHRoaXJkVmVydGV4LmdldFBvc2l0aW9uKCksXG4gICAgICAgIGZpcnN0RXh0ZW50ID0gc3VidHJhY3QzKHNlY29uZFZlcnRleFBvc2l0aW9uLCBmaXJzdFZlcnRleFBvc2l0aW9uKSxcbiAgICAgICAgc2Vjb25kRXh0ZW50ID0gc3VidHJhY3QzKHRoaXJkVmVydGV4UG9zaXRpb24sIGZpcnN0VmVydGV4UG9zaXRpb24pLFxuICAgICAgICBhcmVhID0gbGVuZ3RoMyhjcm9zczMoZmlyc3RFeHRlbnQsIHNlY29uZEV4dGVudCkpIC8gMjtcblxuICByZXR1cm4gYXJlYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNsb25lRWRnZXMsXG4gIGNsb25lTm9ybWFsLFxuICBjbG9uZVZlcnRpY2VzLFxuICBjYWxjdWxhdGVFZGdlcyxcbiAgY2FsY3VsYXRlTm9ybWFsLFxuICBjYWxjdWxhdGVBcmVhXG59O1xuIl19
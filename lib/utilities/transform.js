'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var vectorMaths = require('../maths/vector'),
    matrixMaths = require('../maths/matrix'),
    matrixUtilities = require('../utilities/matrix');

var multiply4 = matrixMaths.multiply4,
    transform4 = vectorMaths.transform4,
    scaleMatrixFromScale = matrixUtilities.scaleMatrixFromScale,
    positionMatrixFromPosition = matrixUtilities.positionMatrixFromPosition,
    rotationsMatrixFromRotations = matrixUtilities.rotationsMatrixFromRotations;

function composeTransform(scale, rotations, position) {
  var matrix = null;

  if (scale !== null) {
    var scaleMatrix = scaleMatrixFromScale(scale);
    matrix = matrix === null ? scaleMatrix : multiply4(scaleMatrix, matrix);
  }

  if (rotations !== null) {
    var rotationsMatrix = rotationsMatrixFromRotations(rotations);
    matrix = matrix === null ? rotationsMatrix : multiply4(rotationsMatrix, matrix);
  }

  if (position !== null) {
    var positionMatrix = positionMatrixFromPosition(position);
    matrix = matrix === null ? positionMatrix : multiply4(positionMatrix, matrix);
  }

  var transform = matrix === null ? function (vector) {
    return vector;
  } : function (vector) {
    return transform4([].concat(_toConsumableArray(vector), [1]), matrix).slice(0, 3);
  };
  return transform;
}

module.exports = module.exports = {
  composeTransform: composeTransform
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRyYW5zZm9ybS5qcyJdLCJuYW1lcyI6WyJ2ZWN0b3JNYXRocyIsInJlcXVpcmUiLCJtYXRyaXhNYXRocyIsIm1hdHJpeFV0aWxpdGllcyIsIm11bHRpcGx5NCIsInRyYW5zZm9ybTQiLCJzY2FsZU1hdHJpeEZyb21TY2FsZSIsInBvc2l0aW9uTWF0cml4RnJvbVBvc2l0aW9uIiwicm90YXRpb25zTWF0cml4RnJvbVJvdGF0aW9ucyIsImNvbXBvc2VUcmFuc2Zvcm0iLCJzY2FsZSIsInJvdGF0aW9ucyIsInBvc2l0aW9uIiwibWF0cml4Iiwic2NhbGVNYXRyaXgiLCJyb3RhdGlvbnNNYXRyaXgiLCJwb3NpdGlvbk1hdHJpeCIsInRyYW5zZm9ybSIsInZlY3RvciIsInNsaWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxXQUFXLEdBQUdDLE9BQU8sQ0FBQyxpQkFBRCxDQUEzQjtBQUFBLElBQ01DLFdBQVcsR0FBR0QsT0FBTyxDQUFDLGlCQUFELENBRDNCO0FBQUEsSUFFTUUsZUFBZSxHQUFHRixPQUFPLENBQUMscUJBQUQsQ0FGL0I7O0FBSU0sSUFBRUcsU0FBRixHQUFnQkYsV0FBaEIsQ0FBRUUsU0FBRjtBQUFBLElBQ0VDLFVBREYsR0FDaUJMLFdBRGpCLENBQ0VLLFVBREY7QUFBQSxJQUVFQyxvQkFGRixHQUVxRkgsZUFGckYsQ0FFRUcsb0JBRkY7QUFBQSxJQUV3QkMsMEJBRnhCLEdBRXFGSixlQUZyRixDQUV3QkksMEJBRnhCO0FBQUEsSUFFb0RDLDRCQUZwRCxHQUVxRkwsZUFGckYsQ0FFb0RLLDRCQUZwRDs7QUFJTixTQUFTQyxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUNDLFNBQWpDLEVBQTRDQyxRQUE1QyxFQUFzRDtBQUNwRCxNQUFJQyxNQUFNLEdBQUcsSUFBYjs7QUFFQSxNQUFJSCxLQUFLLEtBQUssSUFBZCxFQUFvQjtBQUNsQixRQUFNSSxXQUFXLEdBQUdSLG9CQUFvQixDQUFDSSxLQUFELENBQXhDO0FBRUFHLElBQUFBLE1BQU0sR0FBSUEsTUFBTSxLQUFLLElBQVosR0FDRUMsV0FERixHQUVJVixTQUFTLENBQUNVLFdBQUQsRUFBY0QsTUFBZCxDQUZ0QjtBQUdEOztBQUVELE1BQUlGLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUN0QixRQUFNSSxlQUFlLEdBQUdQLDRCQUE0QixDQUFDRyxTQUFELENBQXBEO0FBRUFFLElBQUFBLE1BQU0sR0FBSUEsTUFBTSxLQUFLLElBQVosR0FDRUUsZUFERixHQUVJWCxTQUFTLENBQUNXLGVBQUQsRUFBa0JGLE1BQWxCLENBRnRCO0FBSUQ7O0FBRUQsTUFBSUQsUUFBUSxLQUFLLElBQWpCLEVBQXVCO0FBQ3JCLFFBQU1JLGNBQWMsR0FBR1QsMEJBQTBCLENBQUNLLFFBQUQsQ0FBakQ7QUFFQUMsSUFBQUEsTUFBTSxHQUFJQSxNQUFNLEtBQUssSUFBWixHQUNHRyxjQURILEdBRUtaLFNBQVMsQ0FBQ1ksY0FBRCxFQUFpQkgsTUFBakIsQ0FGdkI7QUFHRDs7QUFFRCxNQUFNSSxTQUFTLEdBQUlKLE1BQU0sS0FBSyxJQUFaLEdBQ0UsVUFBQ0ssTUFBRDtBQUFBLFdBQVlBLE1BQVo7QUFBQSxHQURGLEdBRUksVUFBQ0EsTUFBRDtBQUFBLFdBQVliLFVBQVUsOEJBQU1hLE1BQU4sSUFBYyxDQUFkLElBQW1CTCxNQUFuQixDQUFWLENBQXFDTSxLQUFyQyxDQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxDQUFaO0FBQUEsR0FGdEI7QUFJQSxTQUFPRixTQUFQO0FBQ0Q7O0FBRURHLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkQsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2hDWixFQUFBQSxnQkFBZ0IsRUFBaEJBO0FBRGdDLENBQWxDIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB2ZWN0b3JNYXRocyA9IHJlcXVpcmUoJy4uL21hdGhzL3ZlY3RvcicpLFxuICAgICAgbWF0cml4TWF0aHMgPSByZXF1aXJlKCcuLi9tYXRocy9tYXRyaXgnKSxcbiAgICAgIG1hdHJpeFV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9tYXRyaXgnKTtcblxuY29uc3QgeyBtdWx0aXBseTQgfSA9IG1hdHJpeE1hdGhzLFxuICAgICAgeyB0cmFuc2Zvcm00IH0gPSB2ZWN0b3JNYXRocyxcbiAgICAgIHsgc2NhbGVNYXRyaXhGcm9tU2NhbGUsIHBvc2l0aW9uTWF0cml4RnJvbVBvc2l0aW9uLCByb3RhdGlvbnNNYXRyaXhGcm9tUm90YXRpb25zIH0gPSBtYXRyaXhVdGlsaXRpZXM7XG5cbmZ1bmN0aW9uIGNvbXBvc2VUcmFuc2Zvcm0oc2NhbGUsIHJvdGF0aW9ucywgcG9zaXRpb24pIHtcbiAgbGV0IG1hdHJpeCA9IG51bGw7XG5cbiAgaWYgKHNjYWxlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2NhbGVNYXRyaXggPSBzY2FsZU1hdHJpeEZyb21TY2FsZShzY2FsZSk7XG5cbiAgICBtYXRyaXggPSAobWF0cml4ID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICBzY2FsZU1hdHJpeCA6XG4gICAgICAgICAgICAgICAgIG11bHRpcGx5NChzY2FsZU1hdHJpeCwgbWF0cml4KTtcbiAgfVxuXG4gIGlmIChyb3RhdGlvbnMgIT09IG51bGwpIHtcbiAgICBjb25zdCByb3RhdGlvbnNNYXRyaXggPSByb3RhdGlvbnNNYXRyaXhGcm9tUm90YXRpb25zKHJvdGF0aW9ucyk7XG5cbiAgICBtYXRyaXggPSAobWF0cml4ID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICByb3RhdGlvbnNNYXRyaXggOlxuICAgICAgICAgICAgICAgICBtdWx0aXBseTQocm90YXRpb25zTWF0cml4LCBtYXRyaXgpO1xuXG4gIH1cblxuICBpZiAocG9zaXRpb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBwb3NpdGlvbk1hdHJpeCA9IHBvc2l0aW9uTWF0cml4RnJvbVBvc2l0aW9uKHBvc2l0aW9uKTtcblxuICAgIG1hdHJpeCA9IChtYXRyaXggPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1hdHJpeCA6XG4gICAgICAgICAgICAgICAgICBtdWx0aXBseTQocG9zaXRpb25NYXRyaXgsIG1hdHJpeCk7XG4gIH1cblxuICBjb25zdCB0cmFuc2Zvcm0gPSAobWF0cml4ID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgKHZlY3RvcikgPT4gdmVjdG9yIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICh2ZWN0b3IpID0+IHRyYW5zZm9ybTQoWyAuLi52ZWN0b3IsIDEgXSwgbWF0cml4KS5zbGljZSgwLCAzKTtcblxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wb3NlVHJhbnNmb3JtXG59O1xuIl19
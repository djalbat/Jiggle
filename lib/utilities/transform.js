"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var vectorMaths = require("../maths/vector"),
    matrixMaths = require("../maths/matrix"),
    matrixUtilities = require("../utilities/matrix");

var multiply4 = matrixMaths.multiply4,
    transform4 = vectorMaths.transform4,
    scaleMatrixFromScale = matrixUtilities.scaleMatrixFromScale,
    positionMatrixFromPosition = matrixUtilities.positionMatrixFromPosition,
    rotationsMatrixFromRotations = matrixUtilities.rotationsMatrixFromRotations;

function composeTransform(scale, rotations, position) {
  var matrix = null;

  if (scale !== null) {
    var scaleMatrix = scaleMatrixFromScale(scale);
    matrix = matrix === null ? scaleMatrix : multiply4(scaleMatrix, matrix);
  }

  if (rotations !== null) {
    var rotationsMatrix = rotationsMatrixFromRotations(rotations);
    matrix = matrix === null ? rotationsMatrix : multiply4(rotationsMatrix, matrix);
  }

  if (position !== null) {
    var positionMatrix = positionMatrixFromPosition(position);
    matrix = matrix === null ? positionMatrix : multiply4(positionMatrix, matrix);
  }

  var transform = matrix === null ? function (vector) {
    return vector;
  } : function (vector) {
    return transform4([].concat(_toConsumableArray(vector), [1]), matrix).slice(0, 3);
  };
  return transform;
}

module.exports = module.exports = {
  composeTransform: composeTransform
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRyYW5zZm9ybS5qcyJdLCJuYW1lcyI6WyJ2ZWN0b3JNYXRocyIsInJlcXVpcmUiLCJtYXRyaXhNYXRocyIsIm1hdHJpeFV0aWxpdGllcyIsIm11bHRpcGx5NCIsInRyYW5zZm9ybTQiLCJzY2FsZU1hdHJpeEZyb21TY2FsZSIsInBvc2l0aW9uTWF0cml4RnJvbVBvc2l0aW9uIiwicm90YXRpb25zTWF0cml4RnJvbVJvdGF0aW9ucyIsImNvbXBvc2VUcmFuc2Zvcm0iLCJzY2FsZSIsInJvdGF0aW9ucyIsInBvc2l0aW9uIiwibWF0cml4Iiwic2NhbGVNYXRyaXgiLCJyb3RhdGlvbnNNYXRyaXgiLCJwb3NpdGlvbk1hdHJpeCIsInRyYW5zZm9ybSIsInZlY3RvciIsInNsaWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxXQUFXLEdBQUdDLE9BQU8sQ0FBQyxpQkFBRCxDQUEzQjtBQUFBLElBQ01DLFdBQVcsR0FBR0QsT0FBTyxDQUFDLGlCQUFELENBRDNCO0FBQUEsSUFFTUUsZUFBZSxHQUFHRixPQUFPLENBQUMscUJBQUQsQ0FGL0I7O0FBSU0sSUFBRUcsU0FBRixHQUFnQkYsV0FBaEIsQ0FBRUUsU0FBRjtBQUFBLElBQ0VDLFVBREYsR0FDaUJMLFdBRGpCLENBQ0VLLFVBREY7QUFBQSxJQUVFQyxvQkFGRixHQUVxRkgsZUFGckYsQ0FFRUcsb0JBRkY7QUFBQSxJQUV3QkMsMEJBRnhCLEdBRXFGSixlQUZyRixDQUV3QkksMEJBRnhCO0FBQUEsSUFFb0RDLDRCQUZwRCxHQUVxRkwsZUFGckYsQ0FFb0RLLDRCQUZwRDs7QUFJTixTQUFTQyxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUNDLFNBQWpDLEVBQTRDQyxRQUE1QyxFQUFzRDtBQUNwRCxNQUFJQyxNQUFNLEdBQUcsSUFBYjs7QUFFQSxNQUFJSCxLQUFLLEtBQUssSUFBZCxFQUFvQjtBQUNsQixRQUFNSSxXQUFXLEdBQUdSLG9CQUFvQixDQUFDSSxLQUFELENBQXhDO0FBRUFHLElBQUFBLE1BQU0sR0FBSUEsTUFBTSxLQUFLLElBQVosR0FDRUMsV0FERixHQUVJVixTQUFTLENBQUNVLFdBQUQsRUFBY0QsTUFBZCxDQUZ0QjtBQUdEOztBQUVELE1BQUlGLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUN0QixRQUFNSSxlQUFlLEdBQUdQLDRCQUE0QixDQUFDRyxTQUFELENBQXBEO0FBRUFFLElBQUFBLE1BQU0sR0FBSUEsTUFBTSxLQUFLLElBQVosR0FDRUUsZUFERixHQUVJWCxTQUFTLENBQUNXLGVBQUQsRUFBa0JGLE1BQWxCLENBRnRCO0FBSUQ7O0FBRUQsTUFBSUQsUUFBUSxLQUFLLElBQWpCLEVBQXVCO0FBQ3JCLFFBQU1JLGNBQWMsR0FBR1QsMEJBQTBCLENBQUNLLFFBQUQsQ0FBakQ7QUFFQUMsSUFBQUEsTUFBTSxHQUFJQSxNQUFNLEtBQUssSUFBWixHQUNHRyxjQURILEdBRUtaLFNBQVMsQ0FBQ1ksY0FBRCxFQUFpQkgsTUFBakIsQ0FGdkI7QUFHRDs7QUFFRCxNQUFNSSxTQUFTLEdBQUlKLE1BQU0sS0FBSyxJQUFaLEdBQ0UsVUFBQ0ssTUFBRDtBQUFBLFdBQVlBLE1BQVo7QUFBQSxHQURGLEdBRUksVUFBQ0EsTUFBRDtBQUFBLFdBQVliLFVBQVUsOEJBQU1hLE1BQU4sSUFBYyxDQUFkLElBQW1CTCxNQUFuQixDQUFWLENBQXFDTSxLQUFyQyxDQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxDQUFaO0FBQUEsR0FGdEI7QUFJQSxTQUFPRixTQUFQO0FBQ0Q7O0FBRURHLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkQsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2hDWixFQUFBQSxnQkFBZ0IsRUFBaEJBO0FBRGdDLENBQWxDIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHZlY3Rvck1hdGhzID0gcmVxdWlyZShcIi4uL21hdGhzL3ZlY3RvclwiKSxcbiAgICAgIG1hdHJpeE1hdGhzID0gcmVxdWlyZShcIi4uL21hdGhzL21hdHJpeFwiKSxcbiAgICAgIG1hdHJpeFV0aWxpdGllcyA9IHJlcXVpcmUoXCIuLi91dGlsaXRpZXMvbWF0cml4XCIpO1xuXG5jb25zdCB7IG11bHRpcGx5NCB9ID0gbWF0cml4TWF0aHMsXG4gICAgICB7IHRyYW5zZm9ybTQgfSA9IHZlY3Rvck1hdGhzLFxuICAgICAgeyBzY2FsZU1hdHJpeEZyb21TY2FsZSwgcG9zaXRpb25NYXRyaXhGcm9tUG9zaXRpb24sIHJvdGF0aW9uc01hdHJpeEZyb21Sb3RhdGlvbnMgfSA9IG1hdHJpeFV0aWxpdGllcztcblxuZnVuY3Rpb24gY29tcG9zZVRyYW5zZm9ybShzY2FsZSwgcm90YXRpb25zLCBwb3NpdGlvbikge1xuICBsZXQgbWF0cml4ID0gbnVsbDtcblxuICBpZiAoc2NhbGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBzY2FsZU1hdHJpeCA9IHNjYWxlTWF0cml4RnJvbVNjYWxlKHNjYWxlKTtcblxuICAgIG1hdHJpeCA9IChtYXRyaXggPT09IG51bGwpID9cbiAgICAgICAgICAgICAgIHNjYWxlTWF0cml4IDpcbiAgICAgICAgICAgICAgICAgbXVsdGlwbHk0KHNjYWxlTWF0cml4LCBtYXRyaXgpO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9ucyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHJvdGF0aW9uc01hdHJpeCA9IHJvdGF0aW9uc01hdHJpeEZyb21Sb3RhdGlvbnMocm90YXRpb25zKTtcblxuICAgIG1hdHJpeCA9IChtYXRyaXggPT09IG51bGwpID9cbiAgICAgICAgICAgICAgIHJvdGF0aW9uc01hdHJpeCA6XG4gICAgICAgICAgICAgICAgIG11bHRpcGx5NChyb3RhdGlvbnNNYXRyaXgsIG1hdHJpeCk7XG5cbiAgfVxuXG4gIGlmIChwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHBvc2l0aW9uTWF0cml4ID0gcG9zaXRpb25NYXRyaXhGcm9tUG9zaXRpb24ocG9zaXRpb24pO1xuXG4gICAgbWF0cml4ID0gKG1hdHJpeCA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uTWF0cml4IDpcbiAgICAgICAgICAgICAgICAgIG11bHRpcGx5NChwb3NpdGlvbk1hdHJpeCwgbWF0cml4KTtcbiAgfVxuXG4gIGNvbnN0IHRyYW5zZm9ybSA9IChtYXRyaXggPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAodmVjdG9yKSA9PiB2ZWN0b3IgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKHZlY3RvcikgPT4gdHJhbnNmb3JtNChbIC4uLnZlY3RvciwgMSBdLCBtYXRyaXgpLnNsaWNlKDAsIDMpO1xuXG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBvc2VUcmFuc2Zvcm1cbn07XG4iXX0=
'use strict';

var Canvas = require('../canvas'),
    ModelView = require('../modelView'),
    Projection = require('../projection');

var intermediate = function intermediate() {
  var canvas = new Canvas(),
      context = canvas.getContext();

  if (!context) {
    return;
  }

  var positionData = [+1.0, +1.0, -1.0, +1.0, +1.0, -1.0, -1.0, -1.0],
      vertexShaderSource = '\n          attribute vec4 aVertexPosition;\n      \n          uniform mat4 uModelViewMatrix;\n          uniform mat4 uProjectionMatrix;\n      \n          void main() {\n            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n          }\n        ',
      fragmentShaderSource = '\n          void main() {\n            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n          }\n        ',
      vertexPositionComponents = 2,
      vertexCount = 4,
      ///
  vertexPositionBuffer = canvas.createBuffer(positionData),
      clientWidth = canvas.getClientWidth(),
      clientHeight = canvas.getClientHeight(),
      shaderProgram = canvas.createShaderProgram(vertexShaderSource, fragmentShaderSource),
      vertexPositionAttributeLocation = canvas.getAttributeLocation(shaderProgram, 'aVertexPosition'),
      projection = new Projection(clientWidth, clientHeight),
      modelView = new ModelView();

  canvas.bindBuffer(vertexPositionBuffer, vertexPositionAttributeLocation, vertexPositionComponents);

  canvas.render(shaderProgram, projection, modelView);

  canvas.draw(vertexCount);
};

module.exports = intermediate;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2VzNi9leGFtcGxlcy9pbnRlcm1lZGlhdGUuanMiXSwibmFtZXMiOlsiQ2FudmFzIiwicmVxdWlyZSIsIk1vZGVsVmlldyIsIlByb2plY3Rpb24iLCJpbnRlcm1lZGlhdGUiLCJjYW52YXMiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsInBvc2l0aW9uRGF0YSIsInZlcnRleFNoYWRlclNvdXJjZSIsImZyYWdtZW50U2hhZGVyU291cmNlIiwidmVydGV4UG9zaXRpb25Db21wb25lbnRzIiwidmVydGV4Q291bnQiLCJ2ZXJ0ZXhQb3NpdGlvbkJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImNsaWVudFdpZHRoIiwiZ2V0Q2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJnZXRDbGllbnRIZWlnaHQiLCJzaGFkZXJQcm9ncmFtIiwiY3JlYXRlU2hhZGVyUHJvZ3JhbSIsInZlcnRleFBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24iLCJnZXRBdHRyaWJ1dGVMb2NhdGlvbiIsInByb2plY3Rpb24iLCJtb2RlbFZpZXciLCJiaW5kQnVmZmVyIiwicmVuZGVyIiwiZHJhdyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLElBQU1BLFNBQVNDLFFBQVEsV0FBUixDQUFmO0FBQUEsSUFDTUMsWUFBWUQsUUFBUSxjQUFSLENBRGxCO0FBQUEsSUFFTUUsYUFBYUYsUUFBUSxlQUFSLENBRm5COztBQUlBLElBQU1HLGVBQWUsU0FBZkEsWUFBZSxHQUFNO0FBQ3pCLE1BQU1DLFNBQVMsSUFBSUwsTUFBSixFQUFmO0FBQUEsTUFDTU0sVUFBVUQsT0FBT0UsVUFBUCxFQURoQjs7QUFHQSxNQUFJLENBQUNELE9BQUwsRUFBYztBQUNaO0FBQ0Q7O0FBRUQsTUFBTUUsZUFBZSxDQUNiLENBQUMsR0FEWSxFQUNQLENBQUMsR0FETSxFQUViLENBQUMsR0FGWSxFQUVQLENBQUMsR0FGTSxFQUdiLENBQUMsR0FIWSxFQUdQLENBQUMsR0FITSxFQUliLENBQUMsR0FKWSxFQUlQLENBQUMsR0FKTSxDQUFyQjtBQUFBLE1BTU1DLDBTQU5OO0FBQUEsTUFnQk1DLCtIQWhCTjtBQUFBLE1BcUJNQywyQkFBMkIsQ0FyQmpDO0FBQUEsTUFzQk1DLGNBQWMsQ0F0QnBCO0FBQUEsTUFzQndCO0FBQ2xCQyx5QkFBdUJSLE9BQU9TLFlBQVAsQ0FBb0JOLFlBQXBCLENBdkI3QjtBQUFBLE1Bd0JNTyxjQUFjVixPQUFPVyxjQUFQLEVBeEJwQjtBQUFBLE1BeUJNQyxlQUFlWixPQUFPYSxlQUFQLEVBekJyQjtBQUFBLE1BMEJNQyxnQkFBZ0JkLE9BQU9lLG1CQUFQLENBQTJCWCxrQkFBM0IsRUFBK0NDLG9CQUEvQyxDQTFCdEI7QUFBQSxNQTJCTVcsa0NBQWtDaEIsT0FBT2lCLG9CQUFQLENBQTRCSCxhQUE1QixFQUEyQyxpQkFBM0MsQ0EzQnhDO0FBQUEsTUE0Qk1JLGFBQWEsSUFBSXBCLFVBQUosQ0FBZVksV0FBZixFQUE0QkUsWUFBNUIsQ0E1Qm5CO0FBQUEsTUE2Qk1PLFlBQVksSUFBSXRCLFNBQUosRUE3QmxCOztBQStCQUcsU0FBT29CLFVBQVAsQ0FBa0JaLG9CQUFsQixFQUF3Q1EsK0JBQXhDLEVBQXlFVix3QkFBekU7O0FBRUFOLFNBQU9xQixNQUFQLENBQWNQLGFBQWQsRUFBNkJJLFVBQTdCLEVBQXlDQyxTQUF6Qzs7QUFFQW5CLFNBQU9zQixJQUFQLENBQVlmLFdBQVo7QUFDRCxDQTVDRDs7QUE4Q0FnQixPQUFPQyxPQUFQLEdBQWlCekIsWUFBakIiLCJmaWxlIjoiaW50ZXJtZWRpYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYW52YXMgPSByZXF1aXJlKCcuLi9jYW52YXMnKSxcbiAgICAgIE1vZGVsVmlldyA9IHJlcXVpcmUoJy4uL21vZGVsVmlldycpLFxuICAgICAgUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4uL3Byb2plY3Rpb24nKTtcblxuY29uc3QgaW50ZXJtZWRpYXRlID0gKCkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBuZXcgQ2FudmFzKCksXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBvc2l0aW9uRGF0YSA9IFtcbiAgICAgICAgICArMS4wLCArMS4wLFxuICAgICAgICAgIC0xLjAsICsxLjAsXG4gICAgICAgICAgKzEuMCwgLTEuMCxcbiAgICAgICAgICAtMS4wLCAtMS4wXG4gICAgICAgIF0sXG4gICAgICAgIHZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhVmVydGV4UG9zaXRpb247XG4gICAgICBcbiAgICAgICAgICB1bmlmb3JtIG1hdDQgdU1vZGVsVmlld01hdHJpeDtcbiAgICAgICAgICB1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG4gICAgICBcbiAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdU1vZGVsVmlld01hdHJpeCAqIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcbiAgICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICAgIHZlcnRleFBvc2l0aW9uQ29tcG9uZW50cyA9IDIsXG4gICAgICAgIHZlcnRleENvdW50ID0gNCwgIC8vL1xuICAgICAgICB2ZXJ0ZXhQb3NpdGlvbkJ1ZmZlciA9IGNhbnZhcy5jcmVhdGVCdWZmZXIocG9zaXRpb25EYXRhKSxcbiAgICAgICAgY2xpZW50V2lkdGggPSBjYW52YXMuZ2V0Q2xpZW50V2lkdGgoKSxcbiAgICAgICAgY2xpZW50SGVpZ2h0ID0gY2FudmFzLmdldENsaWVudEhlaWdodCgpLFxuICAgICAgICBzaGFkZXJQcm9ncmFtID0gY2FudmFzLmNyZWF0ZVNoYWRlclByb2dyYW0odmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSksXG4gICAgICAgIHZlcnRleFBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24gPSBjYW52YXMuZ2V0QXR0cmlidXRlTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpLFxuICAgICAgICBwcm9qZWN0aW9uID0gbmV3IFByb2plY3Rpb24oY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCksXG4gICAgICAgIG1vZGVsVmlldyA9IG5ldyBNb2RlbFZpZXcoKTtcblxuICBjYW52YXMuYmluZEJ1ZmZlcih2ZXJ0ZXhQb3NpdGlvbkJ1ZmZlciwgdmVydGV4UG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiwgdmVydGV4UG9zaXRpb25Db21wb25lbnRzKTtcblxuICBjYW52YXMucmVuZGVyKHNoYWRlclByb2dyYW0sIHByb2plY3Rpb24sIG1vZGVsVmlldyk7XG5cbiAgY2FudmFzLmRyYXcodmVydGV4Q291bnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm1lZGlhdGU7XG4iXX0=
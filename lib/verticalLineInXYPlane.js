'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LineInXYPlane = require('./lineInXYPlane'),
    arrayUtilities = require('./utilities/array'),
    vectorUtilities = require('./utilities/vector'),
    vertexUtilities = require('./utilities/vertex'),
    rotationUtilities = require('./utilities/rotation'),
    approximateUtilities = require('./utilities/approximate');

var first = arrayUtilities.first,
    second = arrayUtilities.second,
    rotateAboutZAxis = vertexUtilities.rotateAboutZAxis,
    add3 = vectorUtilities.add3,
    subtract3 = vectorUtilities.subtract3,
    normalise3 = vectorUtilities.normalise3,
    isApproximatelyEqualToZero = approximateUtilities.isApproximatelyEqualToZero,
    calculateForwardsRotationAboutZAxisMatrix = rotationUtilities.calculateForwardsRotationAboutZAxisMatrix,
    calculateBackwardsRotationAboutZAxisMatrix = rotationUtilities.calculateBackwardsRotationAboutZAxisMatrix;

var VerticalLineInXYPlane = function (_LineInXYPlane) {
  _inherits(VerticalLineInXYPlane, _LineInXYPlane);

  function VerticalLineInXYPlane(position, direction, rotationAboutZAxisMatrix) {
    _classCallCheck(this, VerticalLineInXYPlane);

    var _this = _possibleConstructorReturn(this, (VerticalLineInXYPlane.__proto__ || Object.getPrototypeOf(VerticalLineInXYPlane)).call(this, position, direction));

    _this.rotationAboutZAxisMatrix = rotationAboutZAxisMatrix;
    return _this;
  }

  _createClass(VerticalLineInXYPlane, [{
    key: 'getRotationAboutZAxisMatrix',
    value: function getRotationAboutZAxisMatrix() {
      return this.rotationAboutZAxisMatrix;
    }
  }, {
    key: 'splitFacets',
    value: function splitFacets(facets) {
      var smallerFacets = [],
          forwardsRotationAboutZAxisMatrix = calculateForwardsRotationAboutZAxisMatrix(this.rotationAboutZAxisMatrix),
          backwardsRotationAboutZAxisMatrix = calculateBackwardsRotationAboutZAxisMatrix(this.rotationAboutZAxisMatrix);

      facets.forEach(function (facet) {
        facet.rotateAboutZAxis(forwardsRotationAboutZAxisMatrix);

        this.splitFacet(facet, smallerFacets);
      }.bind(this));

      smallerFacets.forEach(function (smallerFacet) {
        smallerFacet.rotateAboutZAxis(backwardsRotationAboutZAxisMatrix);
      });

      return smallerFacets;
    }
  }, {
    key: 'splitFacet',
    value: function splitFacet(facet, smallerFacets) {
      var intersections = this.calculateIntersectionsWithFacet(facet);

      facet.split(intersections, smallerFacets);
    }
  }, {
    key: 'calculateIntersectionsWithFacet',
    value: function calculateIntersectionsWithFacet(facet) {
      var lines = facet.getLines(),
          intersections = lines.map(function (line) {
        var intersection = this.calculateIntersection(line);

        return intersection;
      }.bind(this));

      return intersections;
    }
  }, {
    key: 'calculateIntersection',
    value: function calculateIntersection(line) {
      var intersection = null;

      var lineNonParallel = isLineNonParallel(line);

      if (lineNonParallel) {
        var lineIntersection = this.calculateLineIntersection(line),
            lineIntersectionNonTrivial = isIntersectionNonTrivial(lineIntersection);

        if (lineIntersectionNonTrivial) {
          intersection = lineIntersection; ///
        }
      }

      return intersection;
    }
  }, {
    key: 'calculateLineIntersection',
    value: function calculateLineIntersection(line) {
      var linePosition = line.getPosition(),
          lineDirection = line.getDirection(),
          positionComponents = this.position,
          ///
      linePositionComponents = linePosition,
          ///
      lineDirectionComponents = lineDirection,
          ///
      firstPositionComponent = first(positionComponents),
          firstLinePositionComponent = first(linePositionComponents),
          firstLineDirectionComponent = first(lineDirectionComponents),
          lineIntersection = (firstPositionComponent - firstLinePositionComponent) / firstLineDirectionComponent;

      return lineIntersection;
    }
  }, {
    key: 'calculateIntersectionWithLine',
    value: function calculateIntersectionWithLine(line, lineIntersection) {
      var linePosition = line.getPosition(),
          lineDirection = line.getDirection(),
          positionComponents = this.position,
          ///
      directionComponents = this.direction,
          ///
      linePositionComponents = linePosition,
          ///
      lineDirectionComponents = lineDirection,
          ///
      secondPositionComponent = second(positionComponents),
          secondDirectionComponent = second(directionComponents),
          secondLinePositionComponent = second(linePositionComponents),
          secondLineDirectionComponent = second(lineDirectionComponents),
          secondIntersectionComponent = secondLinePositionComponent + lineIntersection * secondLineDirectionComponent,
          intersectionWithLine = (secondIntersectionComponent - secondPositionComponent) / secondDirectionComponent;

      return intersectionWithLine;
    }
  }], [{
    key: 'fromLineInXYPlane',
    value: function fromLineInXYPlane(lineInXYPlane) {
      var position = lineInXYPlane.getPosition(),
          direction = lineInXYPlane.getDirection();

      var unitDirection = normalise3(direction),
          unitDirectionComponents = unitDirection,
          ///
      firstUnitDirectionComponent = first(unitDirectionComponents),
          secondUnitDirectionComponent = second(unitDirectionComponents),
          angleOfRotationCosine = +secondUnitDirectionComponent,
          ///
      angleOfRotationSine = -firstUnitDirectionComponent,
          ///
      c = angleOfRotationCosine,
          s = angleOfRotationSine,
          rotationAboutZAxisMatrix = [c, -s, 0, +s, c, 0, 0, 0, 1]; ///

      var startVertex = position.slice(),
          ///
      endVertex = add3(position, direction);

      startVertex = rotateAboutZAxis(startVertex, rotationAboutZAxisMatrix);
      endVertex = rotateAboutZAxis(endVertex, rotationAboutZAxisMatrix);

      position = startVertex;
      direction = subtract3(endVertex, startVertex);

      var verticalLineInXYPlane = new VerticalLineInXYPlane(position, direction, rotationAboutZAxisMatrix);

      return verticalLineInXYPlane;
    }
  }]);

  return VerticalLineInXYPlane;
}(LineInXYPlane);

module.exports = VerticalLineInXYPlane;

function isLineNonParallel(line) {
  var lineDirection = line.getDirection(),
      lineDirectionComponents = lineDirection,
      ///
  firstLineDirectionComponent = first(lineDirectionComponents),
      secondLineDirectionComponent = second(lineDirectionComponents),
      lineAngleTangent = firstLineDirectionComponent / secondLineDirectionComponent,
      lineAngleTangentApproximatelyEqualToZero = isApproximatelyEqualToZero(lineAngleTangent),
      lineParallel = lineAngleTangentApproximatelyEqualToZero,
      ///
  lineNonParallel = !lineParallel;

  return lineNonParallel;
}

function isIntersectionNonTrivial(intersection) {
  var intersectionNonTrivial = intersection > 0 && intersection < 1;

  return intersectionNonTrivial;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi92ZXJ0aWNhbExpbmVJblhZUGxhbmUuanMiXSwibmFtZXMiOlsiTGluZUluWFlQbGFuZSIsInJlcXVpcmUiLCJhcnJheVV0aWxpdGllcyIsInZlY3RvclV0aWxpdGllcyIsInZlcnRleFV0aWxpdGllcyIsInJvdGF0aW9uVXRpbGl0aWVzIiwiYXBwcm94aW1hdGVVdGlsaXRpZXMiLCJmaXJzdCIsInNlY29uZCIsInJvdGF0ZUFib3V0WkF4aXMiLCJhZGQzIiwic3VidHJhY3QzIiwibm9ybWFsaXNlMyIsImlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIiwiY2FsY3VsYXRlRm9yd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgiLCJjYWxjdWxhdGVCYWNrd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgiLCJWZXJ0aWNhbExpbmVJblhZUGxhbmUiLCJwb3NpdGlvbiIsImRpcmVjdGlvbiIsInJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsImZhY2V0cyIsInNtYWxsZXJGYWNldHMiLCJmb3J3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsImJhY2t3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsImZvckVhY2giLCJmYWNldCIsInNwbGl0RmFjZXQiLCJiaW5kIiwic21hbGxlckZhY2V0IiwiaW50ZXJzZWN0aW9ucyIsImNhbGN1bGF0ZUludGVyc2VjdGlvbnNXaXRoRmFjZXQiLCJzcGxpdCIsImxpbmVzIiwiZ2V0TGluZXMiLCJtYXAiLCJsaW5lIiwiaW50ZXJzZWN0aW9uIiwiY2FsY3VsYXRlSW50ZXJzZWN0aW9uIiwibGluZU5vblBhcmFsbGVsIiwiaXNMaW5lTm9uUGFyYWxsZWwiLCJsaW5lSW50ZXJzZWN0aW9uIiwiY2FsY3VsYXRlTGluZUludGVyc2VjdGlvbiIsImxpbmVJbnRlcnNlY3Rpb25Ob25Ucml2aWFsIiwiaXNJbnRlcnNlY3Rpb25Ob25Ucml2aWFsIiwibGluZVBvc2l0aW9uIiwiZ2V0UG9zaXRpb24iLCJsaW5lRGlyZWN0aW9uIiwiZ2V0RGlyZWN0aW9uIiwicG9zaXRpb25Db21wb25lbnRzIiwibGluZVBvc2l0aW9uQ29tcG9uZW50cyIsImxpbmVEaXJlY3Rpb25Db21wb25lbnRzIiwiZmlyc3RQb3NpdGlvbkNvbXBvbmVudCIsImZpcnN0TGluZVBvc2l0aW9uQ29tcG9uZW50IiwiZmlyc3RMaW5lRGlyZWN0aW9uQ29tcG9uZW50IiwiZGlyZWN0aW9uQ29tcG9uZW50cyIsInNlY29uZFBvc2l0aW9uQ29tcG9uZW50Iiwic2Vjb25kRGlyZWN0aW9uQ29tcG9uZW50Iiwic2Vjb25kTGluZVBvc2l0aW9uQ29tcG9uZW50Iiwic2Vjb25kTGluZURpcmVjdGlvbkNvbXBvbmVudCIsInNlY29uZEludGVyc2VjdGlvbkNvbXBvbmVudCIsImludGVyc2VjdGlvbldpdGhMaW5lIiwibGluZUluWFlQbGFuZSIsInVuaXREaXJlY3Rpb24iLCJ1bml0RGlyZWN0aW9uQ29tcG9uZW50cyIsImZpcnN0VW5pdERpcmVjdGlvbkNvbXBvbmVudCIsInNlY29uZFVuaXREaXJlY3Rpb25Db21wb25lbnQiLCJhbmdsZU9mUm90YXRpb25Db3NpbmUiLCJhbmdsZU9mUm90YXRpb25TaW5lIiwiYyIsInMiLCJzdGFydFZlcnRleCIsInNsaWNlIiwiZW5kVmVydGV4IiwidmVydGljYWxMaW5lSW5YWVBsYW5lIiwibW9kdWxlIiwiZXhwb3J0cyIsImxpbmVBbmdsZVRhbmdlbnQiLCJsaW5lQW5nbGVUYW5nZW50QXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIiwibGluZVBhcmFsbGVsIiwiaW50ZXJzZWN0aW9uTm9uVHJpdmlhbCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxnQkFBZ0JDLFFBQVEsaUJBQVIsQ0FBdEI7QUFBQSxJQUNNQyxpQkFBaUJELFFBQVEsbUJBQVIsQ0FEdkI7QUFBQSxJQUVNRSxrQkFBa0JGLFFBQVEsb0JBQVIsQ0FGeEI7QUFBQSxJQUdNRyxrQkFBa0JILFFBQVEsb0JBQVIsQ0FIeEI7QUFB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LGdCQUEzQixDQUxqRDtBQUFBLE1BTU1FLGVBQWVELHdDQU5yQjtBQUFBLE1BTStEO0FBQ3pEdkMsb0JBQWtCLENBQUN3QyxZQVB6Qjs7QUFTQSxTQUFPeEMsZUFBUDtBQUNEOztBQUVELFNBQVNLLHdCQUFULENBQWtDUCxZQUFsQyxFQUFnRDtBQUM5QyxNQUFNMkMseUJBQTJCM0MsZUFBZSxDQUFoQixJQUF3QkEsZUFBZSxDQUF2RTs7QUFFQSxTQUFPMkMsc0JBQVA7QUFDRCIsImZpbGUiOiJ2ZXJ0aWNhbExpbmVJblhZUGxhbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IExpbmVJblhZUGxhbmUgPSByZXF1aXJlKCcuL2xpbmVJblhZUGxhbmUnKSxcbiAgICAgIGFycmF5VXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvYXJyYXknKSxcbiAgICAgIHZlY3RvclV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL3ZlY3RvcicpLFxuICAgICAgdmVydGV4VXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvdmVydGV4JyksXG4gICAgICByb3RhdGlvblV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL3JvdGF0aW9uJyksXG4gICAgICBhcHByb3hpbWF0ZVV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL2FwcHJveGltYXRlJyk7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IHJvdGF0ZUFib3V0WkF4aXMgfSA9IHZlcnRleFV0aWxpdGllcyxcbiAgICAgIHsgYWRkMywgc3VidHJhY3QzLCBub3JtYWxpc2UzIH0gPSB2ZWN0b3JVdGlsaXRpZXMsXG4gICAgICB7IGlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIH0gPSBhcHByb3hpbWF0ZVV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlRm9yd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgsIGNhbGN1bGF0ZUJhY2t3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCB9ID0gcm90YXRpb25VdGlsaXRpZXM7XG5cbmNsYXNzIFZlcnRpY2FsTGluZUluWFlQbGFuZSBleHRlbmRzIExpbmVJblhZUGxhbmUge1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbiwgZGlyZWN0aW9uLCByb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpIHtcbiAgICBzdXBlcihwb3NpdGlvbiwgZGlyZWN0aW9uKTtcblxuICAgIHRoaXMucm90YXRpb25BYm91dFpBeGlzTWF0cml4ID0gcm90YXRpb25BYm91dFpBeGlzTWF0cml4O1xuICB9XG4gIFxuICBnZXRSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRpb25BYm91dFpBeGlzTWF0cml4O1xuICB9XG5cbiAgc3BsaXRGYWNldHMoZmFjZXRzKSB7XG4gICAgY29uc3Qgc21hbGxlckZhY2V0cyA9IFtdLFxuICAgICAgICAgIGZvcndhcmRzUm90YXRpb25BYm91dFpBeGlzTWF0cml4ID0gY2FsY3VsYXRlRm9yd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgodGhpcy5yb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpLFxuICAgICAgICAgIGJhY2t3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCA9IGNhbGN1bGF0ZUJhY2t3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCh0aGlzLnJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCk7XG4gICAgXG4gICAgZmFjZXRzLmZvckVhY2goZnVuY3Rpb24oZmFjZXQpIHtcbiAgICAgIGZhY2V0LnJvdGF0ZUFib3V0WkF4aXMoZm9yd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpO1xuXG4gICAgICB0aGlzLnNwbGl0RmFjZXQoZmFjZXQsIHNtYWxsZXJGYWNldHMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgXG4gICAgc21hbGxlckZhY2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHNtYWxsZXJGYWNldCkge1xuICAgICAgc21hbGxlckZhY2V0LnJvdGF0ZUFib3V0WkF4aXMoYmFja3dhcmRzUm90YXRpb25BYm91dFpBeGlzTWF0cml4KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzbWFsbGVyRmFjZXRzOyAgICBcbiAgfVxuXG4gIHNwbGl0RmFjZXQoZmFjZXQsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gdGhpcy5jYWxjdWxhdGVJbnRlcnNlY3Rpb25zV2l0aEZhY2V0KGZhY2V0KTtcblxuICAgIGZhY2V0LnNwbGl0KGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpO1xuICB9XG5cbiAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uc1dpdGhGYWNldChmYWNldCkge1xuICAgIGNvbnN0IGxpbmVzID0gZmFjZXQuZ2V0TGluZXMoKSxcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zID0gbGluZXMubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHRoaXMuY2FsY3VsYXRlSW50ZXJzZWN0aW9uKGxpbmUpO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuICBcbiAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uKGxpbmUpIHtcbiAgICBsZXQgaW50ZXJzZWN0aW9uID0gbnVsbDtcblxuICAgIGNvbnN0IGxpbmVOb25QYXJhbGxlbCA9IGlzTGluZU5vblBhcmFsbGVsKGxpbmUpO1xuXG4gICAgaWYgKGxpbmVOb25QYXJhbGxlbCkge1xuICAgICAgY29uc3QgbGluZUludGVyc2VjdGlvbiA9IHRoaXMuY2FsY3VsYXRlTGluZUludGVyc2VjdGlvbihsaW5lKSxcbiAgICAgICAgICAgIGxpbmVJbnRlcnNlY3Rpb25Ob25Ucml2aWFsID0gaXNJbnRlcnNlY3Rpb25Ob25Ucml2aWFsKGxpbmVJbnRlcnNlY3Rpb24pO1xuXG4gICAgICBpZiAobGluZUludGVyc2VjdGlvbk5vblRyaXZpYWwpIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdGlvbjsgIC8vL1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gIH1cblxuICBjYWxjdWxhdGVMaW5lSW50ZXJzZWN0aW9uKGxpbmUpIHtcbiAgICBjb25zdCBsaW5lUG9zaXRpb24gPSBsaW5lLmdldFBvc2l0aW9uKCksXG4gICAgICAgICAgbGluZURpcmVjdGlvbiA9IGxpbmUuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgICAgcG9zaXRpb25Db21wb25lbnRzID0gdGhpcy5wb3NpdGlvbiwgLy8vXG4gICAgICAgICAgbGluZVBvc2l0aW9uQ29tcG9uZW50cyA9IGxpbmVQb3NpdGlvbiwgLy8vXG4gICAgICAgICAgbGluZURpcmVjdGlvbkNvbXBvbmVudHMgPSBsaW5lRGlyZWN0aW9uLCAvLy9cbiAgICAgICAgICBmaXJzdFBvc2l0aW9uQ29tcG9uZW50ID0gZmlyc3QocG9zaXRpb25Db21wb25lbnRzKSxcbiAgICAgICAgICBmaXJzdExpbmVQb3NpdGlvbkNvbXBvbmVudCA9IGZpcnN0KGxpbmVQb3NpdGlvbkNvbXBvbmVudHMpLFxuICAgICAgICAgIGZpcnN0TGluZURpcmVjdGlvbkNvbXBvbmVudCA9IGZpcnN0KGxpbmVEaXJlY3Rpb25Db21wb25lbnRzKSxcbiAgICAgICAgICBsaW5lSW50ZXJzZWN0aW9uID0gKGZpcnN0UG9zaXRpb25Db21wb25lbnQgLSBmaXJzdExpbmVQb3NpdGlvbkNvbXBvbmVudCkgLyBmaXJzdExpbmVEaXJlY3Rpb25Db21wb25lbnQ7XG4gICAgXG4gICAgcmV0dXJuIGxpbmVJbnRlcnNlY3Rpb247XG4gIH1cblxuICBjYWxjdWxhdGVJbnRlcnNlY3Rpb25XaXRoTGluZShsaW5lLCBsaW5lSW50ZXJzZWN0aW9uKSB7XG4gICAgY29uc3QgbGluZVBvc2l0aW9uID0gbGluZS5nZXRQb3NpdGlvbigpLFxuICAgICAgICAgIGxpbmVEaXJlY3Rpb24gPSBsaW5lLmdldERpcmVjdGlvbigpLFxuICAgICAgICAgIHBvc2l0aW9uQ29tcG9uZW50cyA9IHRoaXMucG9zaXRpb24sIC8vL1xuICAgICAgICAgIGRpcmVjdGlvbkNvbXBvbmVudHMgPSB0aGlzLmRpcmVjdGlvbiwgLy8vXG4gICAgICAgICAgbGluZVBvc2l0aW9uQ29tcG9uZW50cyA9IGxpbmVQb3NpdGlvbiwgLy8vXG4gICAgICAgICAgbGluZURpcmVjdGlvbkNvbXBvbmVudHMgPSBsaW5lRGlyZWN0aW9uLCAvLy9cbiAgICAgICAgICBzZWNvbmRQb3NpdGlvbkNvbXBvbmVudCA9IHNlY29uZChwb3NpdGlvbkNvbXBvbmVudHMpLFxuICAgICAgICAgIHNlY29uZERpcmVjdGlvbkNvbXBvbmVudCA9IHNlY29uZChkaXJlY3Rpb25Db21wb25lbnRzKSxcbiAgICAgICAgICBzZWNvbmRMaW5lUG9zaXRpb25Db21wb25lbnQgPSBzZWNvbmQobGluZVBvc2l0aW9uQ29tcG9uZW50cyksXG4gICAgICAgICAgc2Vjb25kTGluZURpcmVjdGlvbkNvbXBvbmVudCA9IHNlY29uZChsaW5lRGlyZWN0aW9uQ29tcG9uZW50cyksXG4gICAgICAgICAgc2Vjb25kSW50ZXJzZWN0aW9uQ29tcG9uZW50ID0gc2Vjb25kTGluZVBvc2l0aW9uQ29tcG9uZW50ICsgbGluZUludGVyc2VjdGlvbiAqIHNlY29uZExpbmVEaXJlY3Rpb25Db21wb25lbnQsXG4gICAgICAgICAgaW50ZXJzZWN0aW9uV2l0aExpbmUgPSAoc2Vjb25kSW50ZXJzZWN0aW9uQ29tcG9uZW50IC0gc2Vjb25kUG9zaXRpb25Db21wb25lbnQpIC8gc2Vjb25kRGlyZWN0aW9uQ29tcG9uZW50O1xuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbldpdGhMaW5lO1xuICB9XG5cbiAgc3RhdGljIGZyb21MaW5lSW5YWVBsYW5lKGxpbmVJblhZUGxhbmUpIHtcbiAgICBsZXQgcG9zaXRpb24gPSBsaW5lSW5YWVBsYW5lLmdldFBvc2l0aW9uKCksXG4gICAgICAgIGRpcmVjdGlvbiA9IGxpbmVJblhZUGxhbmUuZ2V0RGlyZWN0aW9uKCk7XG5cbiAgICBjb25zdCB1bml0RGlyZWN0aW9uID0gbm9ybWFsaXNlMyhkaXJlY3Rpb24pLFxuICAgICAgICAgIHVuaXREaXJlY3Rpb25Db21wb25lbnRzID0gdW5pdERpcmVjdGlvbiwgIC8vL1xuICAgICAgICAgIGZpcnN0VW5pdERpcmVjdGlvbkNvbXBvbmVudCA9IGZpcnN0KHVuaXREaXJlY3Rpb25Db21wb25lbnRzKSxcbiAgICAgICAgICBzZWNvbmRVbml0RGlyZWN0aW9uQ29tcG9uZW50ID0gc2Vjb25kKHVuaXREaXJlY3Rpb25Db21wb25lbnRzKSxcbiAgICAgICAgICBhbmdsZU9mUm90YXRpb25Db3NpbmUgPSArc2Vjb25kVW5pdERpcmVjdGlvbkNvbXBvbmVudCwgIC8vL1xuICAgICAgICAgIGFuZ2xlT2ZSb3RhdGlvblNpbmUgPSAtZmlyc3RVbml0RGlyZWN0aW9uQ29tcG9uZW50LCAvLy9cbiAgICAgICAgICBjID0gYW5nbGVPZlJvdGF0aW9uQ29zaW5lLFxuICAgICAgICAgIHMgPSBhbmdsZU9mUm90YXRpb25TaW5lLFxuICAgICAgICAgIHJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCA9IFsgYywgLXMsIDAsICtzLCBjLCAwLCAwLCAwLCAxIF07ICAvLy9cblxuICAgIGxldCBzdGFydFZlcnRleCA9IHBvc2l0aW9uLnNsaWNlKCksIC8vL1xuICAgICAgICBlbmRWZXJ0ZXggPSBhZGQzKHBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuXG4gICAgc3RhcnRWZXJ0ZXggPSByb3RhdGVBYm91dFpBeGlzKHN0YXJ0VmVydGV4LCByb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpO1xuICAgIGVuZFZlcnRleCA9IHJvdGF0ZUFib3V0WkF4aXMoZW5kVmVydGV4LCByb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpO1xuXG4gICAgcG9zaXRpb24gPSBzdGFydFZlcnRleDtcbiAgICBkaXJlY3Rpb24gPSBzdWJ0cmFjdDMoZW5kVmVydGV4LCBzdGFydFZlcnRleCk7XG5cbiAgICBjb25zdCB2ZXJ0aWNhbExpbmVJblhZUGxhbmUgPSBuZXcgVmVydGljYWxMaW5lSW5YWVBsYW5lKHBvc2l0aW9uLCBkaXJlY3Rpb24sIHJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCk7XG5cbiAgICByZXR1cm4gdmVydGljYWxMaW5lSW5YWVBsYW5lO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGljYWxMaW5lSW5YWVBsYW5lO1xuXG5mdW5jdGlvbiBpc0xpbmVOb25QYXJhbGxlbChsaW5lKSB7XG4gIGNvbnN0IGxpbmVEaXJlY3Rpb24gPSBsaW5lLmdldERpcmVjdGlvbigpLFxuICAgICAgICBsaW5lRGlyZWN0aW9uQ29tcG9uZW50cyA9IGxpbmVEaXJlY3Rpb24sIC8vL1xuICAgICAgICBmaXJzdExpbmVEaXJlY3Rpb25Db21wb25lbnQgPSBmaXJzdChsaW5lRGlyZWN0aW9uQ29tcG9uZW50cyksXG4gICAgICAgIHNlY29uZExpbmVEaXJlY3Rpb25Db21wb25lbnQgPSBzZWNvbmQobGluZURpcmVjdGlvbkNvbXBvbmVudHMpLFxuICAgICAgICBsaW5lQW5nbGVUYW5nZW50ID0gZmlyc3RMaW5lRGlyZWN0aW9uQ29tcG9uZW50IC8gc2Vjb25kTGluZURpcmVjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgbGluZUFuZ2xlVGFuZ2VudEFwcHJveGltYXRlbHlFcXVhbFRvWmVybyA9IGlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvKGxpbmVBbmdsZVRhbmdlbnQpLFxuICAgICAgICBsaW5lUGFyYWxsZWwgPSBsaW5lQW5nbGVUYW5nZW50QXBwcm94aW1hdGVseUVxdWFsVG9aZXJvLCAvLy9cbiAgICAgICAgbGluZU5vblBhcmFsbGVsID0gIWxpbmVQYXJhbGxlbDtcblxuICByZXR1cm4gbGluZU5vblBhcmFsbGVsO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyc2VjdGlvbk5vblRyaXZpYWwoaW50ZXJzZWN0aW9uKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbk5vblRyaXZpYWwgPSAoKGludGVyc2VjdGlvbiA+IDAgKSAmJiAoaW50ZXJzZWN0aW9uIDwgMSkpO1xuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25Ob25Ucml2aWFsO1xufVxuIl19
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayUtilities = require('./utilities/array'),
    rotationUtilities = require('./utilities/rotation'),
    approximateUtilities = require('./utilities/approximate');

var first = arrayUtilities.first,
    second = arrayUtilities.second,
    isApproximatelyEqualToZero = approximateUtilities.isApproximatelyEqualToZero,
    rotatePositionAboutZAxis = rotationUtilities.rotatePositionAboutZAxis,
    calculateRotationAboutZAxisMatrix = rotationUtilities.calculateRotationAboutZAxisMatrix,
    calculateForwardsRotationAboutZAxisMatrix = rotationUtilities.calculateForwardsRotationAboutZAxisMatrix,
    calculateBackwardsRotationAboutZAxisMatrix = rotationUtilities.calculateBackwardsRotationAboutZAxisMatrix;

var VerticalLineInXYPlane = function () {
  function VerticalLineInXYPlane(firstPositionComponent, rotationAboutZAxisMatrix) {
    _classCallCheck(this, VerticalLineInXYPlane);

    this.firstPositionComponent = firstPositionComponent;
    this.rotationAboutZAxisMatrix = rotationAboutZAxisMatrix;
  }

  _createClass(VerticalLineInXYPlane, [{
    key: 'getFirstPositionComponent',
    value: function getFirstPositionComponent() {
      return this.firstPositionComponent;
    }
  }, {
    key: 'getRotationAboutZAxisMatrix',
    value: function getRotationAboutZAxisMatrix() {
      return this.rotationAboutZAxisMatrix;
    }
  }, {
    key: 'splitFacets',
    value: function splitFacets(facets) {
      var smallerFacets = [],
          forwardsRotationAboutZAxisMatrix = calculateForwardsRotationAboutZAxisMatrix(this.rotationAboutZAxisMatrix),
          backwardsRotationAboutZAxisMatrix = calculateBackwardsRotationAboutZAxisMatrix(this.rotationAboutZAxisMatrix);

      facets.forEach(function (facet) {
        facet.rotateAboutZAxis(forwardsRotationAboutZAxisMatrix);

        this.splitFacet(facet, smallerFacets);
      }.bind(this));

      smallerFacets.forEach(function (smallerFacet) {
        smallerFacet.rotateAboutZAxis(backwardsRotationAboutZAxisMatrix);
      });

      return smallerFacets;
    }
  }, {
    key: 'splitFacet',
    value: function splitFacet(facet, smallerFacets) {
      var intersections = this.calculateIntersectionsWithFacet(facet);

      facet.split(intersections, smallerFacets);
    }
  }, {
    key: 'calculateIntersectionsWithFacet',
    value: function calculateIntersectionsWithFacet(facet) {
      var edges = facet.getEdges(),
          intersections = edges.map(function (edge) {
        var intersection = this.calculateIntersection(edge);

        return intersection;
      }.bind(this));

      return intersections;
    }
  }, {
    key: 'calculateIntersection',
    value: function calculateIntersection(edge) {
      var intersection = null;

      var edgeNonParallel = isEdgeNonParallel(edge);

      if (edgeNonParallel) {
        var edgeIntersection = this.calculateEdgeIntersection(edge),
            edgeIntersectionNonTrivial = isIntersectionNonTrivial(edgeIntersection);

        if (edgeIntersectionNonTrivial) {
          intersection = edgeIntersection; ///
        }
      }

      return intersection;
    }
  }, {
    key: 'calculateEdgeIntersection',
    value: function calculateEdgeIntersection(edge) {
      var edgePosition = edge.getPosition(),
          edgeExtent = edge.getExtent(),
          edgePositionComponents = edgePosition,
          ///
      edgeExtentComponents = edgeExtent,
          ///
      firstEdgePositionComponent = first(edgePositionComponents),
          firstEdgeExtentComponent = first(edgeExtentComponents),
          edgeIntersection = (this.firstPositionComponent - firstEdgePositionComponent) / firstEdgeExtentComponent;

      return edgeIntersection;
    }
  }], [{
    key: 'fromEdgeInXYPlane',
    value: function fromEdgeInXYPlane(edgeInXYPlane) {
      var edgeInXYPlanePosition = edgeInXYPlane.getPosition(),
          rotationAboutZAxisMatrix = calculateRotationAboutZAxisMatrix(edgeInXYPlane),
          position = rotatePositionAboutZAxis(edgeInXYPlanePosition, rotationAboutZAxisMatrix),
          positionComponents = position,
          ///
      firstPositionComponent = first(positionComponents),
          verticalLineInXYPlane = new VerticalLineInXYPlane(firstPositionComponent, rotationAboutZAxisMatrix);

      return verticalLineInXYPlane;
    }
  }]);

  return VerticalLineInXYPlane;
}();

module.exports = VerticalLineInXYPlane;

function isEdgeNonParallel(edge) {
  var edgeExtent = edge.getExtent(),
      edgeExtentComponents = edgeExtent,
      ///
  firstEdgeExtentComponent = first(edgeExtentComponents),
      secondEdgeExtentComponent = second(edgeExtentComponents),
      edgeAngleTangent = firstEdgeExtentComponent / secondEdgeExtentComponent,
      edgeAngleTangentApproximatelyEqualToZero = isApproximatelyEqualToZero(edgeAngleTangent),
      edgeParallel = edgeAngleTangentApproximatelyEqualToZero,
      ///
  edgeNonParallel = !edgeParallel;

  return edgeNonParallel;
}

function isIntersectionNonTrivial(intersection) {
  var intersectionNonTrivial = intersection > 0 && intersection < 1;

  return intersectionNonTrivial;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi92ZXJ0aWNhbExpbmVJblhZUGxhbmUuanMiXSwibmFtZXMiOlsiYXJyYXlVdGlsaXRpZXMiLCJyZXF1aXJlIiwicm90YXRpb25VdGlsaXRpZXMiLCJhcHByb3hpbWF0ZVV0aWxpdGllcyIsImZpcnN0Iiwic2Vjb25kIiwiaXNBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8iLCJyb3RhdGVQb3NpdGlvbkFib3V0WkF4aXMiLCJjYWxjdWxhdGVSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgiLCJjYWxjdWxhdGVGb3J3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsImNhbGN1bGF0ZUJhY2t3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsIlZlcnRpY2FsTGluZUluWFlQbGFuZSIsImZpcnN0UG9zaXRpb25Db21wb25lbnQiLCJyb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgiLCJmYWNldHMiLCJzbWFsbGVyRmFjZXRzIiwiZm9yd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgiLCJiYWNrd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgiLCJmb3JFYWNoIiwiZmFjZXQiLCJyb3RhdGVBYm91dFpBeGlzIiwic3BsaXRGYWNldCIsImJpbmQiLCJzbWFsbGVyRmFjZXQiLCJpbnRlcnNlY3Rpb25zIiwiY2FsY3VsYXRlSW50ZXJzZWN0aW9uc1dpdGhGYWNldCIsInNwbGl0IiwiZWRnZXMiLCJnZXRFZGdlcyIsIm1hcCIsImVkZ2UiLCJpbnRlcnNlY3Rpb24iLCJjYWxjdWxhdGVJbnRlcnNlY3Rpb24iLCJlZGdlTm9uUGFyYWxsZWwiLCJpc0VkZ2VOb25QYXJhbGxlbCIsImVkZ2VJbnRlcnNlY3Rpb24iLCJjYWxjdWxhdGVFZGdlSW50ZXJzZWN0aW9uIiwiZWRnZUludGVyc2VjdGlvbk5vblRyaXZpYWwiLCJpc0ludGVyc2VjdGlvbk5vblRyaXZpYWwiLCJlZGdlUG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsImVkZ2VFeHRlbnQiLCJnZXRFeHRlbnQiLCJlZGdlUG9zaXRpb25Db21wb25lbnRzIiwiZWRnZUV4dGVudENvbXBvbmVudHMiLCJmaXJzdEVkZ2VQb3NpdGlvbkNvbXBvbmVudCIsImZpcnN0RWRnZUV4dGVudENvbXBvbmVudCIsImVkZ2VJblhZUGxhbmUiLCJlZGdlSW5YWVBsYW5lUG9zaXRpb24iLCJwb3NpdGlvbiIsInBvc2l0aW9uQ29tcG9uZW50cyIsInZlcnRpY2FsTGluZUluWFlQbGFuZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZWNvbmRFZGdlRXh0ZW50Q29tcG9uZW50IiwiZWRnZUFuZ2xlVGFuZ2VudCIsImVkZ2VBbmdsZVRhbmdlbnRBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8iLCJlZGdlUGFyYWxsZWwiLCJpbnRlcnNlY3Rpb25Ob25Ucml2aWFsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUEsSUFBTUEsaUJBQWlCQyxRQUFRLG1CQUFSLENBQXZCO0FBQUEsSUFDTUMsb0JBQW9CRCxRQUFRLHNCQUFSLENBRDFCO0FBQUEsSUFFTUUsdUJBQXVCRixRQUFRLHlCQUFSLENBRjdCOztJQUlRRyxLLEdBQWtCSixjLENBQWxCSSxLO0lBQU9DLE0sR0FBV0wsYyxDQUFYSyxNO0lBQ1BDLDBCLEdBQStCSCxvQixDQUEvQkcsMEI7SUFDQUMsd0IsR0FBdUpMLGlCLENBQXZKSyx3QjtJQUEwQkMsaUMsR0FBNkhOLGlCLENBQTdITSxpQztJQUFtQ0MseUMsR0FBMEZQLGlCLENBQTFGTyx5QztJQUEyQ0MsMEMsR0FBK0NSLGlCLENBQS9DUSwwQzs7SUFFMUdDLHFCO0FBQ0osaUNBQVlDLHNCQUFaLEVBQW9DQyx3QkFBcEMsRUFBOEQ7QUFBQTs7QUFDNUQsU0FBS0Qsc0JBQUwsR0FBOEJBLHNCQUE5QjtBQUNBLFNBQUtDLHdCQUFMLEdBQWdDQSx3QkFBaEM7QUFDRDs7OztnREFFMkI7QUFDMUIsYUFBTyxLQUFLRCxzQkFBWjtBQUNEOzs7a0RBRTZCO0FBQzVCLGFBQU8sS0FBS0Msd0JBQVo7QUFDRDs7O2dDQUVXQyxNLEVBQVE7QUFD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QUFNd0Msb0JBQU4sQ0FGakM7QUFBQSxNQUdNVSw0QkFBNEJqRCxPQUFPdUMsb0JBQVAsQ0FIbEM7QUFBQSxNQUlNVyxtQkFBbUJULDJCQUEyQlEseUJBSnBEO0FBQUEsTUFLTUUsMkNBQTJDbEQsMkJBQTJCaUQsZ0JBQTNCLENBTGpEO0FBQUEsTUFNTUUsZUFBZUQsd0NBTnJCO0FBQUEsTUFNK0Q7QUFDekR2QixvQkFBa0IsQ0FBQ3dCLFlBUHpCOztBQVNBLFNBQU94QixlQUFQO0FBQ0Q7O0FBRUQsU0FBU0ssd0JBQVQsQ0FBa0NQLFlBQWxDLEVBQWdEO0FBQzlDLE1BQU0yQix5QkFBMkIzQixlQUFlLENBQWhCLElBQXdCQSxlQUFlLENBQXZFOztBQUVBLFNBQU8yQixzQkFBUDtBQUNEIiwiZmlsZSI6InZlcnRpY2FsTGluZUluWFlQbGFuZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXJyYXlVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9hcnJheScpLFxuICAgICAgcm90YXRpb25VdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9yb3RhdGlvbicpLFxuICAgICAgYXBwcm94aW1hdGVVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9hcHByb3hpbWF0ZScpO1xuXG5jb25zdCB7IGZpcnN0LCBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzLFxuICAgICAgeyBpc0FwcHJveGltYXRlbHlFcXVhbFRvWmVybyB9ID0gYXBwcm94aW1hdGVVdGlsaXRpZXMsXG4gICAgICB7IHJvdGF0ZVBvc2l0aW9uQWJvdXRaQXhpcywgY2FsY3VsYXRlUm90YXRpb25BYm91dFpBeGlzTWF0cml4LCBjYWxjdWxhdGVGb3J3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCwgY2FsY3VsYXRlQmFja3dhcmRzUm90YXRpb25BYm91dFpBeGlzTWF0cml4IH0gPSByb3RhdGlvblV0aWxpdGllcztcblxuY2xhc3MgVmVydGljYWxMaW5lSW5YWVBsYW5lIHtcbiAgY29uc3RydWN0b3IoZmlyc3RQb3NpdGlvbkNvbXBvbmVudCwgcm90YXRpb25BYm91dFpBeGlzTWF0cml4KSB7XG4gICAgdGhpcy5maXJzdFBvc2l0aW9uQ29tcG9uZW50ID0gZmlyc3RQb3NpdGlvbkNvbXBvbmVudDtcbiAgICB0aGlzLnJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCA9IHJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeDtcbiAgfVxuXG4gIGdldEZpcnN0UG9zaXRpb25Db21wb25lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RQb3NpdGlvbkNvbXBvbmVudDtcbiAgfVxuICBcbiAgZ2V0Um90YXRpb25BYm91dFpBeGlzTWF0cml4KCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeDtcbiAgfVxuXG4gIHNwbGl0RmFjZXRzKGZhY2V0cykge1xuICAgIGNvbnN0IHNtYWxsZXJGYWNldHMgPSBbXSxcbiAgICAgICAgICBmb3J3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCA9IGNhbGN1bGF0ZUZvcndhcmRzUm90YXRpb25BYm91dFpBeGlzTWF0cml4KHRoaXMucm90YXRpb25BYm91dFpBeGlzTWF0cml4KSxcbiAgICAgICAgICBiYWNrd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXggPSBjYWxjdWxhdGVCYWNrd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgodGhpcy5yb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpO1xuICAgIFxuICAgIGZhY2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGZhY2V0KSB7XG4gICAgICBmYWNldC5yb3RhdGVBYm91dFpBeGlzKGZvcndhcmRzUm90YXRpb25BYm91dFpBeGlzTWF0cml4KTtcblxuICAgICAgdGhpcy5zcGxpdEZhY2V0KGZhY2V0LCBzbWFsbGVyRmFjZXRzKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIFxuICAgIHNtYWxsZXJGYWNldHMuZm9yRWFjaChmdW5jdGlvbihzbWFsbGVyRmFjZXQpIHtcbiAgICAgIHNtYWxsZXJGYWNldC5yb3RhdGVBYm91dFpBeGlzKGJhY2t3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc21hbGxlckZhY2V0czsgICAgXG4gIH1cblxuICBzcGxpdEZhY2V0KGZhY2V0LCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IHRoaXMuY2FsY3VsYXRlSW50ZXJzZWN0aW9uc1dpdGhGYWNldChmYWNldCk7XG5cbiAgICBmYWNldC5zcGxpdChpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUludGVyc2VjdGlvbnNXaXRoRmFjZXQoZmFjZXQpIHtcbiAgICBjb25zdCBlZGdlcyA9IGZhY2V0LmdldEVkZ2VzKCksXG4gICAgICAgICAgaW50ZXJzZWN0aW9ucyA9IGVkZ2VzLm1hcChmdW5jdGlvbihlZGdlKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSB0aGlzLmNhbGN1bGF0ZUludGVyc2VjdGlvbihlZGdlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbjtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cbiAgXG4gIGNhbGN1bGF0ZUludGVyc2VjdGlvbihlZGdlKSB7XG4gICAgbGV0IGludGVyc2VjdGlvbiA9IG51bGw7XG5cbiAgICBjb25zdCBlZGdlTm9uUGFyYWxsZWwgPSBpc0VkZ2VOb25QYXJhbGxlbChlZGdlKTtcblxuICAgIGlmIChlZGdlTm9uUGFyYWxsZWwpIHtcbiAgICAgIGNvbnN0IGVkZ2VJbnRlcnNlY3Rpb24gPSB0aGlzLmNhbGN1bGF0ZUVkZ2VJbnRlcnNlY3Rpb24oZWRnZSksXG4gICAgICAgICAgICBlZGdlSW50ZXJzZWN0aW9uTm9uVHJpdmlhbCA9IGlzSW50ZXJzZWN0aW9uTm9uVHJpdmlhbChlZGdlSW50ZXJzZWN0aW9uKTtcblxuICAgICAgaWYgKGVkZ2VJbnRlcnNlY3Rpb25Ob25Ucml2aWFsKSB7XG4gICAgICAgIGludGVyc2VjdGlvbiA9IGVkZ2VJbnRlcnNlY3Rpb247ICAvLy9cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICB9XG5cbiAgY2FsY3VsYXRlRWRnZUludGVyc2VjdGlvbihlZGdlKSB7XG4gICAgY29uc3QgZWRnZVBvc2l0aW9uID0gZWRnZS5nZXRQb3NpdGlvbigpLFxuICAgICAgICAgIGVkZ2VFeHRlbnQgPSBlZGdlLmdldEV4dGVudCgpLFxuICAgICAgICAgIGVkZ2VQb3NpdGlvbkNvbXBvbmVudHMgPSBlZGdlUG9zaXRpb24sIC8vL1xuICAgICAgICAgIGVkZ2VFeHRlbnRDb21wb25lbnRzID0gZWRnZUV4dGVudCwgLy8vXG4gICAgICAgICAgZmlyc3RFZGdlUG9zaXRpb25Db21wb25lbnQgPSBmaXJzdChlZGdlUG9zaXRpb25Db21wb25lbnRzKSxcbiAgICAgICAgICBmaXJzdEVkZ2VFeHRlbnRDb21wb25lbnQgPSBmaXJzdChlZGdlRXh0ZW50Q29tcG9uZW50cyksXG4gICAgICAgICAgZWRnZUludGVyc2VjdGlvbiA9ICh0aGlzLmZpcnN0UG9zaXRpb25Db21wb25lbnQgLSBmaXJzdEVkZ2VQb3NpdGlvbkNvbXBvbmVudCkgLyBmaXJzdEVkZ2VFeHRlbnRDb21wb25lbnQ7XG4gICAgXG4gICAgcmV0dXJuIGVkZ2VJbnRlcnNlY3Rpb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUVkZ2VJblhZUGxhbmUoZWRnZUluWFlQbGFuZSkge1xuICAgIGNvbnN0IGVkZ2VJblhZUGxhbmVQb3NpdGlvbiA9IGVkZ2VJblhZUGxhbmUuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgICByb3RhdGlvbkFib3V0WkF4aXNNYXRyaXggPSBjYWxjdWxhdGVSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgoZWRnZUluWFlQbGFuZSksXG4gICAgICAgICAgcG9zaXRpb24gPSByb3RhdGVQb3NpdGlvbkFib3V0WkF4aXMoZWRnZUluWFlQbGFuZVBvc2l0aW9uLCByb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpLFxuICAgICAgICAgIHBvc2l0aW9uQ29tcG9uZW50cyA9IHBvc2l0aW9uLCAvLy9cbiAgICAgICAgICBmaXJzdFBvc2l0aW9uQ29tcG9uZW50ID0gZmlyc3QocG9zaXRpb25Db21wb25lbnRzKSxcbiAgICAgICAgICB2ZXJ0aWNhbExpbmVJblhZUGxhbmUgPSBuZXcgVmVydGljYWxMaW5lSW5YWVBsYW5lKGZpcnN0UG9zaXRpb25Db21wb25lbnQsIHJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCk7XG5cbiAgICByZXR1cm4gdmVydGljYWxMaW5lSW5YWVBsYW5lO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGljYWxMaW5lSW5YWVBsYW5lO1xuXG5mdW5jdGlvbiBpc0VkZ2VOb25QYXJhbGxlbChlZGdlKSB7XG4gIGNvbnN0IGVkZ2VFeHRlbnQgPSBlZGdlLmdldEV4dGVudCgpLFxuICAgICAgICBlZGdlRXh0ZW50Q29tcG9uZW50cyA9IGVkZ2VFeHRlbnQsIC8vL1xuICAgICAgICBmaXJzdEVkZ2VFeHRlbnRDb21wb25lbnQgPSBmaXJzdChlZGdlRXh0ZW50Q29tcG9uZW50cyksXG4gICAgICAgIHNlY29uZEVkZ2VFeHRlbnRDb21wb25lbnQgPSBzZWNvbmQoZWRnZUV4dGVudENvbXBvbmVudHMpLFxuICAgICAgICBlZGdlQW5nbGVUYW5nZW50ID0gZmlyc3RFZGdlRXh0ZW50Q29tcG9uZW50IC8gc2Vjb25kRWRnZUV4dGVudENvbXBvbmVudCxcbiAgICAgICAgZWRnZUFuZ2xlVGFuZ2VudEFwcHJveGltYXRlbHlFcXVhbFRvWmVybyA9IGlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvKGVkZ2VBbmdsZVRhbmdlbnQpLFxuICAgICAgICBlZGdlUGFyYWxsZWwgPSBlZGdlQW5nbGVUYW5nZW50QXBwcm94aW1hdGVseUVxdWFsVG9aZXJvLCAvLy9cbiAgICAgICAgZWRnZU5vblBhcmFsbGVsID0gIWVkZ2VQYXJhbGxlbDtcblxuICByZXR1cm4gZWRnZU5vblBhcmFsbGVsO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyc2VjdGlvbk5vblRyaXZpYWwoaW50ZXJzZWN0aW9uKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbk5vblRyaXZpYWwgPSAoKGludGVyc2VjdGlvbiA+IDAgKSAmJiAoaW50ZXJzZWN0aW9uIDwgMSkpO1xuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25Ob25Ucml2aWFsO1xufVxuIl19
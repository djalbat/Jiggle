'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./edge'),
    Normal = require('./normal'),
    Vertex = require('./vertex'),
    constants = require('./constants'),
    facetUtilities = require('./utilities/facet'),
    arrayUtilities = require('./utilities/array'),
    midPointUtilities = require('./utilities/midPoint'),
    approximateUtilities = require('./utilities/approximate'),
    intersectionUtilities = require('./utilities/intersection');

var VERTICES_LENGTH = constants.VERTICES_LENGTH,
    push = arrayUtilities.push,
    _permute = arrayUtilities.permute,
    isApproximatelyEqualToZero = approximateUtilities.isApproximatelyEqualToZero,
    calculateEdges = facetUtilities.calculateEdges,
    calculateNormal = facetUtilities.calculateNormal,
    calculateArea = facetUtilities.calculateArea,
    calculateMidPointPosition = midPointUtilities.calculateMidPointPosition,
    isMidPointPositionToOneSideOfMaskingEdges = midPointUtilities.isMidPointPositionToOneSideOfMaskingEdges,
    calculateIntermediateVertexPosition = intersectionUtilities.calculateIntermediateVertexPosition,
    calculateNonNullIntersections = intersectionUtilities.calculateNonNullIntersections,
    calculateNullIntersectionIndex = intersectionUtilities.calculateNullIntersectionIndex,
    calculateNonNullIntersectionIndex = intersectionUtilities.calculateNonNullIntersectionIndex;

var Facet = function () {
  function Facet(vertices, normal, edges) {
    _classCallCheck(this, Facet);

    this.vertices = vertices;
    this.normal = normal;
    this.edges = edges;
  }

  _createClass(Facet, [{
    key: 'getVertices',
    value: function getVertices() {
      return this.vertices;
    }
  }, {
    key: 'getNormal',
    value: function getNormal() {
      return this.normal;
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this.edges;
    }
  }, {
    key: 'getVertexPositions',
    value: function getVertexPositions() {
      var vertexPositions = this.vertices.map(function (vertex) {
        return vertex.getPosition();
      });

      return vertexPositions;
    }
  }, {
    key: 'getVertexNormals',
    value: function getVertexNormals() {
      var extent = this.normal.getExtent(),
          vertexNormal = extent,
          ///
      vertexNormals = [vertexNormal, vertexNormal, vertexNormal];

      return vertexNormals;
    }
  }, {
    key: 'getVertexIndexes',
    value: function getVertexIndexes(index) {
      ///
      var vertexIndex = index * 3,
          vertexIndexes = [vertexIndex + 0, vertexIndex + 1, vertexIndex + 2];

      return vertexIndexes;
    }
  }, {
    key: 'isTooSmall',
    value: function isTooSmall() {
      var area = calculateArea(this.vertices),
          areaApproximatelyEqualToZero = isApproximatelyEqualToZero(area),
          tooSmall = areaApproximatelyEqualToZero; ///

      return tooSmall;
    }
  }, {
    key: 'isMasked',
    value: function isMasked(maskingFacet) {
      var maskingEdges = maskingFacet.getMaskingEdges(),
          midPointPosition = calculateMidPointPosition(this.vertices),
          midPointPositionToOneSideOfMaskingEdges = isMidPointPositionToOneSideOfMaskingEdges(midPointPosition, maskingEdges),
          masked = midPointPositionToOneSideOfMaskingEdges; ///

      return masked;
    }
  }, {
    key: 'permute',
    value: function permute(places) {
      this.vertices = _permute(this.vertices, places);

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotate',
    value: function rotate(rotationQuaternion) {
      this.vertices.forEach(function (vertex) {
        return vertex.rotate(rotationQuaternion);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'applyTransforms',
    value: function applyTransforms(transforms) {
      this.vertices.forEach(function (vertex) {
        return vertex.applyTransforms(transforms);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'splitWithIntersections',
    value: function splitWithIntersections(intersections, smallerFacets) {
      var nonNullIntersections = calculateNonNullIntersections(intersections),
          nonNullIntersectionsLength = nonNullIntersections.length;

      switch (nonNullIntersectionsLength) {
        case 2:
          this.splitWithTwoNonNullIntersections(intersections, smallerFacets);
          break;

        case 1:
          this.splitWithOneNonNullIntersection(intersections, smallerFacets);
          break;

        case 0:
          this.splitWithNoNonNullIntersections(intersections, smallerFacets);
          break;
      }
    }
  }, {
    key: 'splitWithTwoNonNullIntersections',
    value: function splitWithTwoNonNullIntersections(intersections, smallerFacets) {
      var nullIntersectionIndex = calculateNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(1); ///

      this.permute(places);

      var startVertexPositionIndexes = [1, 2],
          endVertexPositionIndexes = [2, 0],
          indexTuples = [[0, 1, 3], [3, 4, 0], [3, 2, 4]];

      this.splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets);
    }
  }, {
    key: 'splitWithOneNonNullIntersection',
    value: function splitWithOneNonNullIntersection(intersections, smallerFacets) {
      var nonNullIntersectionIndex = calculateNonNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nonNullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(0, 1); ///

      this.permute(places);

      var startVertexPositionIndexes = [0],
          endVertexPositionIndexes = [1],
          indexTuples = [[0, 3, 2], [3, 1, 2]];

      this.splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets);
    }
  }, {
    key: 'splitWithNoNonNullIntersections',
    value: function splitWithNoNonNullIntersections(intersections, smallerFacets) {
      var smallerFacet = this.fromVertices(this.vertices); ///

      smallerFacets.push(smallerFacet);
    }
  }, {
    key: 'splitWithIndexTuplesAndIntersections',
    value: function splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets) {
      var _this = this;

      var vertexPositions = this.getVertexPositions(),
          intermediateVertexPositions = intersections.map(function (intersection, index) {
        var startVertexPositionIndex = startVertexPositionIndexes[index],
            endVertexPositionIndex = endVertexPositionIndexes[index],
            startVertexPosition = vertexPositions[startVertexPositionIndex],
            endVertexPosition = vertexPositions[endVertexPositionIndex],
            intermediateVertexPosition = calculateIntermediateVertexPosition(startVertexPosition, endVertexPosition, intersection);

        return intermediateVertexPosition;
      });

      push(vertexPositions, intermediateVertexPositions);

      indexTuples.forEach(function (indexTuple) {
        var positions = vertexPositions,
            ///
        indexes = indexTuple,
            ///
        facet = _this,
            smallerFacet = smallerFacetFromPositionsIndexesAndFacet(positions, indexes, facet),
            smallerFacetTooSmall = smallerFacet.isTooSmall();

        if (!smallerFacetTooSmall) {
          smallerFacets.push(smallerFacet);
        }
      });
    }
  }]);

  return Facet;
}();

module.exports = Facet;

function smallerFacetFromPositionsIndexesAndFacet(positions, indexes, facet) {
  var vertices = indexes.map(function (index) {
    var position = positions[index];

    position = position.slice(); ///

    var vertex = Vertex.fromPosition(position);

    return vertex;
  }),
      smallerFacet = facet.fromVertices(vertices);

  return smallerFacet;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9mYWNldC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIk5vcm1hbCIsIlZlcnRleCIsImNvbnN0YW50cyIsImZhY2V0VXRpbGl0aWVzIiwiYXJyYXlVdGlsaXRpZXMiLCJtaWRQb2ludFV0aWxpdGllcyIsImFwcHJveGltYXRlVXRpbGl0aWVzIiwiaW50ZXJzZWN0aW9uVXRpbGl0aWVzIiwiVkVSVElDRVNfTEVOR1RIIiwicHVzaCIsInBlcm11dGUiLCJpc0FwcHJveGltYXRlbHlFcXVhbFRvWmVybyIsImNhbGN1bGF0ZUVkZ2VzIiwiY2FsY3VsYXRlTm9ybWFsIiwiY2FsY3VsYXRlQXJlYSIsImNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24iLCJpc01pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyIsImNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uIiwiY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbnMiLCJjYWxjdWxhdGVOdWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJGYWNldCIsInZlcnRpY2VzIiwibm9ybWFsIiwiZWRnZXMiLCJ2ZXJ0ZXhQb3NpdGlvbnMiLCJtYXAiLCJ2ZXJ0ZXgiLCJnZXRQb3NpdGlvbiIsImV4dGVudCIsImdldEV4dGVudCIsInZlcnRleE5vcm1hbCIsInZlcnRleE5vcm1hbHMiLCJpbmRleCIsInZlcnRleEluZGV4IiwidmVydGV4SW5kZXhlcyIsImFyZWEiLCJhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIiwidG9vU21hbGwiLCJtYXNraW5nRmFjZXQiLCJtYXNraW5nRWRnZXMiLCJnZXRNYXNraW5nRWRnZXMiLCJtaWRQb2ludFBvc2l0aW9uIiwibWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzIiwibWFza2VkIiwicGxhY2VzIiwicm90YXRpb25RdWF0ZXJuaW9uIiwiZm9yRWFjaCIsInJvdGF0ZSIsInRyYW5zZm9ybXMiLCJhcHBseVRyYW5zZm9ybXMiLCJpbnRlcnNlY3Rpb25zIiwic21hbGxlckZhY2V0cyIsIm5vbk51bGxJbnRlcnNlY3Rpb25zIiwibm9uTnVsbEludGVyc2VjdGlvbnNMZW5ndGgiLCJsZW5ndGgiLCJzcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyIsInNwbGl0V2l0aE9uZU5vbk51bGxJbnRlcnNlY3Rpb24iLCJzcGxpdFdpdGhOb05vbk51bGxJbnRlcnNlY3Rpb25zIiwibnVsbEludGVyc2VjdGlvbkluZGV4Iiwic2xpY2UiLCJzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcyIsImVuZFZlcnRleFBvc2l0aW9uSW5kZXhlcyIsImluZGV4VHVwbGVzIiwic3BsaXRXaXRoSW5kZXhUdXBsZXNBbmRJbnRlcnNlY3Rpb25zIiwibm9uTnVsbEludGVyc2VjdGlvbkluZGV4Iiwic21hbGxlckZhY2V0IiwiZnJvbVZlcnRpY2VzIiwiZ2V0VmVydGV4UG9zaXRpb25zIiwiaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb25zIiwiaW50ZXJzZWN0aW9uIiwic3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4IiwiZW5kVmVydGV4UG9zaXRpb25JbmRleCIsInN0YXJ0VmVydGV4UG9zaXRpb24iLCJlbmRWZXJ0ZXhQb3NpdGlvbiIsImludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uIiwiaW5kZXhUdXBsZSIsInBvc2l0aW9ucyIsImluZGV4ZXMiLCJmYWNldCIsInNtYWxsZXJGYWNldEZyb21Qb3NpdGlvbnNJbmRleGVzQW5kRmFjZXQiLCJzbWFsbGVyRmFjZXRUb29TbWFsbCIsImlzVG9vU21hbGwiLCJtb2R1bGUiLCJleHBvcnRzIiwicG9zaXRpb24iLCJmcm9tUG9zaXRpb24iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQSxJQUFNQSxPQUFPQyxRQUFRLFFBQVIsQ0FBYjtBQUFBLElBQ01DLFNBQVNELFFBQVEsVUFBUixDQURmO0FBQUEsSUFFTUUsU0FBU0YsUUFBUSxVQUFSLENBRmY7QUFBQSxJQUdNRyxZQUFZSCxRQUFRLGFBQVIsQ0FIbEI7QUFBQSxJQUlNSSxpQkFBaUJKLFFBQVEsbUJBQVIsQ0FKdkI7QUFBQSxJQUtNSyxpQkFBaUJMLFFBQVEsbUJBQVIsQ0FMdkI7QUFBQSxJQU1NTSxvQkFBb0JOLFFBQVEsc0JBQVIsQ0FOMUI7QUFBQSxJQU9NTyx1QkFBdUJQLFFBQVEseUJBQVIsQ0FQN0I7QUFBQSxJQVFNUSx3QkFBd0JSLFFBQVEsMEJBQVIsQ0FSOUI7O0FBVU0sSUFBRVMsZUFBRixHQUFzQk4sU0FBdEIsQ0FBRU0sZUFBRjtBQUFBLElBQ0VDLElBREYsR0FDb0JMLGNBRHBCLENBQ0VLLElBREY7QUFBQSxJQUNRQyxRQURSLEdBQ29CTixjQURwQixDQUNRTSxPQURSO0FBQUEsSUFFRUMsMEJBRkYsR0FFaUNMLG9CQUZqQyxDQUVFSywwQkFGRjtBQUFBLElBR0VDLGNBSEYsR0FHcURULGNBSHJELENBR0VTLGNBSEY7QUFBQSxJQUdrQkMsZUFIbEIsR0FHcURWLGNBSHJELENBR2tCVSxlQUhsQjtBQUFBLElBR21DQyxhQUhuQyxHQUdxRFgsY0FIckQsQ0FHbUNXLGFBSG5DO0FBQUEsSUFJRUMseUJBSkYsR0FJMkVWLGlCQUozRSxDQUlFVSx5QkFKRjtBQUFBLElBSTZCQyx5Q0FKN0IsR0FJMkVYLGlCQUozRSxDQUk2QlcseUNBSjdCO0FBQUEsSUFLRUMsbUNBTEYsR0FLNElWLHFCQUw1SSxDQUtFVSxtQ0FMRjtBQUFBLElBS3VDQyw2QkFMdkMsR0FLNElYLHFCQUw1SSxDQUt1Q1csNkJBTHZDO0FBQUEsSUFLc0VDLDhCQUx0RSxHQUs0SVoscUJBTDVJLENBS3NFWSw4QkFMdEU7QUFBQSxJQUtzR0MsaUNBTHRHLEdBSzRJYixxQkFMNUksQ0FLc0dhLGlDQUx0Rzs7SUFPQUMsSztBQUNKLGlCQUFZQyxRQUFaLEVBQXNCQyxNQUF0QixFQUE4QkMsS0FBOUIsRUFBcUM7QUFBQTs7QUFDbkMsU0FBS0YsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxTQUFLQyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLQyxLQUFMLEdBQWFBLEtBQWI7QUFDRDs7OztrQ0FFYTtBQUNaLGFBQU8sS0FBS0YsUUFBWjtBQUNEOzs7Z0NBRVc7QUFDVixhQUFPLEtBQUtDLE1BQVo7QUFDRDs7OytCQUVVO0FBQ1QsYUFBTyxLQUFLQyxLQUFaO0FBQ0Q7Ozt5Q0FFb0I7QUFDbkIsVUFBTUMsa0JBQWtCLEtBQUtILFFBQUwsQ0FBY0ksR0FBZCxDQUFrQixVQUFDQyxNQUFEO0FBQUEsZUFBWUEsT0FBT0MsV0FBUCxFQUFaO0FBQUEsT0FBbEIsQ0FBeEI7O0FBRUEsYUFBT0gsZUFBUDtBQUNEOzs7dUNBRWtCO0FBQ2pCLFVBQU1JLFNBQVMsS0FBS04sTUFBTCxDQUFZTyxTQUFaLEVBQWY7QUFBQSxVQUNNQyxlQUFlRixNQURyQjtBQUFBLFVBQzhCO0FBQ3hCRyxzQkFBZ0IsQ0FDZEQsWUFEYyxFQUVkQSxZQUZjLEVBR2RBLFlBSGMsQ0FGdEI7O0FBUUEsYUFBT0MsYUFBUDtBQUNEOzs7cUNBRWdCQyxLLEVBQU87QUFBRTtBQUN4QixVQUFNQyxjQUFjRCxRQUFRLENBQTVCO0FBQUEsVUFDTUUsZ0JBQWdCLENBQ2RELGNBQWMsQ0FEQSxFQUVkQSxjQUFjLENBRkEsRUFHZEEsY0FBYyxDQUhBLENBRHRCOztBQU9BLGFBQU9DLGFBQVA7QUFDRDs7O2lDQUVZO0FBQ1gsVUFBTUMsT0FBT3RCLGNBQWMsS0FBS1EsUUFBbkIsQ0FBYjtBQUFBLFVBQ01lLCtCQUErQjFCLDJCQUEyQnlCLElBQTNCLENBRHJDO0FBQUEsVUFFTUUsV0FBV0QsNEJBRmpCLENBRFcsQ0FHcUM7O0FBRWhELGFBQU9DLFFBQVA7QUFDRDs7OzZCQUVRQyxZLEVBQWM7QUFDckIsVUFBTUMsZUFBZUQsYUFBYUUsZUFBYixFQUFyQjtBQUFBLFVBQ01DLG1CQUFtQjNCLDBCQUEwQixLQUFLTyxRQUEvQixDQUR6QjtBQUFBLFVBRU1xQiwwQ0FBMEMzQiwwQ0FBMEMwQixnQkFBMUMsRUFBNERGLFlBQTVELENBRmhEO0FBQUEsVUFHTUksU0FBU0QsdUNBSGYsQ0FEcUIsQ0FJb0M7O0FBRXpELGFBQU9DLE1BQVA7QUFDRDs7OzRCQUVPQyxNLEVBQVE7QUFDZCxXQUFLdkIsUUFBTCxHQUFnQlosU0FBUSxLQUFLWSxRQUFiLEVBQXVCdUIsTUFBdkIsQ0FBaEI7O0FBRUEsV0FBS3RCLE1BQUwsR0FBY1YsZ0JBQWdCLEtBQUtTLFFBQXJCLEVBQStCdEIsTUFBL0IsQ0FBZDs7QUFFQSxXQUFLd0IsS0FBTCxHQUFhWixlQUFlLEtBQUtVLFFBQXBCLEVBQThCeEIsSUFBOUIsQ0FBYjtBQUNEOzs7MkJBRU1nRCxrQixFQUFvQjtBQUN6QixXQUFLeEIsUUFBTCxDQUFjeUIsT0FBZCxDQUFzQixVQUFDcEIsTUFBRDtBQUFBLGVBQVlBLE9BQU9xQixNQUFQLENBQWNGLGtCQUFkLENBQVo7QUFBQSxPQUF0Qjs7QUFFQSxXQUFLdkIsTUFBTCxHQUFjVixnQkFBZ0IsS0FBS1MsUUFBckIsRUFBK0J0QixNQUEvQixDQUFkOztBQUVBLFdBQUt3QixLQUFMLEdBQWFaLGVBQWUsS0FBS1UsUUFBcEIsRUFBOEJ4QixJQUE5QixDQUFiO0FBQ0Q7OztvQ0FFZW1ELFUsRUFBWTtBQUMxQixXQUFLM0IsUUFBTCxDQUFjeUIsT0FBZCxDQUFzQixVQUFDcEIsTUFBRDtBQUFBLGVBQVlBLE9BQU91QixlQUFQLENBQXVCRCxVQUF2QixDQUFaO0FBQUEsT0FBdEI7O0FBRUEsV0FBSzFCLE1BQUwsR0FBY1YsZ0JBQWdCLEtBQUtTLFFBQXJCLEVBQStCdEIsTUFBL0IsQ0FBZDs7QUFFQSxXQUFLd0IsS0FBTCxHQUFhWixlQUFlLEtBQUtVLFFBQXBCLEVBQThCeEIsSUFBOUIsQ0FBYjtBQUNEOzs7MkNBRXNCcUQsYSxFQUFlQyxhLEVBQWU7QUFDbkQsVUFBTUMsdUJBQXVCbkMsOEJBQThCaUMsYUFBOUIsQ0FBN0I7QUFBQSxVQUNNRyw2QkFBNkJELHFCQUFxQkUsTUFEeEQ7O0FBR0EsY0FBUUQsMEJBQVI7QUFDRSxhQUFLLENBQUw7QUFDRSxlQUFLRSxnQ0FBTCxDQUFzQ0wsYUFBdEMsRUFBcURDLGFBQXJEO0FBQ0E7O0FBRUYsYUFBSyxDQUFMO0FBQ0UsZUFBS0ssK0JBQUwsQ0FBcUNOLGFBQXJDLEVBQW9EQyxhQUFwRDtBQUNBOztBQUVGLGFBQUssQ0FBTDtBQUNFLGVBQUtNLCtCQUFMLENBQXFDUCxhQUFyQyxFQUFvREMsYUFBcEQ7QUFDQTtBQVhKO0FBYUQ7OztxREFFZ0NELGEsRUFBZUMsYSxFQUFlO0FBQzdELFVBQU1PLHdCQUF3QnhDLCtCQUErQmdDLGFBQS9CLENBQTlCO0FBQUEsVUFDTU4sU0FBUyxDQUFDckMsa0JBQWtCbUQscUJBQW5CLElBQTRDbkQsZUFEM0Q7O0FBR0EyQyxzQkFBZ0J6QyxTQUFReUMsYUFBUixFQUF1Qk4sTUFBdkIsQ0FBaEI7O0FBRUFNLHNCQUFnQkEsY0FBY1MsS0FBZCxDQUFvQixDQUFwQixDQUFoQixDQU42RCxDQU1yQjs7QUFFeEMsV0FBS2xELE9BQUwsQ0FBYW1DLE1BQWI7O0FBRUEsVUFBTWdCLDZCQUE2QixDQUFFLENBQUYsRUFBSyxDQUFMLENBQW5DO0FBQUEsVUFDTUMsMkJBQTJCLENBQUUsQ0FBRixFQUFLLENBQUwsQ0FEakM7QUFBQSxVQUVNQyxjQUFjLENBRVosQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsQ0FGWSxFQUdaLENBQUUsQ0FBRixFQUFLLENBQUwsRUFBUSxDQUFSLENBSFksRUFJWixDQUFFLENBQUYsRUFBSyxDQUFMLEVBQVEsQ0FBUixDQUpZLENBRnBCOztBQVVBLFdBQUtDLG9DQUFMLENBQTBDSCwwQkFBMUMsRUFBc0VDLHdCQUF0RSxFQUFnR0MsV0FBaEcsRUFBNkdaLGFBQTdHLEVBQTRIQyxhQUE1SDtBQUNEOzs7b0RBRStCRCxhLEVBQWVDLGEsRUFBZTtBQUM1RCxVQUFNYSwyQkFBMkI3QyxrQ0FBa0MrQixhQUFsQyxDQUFqQztBQUFBLFVBQ01OLFNBQVMsQ0FBQ3JDLGtCQUFrQnlELHdCQUFuQixJQUErQ3pELGVBRDlEOztBQUdBMkMsc0JBQWdCekMsU0FBUXlDLGFBQVIsRUFBdUJOLE1BQXZCLENBQWhCOztBQUVBTSxzQkFBZ0JBLGNBQWNTLEtBQWQsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsQ0FBaEIsQ0FONEQsQ0FNaEI7O0FBRTVDLFdBQUtsRCxPQUFMLENBQWFtQyxNQUFiOztBQUVBLFVBQU1nQiw2QkFBNkIsQ0FBRSxDQUFGLENBQW5DO0FBQUEsVUFDTUMsMkJBQTJCLENBQUUsQ0FBRixDQURqQztBQUFBLFVBRU1DLGNBQWMsQ0FFWixDQUFFLENBQUYsRUFBSyxDQUFMLEVBQVEsQ0FBUixDQUZZLEVBR1osQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsQ0FIWSxDQUZwQjs7QUFTQSxXQUFLQyxvQ0FBTCxDQUEwQ0gsMEJBQTFDLEVBQXNFQyx3QkFBdEUsRUFBZ0dDLFdBQWhHLEVBQTZHWixhQUE3RyxFQUE0SEMsYUFBNUg7QUFDRDs7O29EQUUrQkQsYSxFQUFlQyxhLEVBQWU7QUFDNUQsVUFBTWMsZUFBZSxLQUFLQyxZQUFMLENBQWtCLEtBQUs3QyxRQUF2QixDQUFyQixDQUQ0RCxDQUNKOztBQUV4RDhCLG9CQUFjM0MsSUFBZCxDQUFtQnlELFlBQW5CO0FBQ0Q7Ozt5REFFb0NMLDBCLEVBQTRCQyx3QixFQUEwQkMsVyxFQUFhWixhLEVBQWVDLGEsRUFBZTtBQUFBOztBQUNwSSxVQUFNM0Isa0JBQWtCLEtBQUsyQyxrQkFBTCxFQUF4QjtBQUFBLFVBQ01DLDhCQUE4QmxCLGNBQWN6QixHQUFkLENBQWtCLFVBQUM0QyxZQUFELEVBQWVyQyxLQUFmLEVBQXlCO0FBQ3ZFLFlBQU1zQywyQkFBMkJWLDJCQUEyQjVCLEtBQTNCLENBQWpDO0FBQUEsWUFDTXVDLHlCQUF5QlYseUJBQXlCN0IsS0FBekIsQ0FEL0I7QUFBQSxZQUVNd0Msc0JBQXNCaEQsZ0JBQWdCOEMsd0JBQWhCLENBRjVCO0FBQUEsWUFHTUcsb0JBQW9CakQsZ0JBQWdCK0Msc0JBQWhCLENBSDFCO0FBQUEsWUFJTUcsNkJBQTZCMUQsb0NBQW9Dd0QsbUJBQXBDLEVBQXlEQyxpQkFBekQsRUFBNEVKLFlBQTVFLENBSm5DOztBQU1BLGVBQU9LLDBCQUFQO0FBQ0QsT0FSNkIsQ0FEcEM7O0FBV0FsRSxXQUFLZ0IsZUFBTCxFQUFzQjRDLDJCQUF0Qjs7QUFFQU4sa0JBQVloQixPQUFaLENBQW9CLFVBQUM2QixVQUFELEVBQWdCO0FBQ2xDLFlBQU1DLFlBQVlwRCxlQUFsQjtBQUFBLFlBQW9DO0FBQzlCcUQsa0JBQVVGLFVBRGhCO0FBQUEsWUFDNkI7QUFDdkJHLGdCQUFRLEtBRmQ7QUFBQSxZQUdNYixlQUFlYyx5Q0FBeUNILFNBQXpDLEVBQW9EQyxPQUFwRCxFQUE2REMsS0FBN0QsQ0FIckI7QUFBQSxZQUlNRSx1QkFBdUJmLGFBQWFnQixVQUFiLEVBSjdCOztBQU1BLFlBQUksQ0FBQ0Qsb0JBQUwsRUFBMkI7QUFDekI3Qix3QkFBYzNDLElBQWQsQ0FBbUJ5RCxZQUFuQjtBQUNEO0FBQ0YsT0FWRDtBQVdEOzs7Ozs7QUFHSGlCLE9BQU9DLE9BQVAsR0FBaUIvRCxLQUFqQjs7QUFFQSxTQUFTMkQsd0NBQVQsQ0FBa0RILFNBQWxELEVBQTZEQyxPQUE3RCxFQUFzRUMsS0FBdEUsRUFBNkU7QUFDM0UsTUFBTXpELFdBQVd3RCxRQUFRcEQsR0FBUixDQUFZLFVBQUNPLEtBQUQsRUFBVztBQUNoQyxRQUFJb0QsV0FBV1IsVUFBVTVDLEtBQVYsQ0FBZjs7QUFFQW9ELGVBQVdBLFNBQVN6QixLQUFULEVBQVgsQ0FIZ0MsQ0FHSDs7QUFFN0IsUUFBTWpDLFNBQVMxQixPQUFPcUYsWUFBUCxDQUFvQkQsUUFBcEIsQ0FBZjs7QUFFQSxXQUFPMUQsTUFBUDtBQUNELEdBUlUsQ0FBakI7QUFBQSxNQVNNdUMsZUFBZWEsTUFBTVosWUFBTixDQUFtQjdDLFFBQW5CLENBVHJCOztBQVdBLFNBQU80QyxZQUFQO0FBQ0QiLCJmaWxlIjoiZmFjZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEVkZ2UgPSByZXF1aXJlKCcuL2VkZ2UnKSxcbiAgICAgIE5vcm1hbCA9IHJlcXVpcmUoJy4vbm9ybWFsJyksXG4gICAgICBWZXJ0ZXggPSByZXF1aXJlKCcuL3ZlcnRleCcpLFxuICAgICAgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKSxcbiAgICAgIGZhY2V0VXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvZmFjZXQnKSxcbiAgICAgIGFycmF5VXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvYXJyYXknKSxcbiAgICAgIG1pZFBvaW50VXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvbWlkUG9pbnQnKSxcbiAgICAgIGFwcHJveGltYXRlVXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvYXBwcm94aW1hdGUnKSxcbiAgICAgIGludGVyc2VjdGlvblV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL2ludGVyc2VjdGlvbicpO1xuXG5jb25zdCB7IFZFUlRJQ0VTX0xFTkdUSCB9ID0gY29uc3RhbnRzLFxuICAgICAgeyBwdXNoLCBwZXJtdXRlIH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgaXNBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8gfSA9IGFwcHJveGltYXRlVXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVFZGdlcywgY2FsY3VsYXRlTm9ybWFsLCBjYWxjdWxhdGVBcmVhIH0gPSBmYWNldFV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlTWlkUG9pbnRQb3NpdGlvbiwgaXNNaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMgfSA9IG1pZFBvaW50VXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVJbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbiwgY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbnMsIGNhbGN1bGF0ZU51bGxJbnRlcnNlY3Rpb25JbmRleCwgY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbkluZGV4IH0gPSBpbnRlcnNlY3Rpb25VdGlsaXRpZXM7XG5cbmNsYXNzIEZhY2V0IHtcbiAgY29uc3RydWN0b3IodmVydGljZXMsIG5vcm1hbCwgZWRnZXMpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICB9XG5cbiAgZ2V0VmVydGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVydGljZXM7XG4gIH1cblxuICBnZXROb3JtYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsO1xuICB9XG5cbiAgZ2V0RWRnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXM7XG4gIH1cbiAgXG4gIGdldFZlcnRleFBvc2l0aW9ucygpIHtcbiAgICBjb25zdCB2ZXJ0ZXhQb3NpdGlvbnMgPSB0aGlzLnZlcnRpY2VzLm1hcCgodmVydGV4KSA9PiB2ZXJ0ZXguZ2V0UG9zaXRpb24oKSk7XG4gICAgXG4gICAgcmV0dXJuIHZlcnRleFBvc2l0aW9ucztcbiAgfVxuICBcbiAgZ2V0VmVydGV4Tm9ybWFscygpIHtcbiAgICBjb25zdCBleHRlbnQgPSB0aGlzLm5vcm1hbC5nZXRFeHRlbnQoKSxcbiAgICAgICAgICB2ZXJ0ZXhOb3JtYWwgPSBleHRlbnQsICAvLy9cbiAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzID0gW1xuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgIF07XG4gICAgXG4gICAgcmV0dXJuIHZlcnRleE5vcm1hbHM7XG4gIH1cbiAgXG4gIGdldFZlcnRleEluZGV4ZXMoaW5kZXgpIHsgLy8vXG4gICAgY29uc3QgdmVydGV4SW5kZXggPSBpbmRleCAqIDMsXG4gICAgICAgICAgdmVydGV4SW5kZXhlcyA9IFtcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMCxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMSxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMixcbiAgICAgICAgICBdO1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXhJbmRleGVzO1xuICB9XG5cbiAgaXNUb29TbWFsbCgpIHtcbiAgICBjb25zdCBhcmVhID0gY2FsY3VsYXRlQXJlYSh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICBhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvID0gaXNBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8oYXJlYSksXG4gICAgICAgICAgdG9vU21hbGwgPSBhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvOyAgLy8vXG5cbiAgICByZXR1cm4gdG9vU21hbGw7XG4gIH1cblxuICBpc01hc2tlZChtYXNraW5nRmFjZXQpIHtcbiAgICBjb25zdCBtYXNraW5nRWRnZXMgPSBtYXNraW5nRmFjZXQuZ2V0TWFza2luZ0VkZ2VzKCksXG4gICAgICAgICAgbWlkUG9pbnRQb3NpdGlvbiA9IGNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24odGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgbWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzID0gaXNNaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMobWlkUG9pbnRQb3NpdGlvbiwgbWFza2luZ0VkZ2VzKSxcbiAgICAgICAgICBtYXNrZWQgPSBtaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXM7ICAvLy9cbiAgICBcbiAgICByZXR1cm4gbWFza2VkO1xuICB9XG5cbiAgcGVybXV0ZShwbGFjZXMpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gcGVybXV0ZSh0aGlzLnZlcnRpY2VzLCBwbGFjZXMpO1xuXG4gICAgdGhpcy5ub3JtYWwgPSBjYWxjdWxhdGVOb3JtYWwodGhpcy52ZXJ0aWNlcywgTm9ybWFsKTtcblxuICAgIHRoaXMuZWRnZXMgPSBjYWxjdWxhdGVFZGdlcyh0aGlzLnZlcnRpY2VzLCBFZGdlKTtcbiAgfVxuXG4gIHJvdGF0ZShyb3RhdGlvblF1YXRlcm5pb24pIHtcbiAgICB0aGlzLnZlcnRpY2VzLmZvckVhY2goKHZlcnRleCkgPT4gdmVydGV4LnJvdGF0ZShyb3RhdGlvblF1YXRlcm5pb24pKTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICBhcHBseVRyYW5zZm9ybXModHJhbnNmb3Jtcykge1xuICAgIHRoaXMudmVydGljZXMuZm9yRWFjaCgodmVydGV4KSA9PiB2ZXJ0ZXguYXBwbHlUcmFuc2Zvcm1zKHRyYW5zZm9ybXMpKTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICBzcGxpdFdpdGhJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBub25OdWxsSW50ZXJzZWN0aW9ucyA9IGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIG5vbk51bGxJbnRlcnNlY3Rpb25zTGVuZ3RoID0gbm9uTnVsbEludGVyc2VjdGlvbnMubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCkge1xuICAgICAgY2FzZSAyIDpcbiAgICAgICAgdGhpcy5zcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMSA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoT25lTm9uTnVsbEludGVyc2VjdGlvbihpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMCA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoTm9Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICBzcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3QgbnVsbEludGVyc2VjdGlvbkluZGV4ID0gY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4KGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIHBsYWNlcyA9IChWRVJUSUNFU19MRU5HVEggLSBudWxsSW50ZXJzZWN0aW9uSW5kZXgpICUgVkVSVElDRVNfTEVOR1RIO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IHBlcm11dGUoaW50ZXJzZWN0aW9ucywgcGxhY2VzKTtcblxuICAgIGludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDEpOyAvLy9cblxuICAgIHRoaXMucGVybXV0ZShwbGFjZXMpO1xuXG4gICAgY29uc3Qgc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMgPSBbIDEsIDIgXSxcbiAgICAgICAgICBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMgPSBbIDIsIDAgXSxcbiAgICAgICAgICBpbmRleFR1cGxlcyA9IFtcblxuICAgICAgICAgICAgWyAwLCAxLCAzIF0sXG4gICAgICAgICAgICBbIDMsIDQsIDAgXSxcbiAgICAgICAgICAgIFsgMywgMiwgNCBdLFxuXG4gICAgICAgICAgXTtcblxuICAgIHRoaXMuc3BsaXRXaXRoSW5kZXhUdXBsZXNBbmRJbnRlcnNlY3Rpb25zKHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleGVzLCBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMsIGluZGV4VHVwbGVzLCBpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgfVxuXG4gIHNwbGl0V2l0aE9uZU5vbk51bGxJbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IG5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCA9IGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25JbmRleChpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBwbGFjZXMgPSAoVkVSVElDRVNfTEVOR1RIIC0gbm9uTnVsbEludGVyc2VjdGlvbkluZGV4KSAlIFZFUlRJQ0VTX0xFTkdUSDtcblxuICAgIGludGVyc2VjdGlvbnMgPSBwZXJtdXRlKGludGVyc2VjdGlvbnMsIHBsYWNlcyk7XG5cbiAgICBpbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0aW9ucy5zbGljZSgwLCAxKTsgIC8vL1xuXG4gICAgdGhpcy5wZXJtdXRlKHBsYWNlcyk7XG5cbiAgICBjb25zdCBzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcyA9IFsgMCBdLFxuICAgICAgICAgIGVuZFZlcnRleFBvc2l0aW9uSW5kZXhlcyA9IFsgMSBdLFxuICAgICAgICAgIGluZGV4VHVwbGVzID0gW1xuXG4gICAgICAgICAgICBbIDAsIDMsIDIgXSxcbiAgICAgICAgICAgIFsgMywgMSwgMiBdLFxuXG4gICAgICAgICAgXTtcblxuICAgIHRoaXMuc3BsaXRXaXRoSW5kZXhUdXBsZXNBbmRJbnRlcnNlY3Rpb25zKHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleGVzLCBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMsIGluZGV4VHVwbGVzLCBpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgfVxuXG4gIHNwbGl0V2l0aE5vTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IHNtYWxsZXJGYWNldCA9IHRoaXMuZnJvbVZlcnRpY2VzKHRoaXMudmVydGljZXMpOyAgLy8vXG5cbiAgICBzbWFsbGVyRmFjZXRzLnB1c2goc21hbGxlckZhY2V0KTtcbiAgfVxuXG4gIHNwbGl0V2l0aEluZGV4VHVwbGVzQW5kSW50ZXJzZWN0aW9ucyhzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcywgZW5kVmVydGV4UG9zaXRpb25JbmRleGVzLCBpbmRleFR1cGxlcywgaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IHZlcnRleFBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4UG9zaXRpb25zKCksXG4gICAgICAgICAgaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb25zID0gaW50ZXJzZWN0aW9ucy5tYXAoKGludGVyc2VjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleCA9IHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgIGVuZFZlcnRleFBvc2l0aW9uSW5kZXggPSBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgc3RhcnRWZXJ0ZXhQb3NpdGlvbiA9IHZlcnRleFBvc2l0aW9uc1tzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgZW5kVmVydGV4UG9zaXRpb24gPSB2ZXJ0ZXhQb3NpdGlvbnNbZW5kVmVydGV4UG9zaXRpb25JbmRleF0sXG4gICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbiA9IGNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uKHN0YXJ0VmVydGV4UG9zaXRpb24sIGVuZFZlcnRleFBvc2l0aW9uLCBpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb247XG4gICAgICAgICAgfSk7XG5cbiAgICBwdXNoKHZlcnRleFBvc2l0aW9ucywgaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb25zKTtcblxuICAgIGluZGV4VHVwbGVzLmZvckVhY2goKGluZGV4VHVwbGUpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHZlcnRleFBvc2l0aW9ucywgIC8vL1xuICAgICAgICAgICAgaW5kZXhlcyA9IGluZGV4VHVwbGUsICAvLy9cbiAgICAgICAgICAgIGZhY2V0ID0gdGhpcywgXG4gICAgICAgICAgICBzbWFsbGVyRmFjZXQgPSBzbWFsbGVyRmFjZXRGcm9tUG9zaXRpb25zSW5kZXhlc0FuZEZhY2V0KHBvc2l0aW9ucywgaW5kZXhlcywgZmFjZXQpLFxuICAgICAgICAgICAgc21hbGxlckZhY2V0VG9vU21hbGwgPSBzbWFsbGVyRmFjZXQuaXNUb29TbWFsbCgpO1xuXG4gICAgICBpZiAoIXNtYWxsZXJGYWNldFRvb1NtYWxsKSB7XG4gICAgICAgIHNtYWxsZXJGYWNldHMucHVzaChzbWFsbGVyRmFjZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjZXQ7XG5cbmZ1bmN0aW9uIHNtYWxsZXJGYWNldEZyb21Qb3NpdGlvbnNJbmRleGVzQW5kRmFjZXQocG9zaXRpb25zLCBpbmRleGVzLCBmYWNldCkge1xuICBjb25zdCB2ZXJ0aWNlcyA9IGluZGV4ZXMubWFwKChpbmRleCkgPT4ge1xuICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHBvc2l0aW9uc1tpbmRleF07XG4gICAgXG4gICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbi5zbGljZSgpOyAvLy9cbiAgICBcbiAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSBWZXJ0ZXguZnJvbVBvc2l0aW9uKHBvc2l0aW9uKTtcblxuICAgICAgICAgIHJldHVybiB2ZXJ0ZXg7XG4gICAgICAgIH0pLFxuICAgICAgICBzbWFsbGVyRmFjZXQgPSBmYWNldC5mcm9tVmVydGljZXModmVydGljZXMpO1xuXG4gIHJldHVybiBzbWFsbGVyRmFjZXQ7XG59XG4iXX0=
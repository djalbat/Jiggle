'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./edge'),
    Normal = require('./normal'),
    Vertex = require('./vertex'),
    constants = require('./constants'),
    facetUtilities = require('./utilities/facet'),
    arrayUtilities = require('./utilities/array'),
    midPointUtilities = require('./utilities/midPoint'),
    approximateUtilities = require('./utilities/approximate'),
    intersectionUtilities = require('./utilities/intersection');

var VERTICES_LENGTH = constants.VERTICES_LENGTH,
    push = arrayUtilities.push,
    _permute = arrayUtilities.permute,
    isApproximatelyEqualToZero = approximateUtilities.isApproximatelyEqualToZero,
    calculateEdges = facetUtilities.calculateEdges,
    calculateNormal = facetUtilities.calculateNormal,
    calculateArea = facetUtilities.calculateArea,
    calculateMidPointPosition = midPointUtilities.calculateMidPointPosition,
    isMidPointPositionToOneSideOfMaskingEdges = midPointUtilities.isMidPointPositionToOneSideOfMaskingEdges,
    calculateIntermediateVertexPosition = intersectionUtilities.calculateIntermediateVertexPosition,
    calculateNonNullIntersections = intersectionUtilities.calculateNonNullIntersections,
    calculateNullIntersectionIndex = intersectionUtilities.calculateNullIntersectionIndex,
    calculateNonNullIntersectionIndex = intersectionUtilities.calculateNonNullIntersectionIndex;

var Facet = function () {
  function Facet(vertices, normal, edges) {
    _classCallCheck(this, Facet);

    this.vertices = vertices;
    this.normal = normal;
    this.edges = edges;
  }

  _createClass(Facet, [{
    key: 'getVertices',
    value: function getVertices() {
      return this.vertices;
    }
  }, {
    key: 'getNormal',
    value: function getNormal() {
      return this.normal;
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this.edges;
    }
  }, {
    key: 'getVertexPositions',
    value: function getVertexPositions() {
      var vertexPositions = this.vertices.map(function (vertex) {
        var vertexPosition = vertex.getPosition();

        return vertexPosition;
      });

      return vertexPositions;
    }
  }, {
    key: 'getVertexNormals',
    value: function getVertexNormals() {
      var extent = this.normal.getExtent(),
          vertexNormal = extent,
          ///
      vertexNormals = [vertexNormal, vertexNormal, vertexNormal];

      return vertexNormals;
    }
  }, {
    key: 'getVertexIndexes',
    value: function getVertexIndexes(index) {
      ///
      var vertexIndex = index * 3,
          vertexIndexes = [vertexIndex + 0, vertexIndex + 1, vertexIndex + 2];

      return vertexIndexes;
    }
  }, {
    key: 'isTooSmall',
    value: function isTooSmall() {
      var area = calculateArea(this.vertices),
          areaApproximatelyEqualToZero = isApproximatelyEqualToZero(area),
          tooSmall = areaApproximatelyEqualToZero; ///

      return tooSmall;
    }
  }, {
    key: 'isMasked',
    value: function isMasked(maskingFacet) {
      var maskingEdges = maskingFacet.getMaskingEdges(),
          midPointPosition = calculateMidPointPosition(this.vertices),
          midPointPositionToOneSideOfMaskingEdges = isMidPointPositionToOneSideOfMaskingEdges(midPointPosition, maskingEdges),
          masked = midPointPositionToOneSideOfMaskingEdges; ///

      return masked;
    }
  }, {
    key: 'permute',
    value: function permute(places) {
      this.vertices = _permute(this.vertices, places);

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotate',
    value: function rotate(rotationQuaternion) {
      this.vertices.forEach(function (vertex) {
        vertex.rotate(rotationQuaternion);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotateAboutZAxis',
    value: function rotateAboutZAxis(rotationAboutZAxisMatrix) {
      this.vertices.forEach(function (vertex) {
        vertex.rotateAboutZAxis(rotationAboutZAxisMatrix);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'applyTransforms',
    value: function applyTransforms(transforms) {
      this.vertices.forEach(function (vertex) {
        vertex.applyTransforms(transforms);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'splitWithIntersections',
    value: function splitWithIntersections(intersections, smallerFacets) {
      var nonNullIntersections = calculateNonNullIntersections(intersections),
          nonNullIntersectionsLength = nonNullIntersections.length;

      switch (nonNullIntersectionsLength) {
        case 2:
          this.splitWithTwoNonNullIntersections(intersections, smallerFacets);
          break;

        case 1:
          this.splitWithOneNonNullIntersection(intersections, smallerFacets);
          break;

        case 0:
          this.splitWithNoNonNullIntersections(intersections, smallerFacets);
          break;
      }
    }
  }, {
    key: 'splitWithTwoNonNullIntersections',
    value: function splitWithTwoNonNullIntersections(intersections, smallerFacets) {
      var nullIntersectionIndex = calculateNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(1); ///

      this.permute(places);

      var startVertexPositionIndices = [1, 2],
          endVertexPositionIndices = [2, 0],
          smallerFacetsIndices = [[0, 1, 3], [3, 4, 0], [3, 2, 4]];

      this.splitWithIndicesAndIntersections(startVertexPositionIndices, endVertexPositionIndices, smallerFacetsIndices, intersections, smallerFacets);
    }
  }, {
    key: 'splitWithOneNonNullIntersection',
    value: function splitWithOneNonNullIntersection(intersections, smallerFacets) {
      var nonNullIntersectionIndex = calculateNonNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nonNullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(0, 1); ///

      this.permute(places);

      var startVertexPositionIndices = [0],
          endVertexPositionIndices = [1],
          smallerFacetsIndices = [[0, 3, 2], [3, 1, 2]];

      this.splitWithIndicesAndIntersections(startVertexPositionIndices, endVertexPositionIndices, smallerFacetsIndices, intersections, smallerFacets);
    }
  }, {
    key: 'splitWithNoNonNullIntersections',
    value: function splitWithNoNonNullIntersections(intersections, smallerFacets) {
      var smallerFacet = this.fromVertices(this.vertices); ///

      smallerFacets.push(smallerFacet);
    }
  }, {
    key: 'splitWithIndicesAndIntersections',
    value: function splitWithIndicesAndIntersections(startVertexPositionIndices, endVertexPositionIndices, smallerFacetsIndices, intersections, smallerFacets) {
      var vertexPositions = this.getVertexPositions(),
          intermediateVertexPositions = intersections.map(function (intersection, index) {
        var startVertexPositionIndex = startVertexPositionIndices[index],
            endVertexPositionIndex = endVertexPositionIndices[index],
            startVertexPosition = vertexPositions[startVertexPositionIndex],
            endVertexPosition = vertexPositions[endVertexPositionIndex],
            intermediateVertexPosition = calculateIntermediateVertexPosition(startVertexPosition, endVertexPosition, intersection);

        return intermediateVertexPosition;
      });

      push(vertexPositions, intermediateVertexPositions);

      smallerFacetsIndices.forEach(function (smallerFacetIndices) {
        var positions = vertexPositions,
            ///
        indices = smallerFacetIndices,
            ///
        facet = this,
            ///
        smallerFacet = smallerFacetFromPositionsAndIndices(positions, indices, facet),
            smallerFacetTooSmall = smallerFacet.isTooSmall();

        if (!smallerFacetTooSmall) {
          smallerFacets.push(smallerFacet);
        }
      }.bind(this));
    }
  }]);

  return Facet;
}();

module.exports = Facet;

function smallerFacetFromPositionsAndIndices(positions, indices, facet) {
  var vertices = indices.map(function (index) {
    var position = clonePosition(positions[index]),
        vertex = Vertex.fromPosition(position);

    return vertex;
  }),
      smallerFacet = facet.fromVertices(vertices);

  return smallerFacet;
}

function clonePosition(position) {
  return position.slice();
} ///
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9mYWNldC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIk5vcm1hbCIsIlZlcnRleCIsImNvbnN0YW50cyIsImZhY2V0VXRpbGl0aWVzIiwiYXJyYXlVdGlsaXRpZXMiLCJtaWRQb2ludFV0aWxpdGllcyIsImFwcHJveGltYXRlVXRpbGl0aWVzIiwiaW50ZXJzZWN0aW9uVXRpbGl0aWVzIiwiVkVSVElDRVNfTEVOR1RIIiwicHVzaCIsInBlcm11dGUiLCJpc0FwcHJveGltYXRlbHlFcXVhbFRvWmVybyIsImNhbGN1bGF0ZUVkZ2VzIiwiY2FsY3VsYXRlTm9ybWFsIiwiY2FsY3VsYXRlQXJlYSIsImNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24iLCJpc01pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyIsImNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uIiwiY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbnMiLCJjYWxjdWxhdGVOdWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJGYWNldCIsInZlcnRpY2VzIiwibm9ybWFsIiwiZWRnZXMiLCJ2ZXJ0ZXhQb3NpdGlvbnMiLCJtYXAiLCJ2ZXJ0ZXgiLCJ2ZXJ0ZXhQb3NpdGlvbiIsImdldFBvc2l0aW9uIiwiZXh0ZW50IiwiZ2V0RXh0ZW50IiwidmVydGV4Tm9ybWFsIiwidmVydGV4Tm9ybWFscyIsImluZGV4IiwidmVydGV4SW5kZXgiLCJ2ZXJ0ZXhJbmRleGVzIiwiYXJlYSIsImFyZWFBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8iLCJ0b29TbWFsbCIsIm1hc2tpbmdGYWNldCIsIm1hc2tpbmdFZGdlcyIsImdldE1hc2tpbmdFZGdlcyIsIm1pZFBvaW50UG9zaXRpb24iLCJtaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMiLCJtYXNrZWQiLCJwbGFjZXMiLCJyb3RhdGlvblF1YXRlcm5pb24iLCJmb3JFYWNoIiwicm90YXRlIiwicm90YXRpb25BYm91dFpBeGlzTWF0cml4Iiwicm90YXRlQWJvdXRaQXhpcyIsInRyYW5zZm9ybXMiLCJhcHBseVRyYW5zZm9ybXMiLCJpbnRlcnNlY3Rpb25zIiwic21hbGxlckZhY2V0cyIsIm5vbk51bGxJbnRlcnNlY3Rpb25zIiwibm9uTnVsbEludGVyc2VjdGlvbnNMZW5ndGgiLCJsZW5ndGgiLCJzcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyIsInNwbGl0V2l0aE9uZU5vbk51bGxJbnRlcnNlY3Rpb24iLCJzcGxpdFdpdGhOb05vbk51bGxJbnRlcnNlY3Rpb25zIiwibnVsbEludGVyc2VjdGlvbkluZGV4Iiwic2xpY2UiLCJzdGFydFZlcnRleFBvc2l0aW9uSW5kaWNlcyIsImVuZFZlcnRleFBvc2l0aW9uSW5kaWNlcyIsInNtYWxsZXJGYWNldHNJbmRpY2VzIiwic3BsaXRXaXRoSW5kaWNlc0FuZEludGVyc2VjdGlvbnMiLCJub25OdWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJzbWFsbGVyRmFjZXQiLCJmcm9tVmVydGljZXMiLCJnZXRWZXJ0ZXhQb3NpdGlvbnMiLCJpbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbnMiLCJpbnRlcnNlY3Rpb24iLCJzdGFydFZlcnRleFBvc2l0aW9uSW5kZXgiLCJlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4Iiwic3RhcnRWZXJ0ZXhQb3NpdGlvbiIsImVuZFZlcnRleFBvc2l0aW9uIiwiaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb24iLCJzbWFsbGVyRmFjZXRJbmRpY2VzIiwicG9zaXRpb25zIiwiaW5kaWNlcyIsImZhY2V0Iiwic21hbGxlckZhY2V0RnJvbVBvc2l0aW9uc0FuZEluZGljZXMiLCJzbWFsbGVyRmFjZXRUb29TbWFsbCIsImlzVG9vU21hbGwiLCJiaW5kIiwibW9kdWxlIiwiZXhwb3J0cyIsInBvc2l0aW9uIiwiY2xvbmVQb3NpdGlvbiIsImZyb21Qb3NpdGlvbiJdLCJtYXBwaW5n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RUFBd0U7QUFDdEUsTUFBTTVELFdBQVcyRCxRQUFRdkQsR0FBUixDQUFZLFVBQVNRLEtBQVQsRUFBZ0I7QUFDckMsUUFBTXVELFdBQVdDLGNBQWNWLFVBQVU5QyxLQUFWLENBQWQsQ0FBakI7QUFBQSxRQUNNUCxTQUFTMUIsT0FBTzBGLFlBQVAsQ0FBb0JGLFFBQXBCLENBRGY7O0FBR0EsV0FBTzlELE1BQVA7QUFDRCxHQUxVLENBQWpCO0FBQUEsTUFNTTBDLGVBQWVhLE1BQU1aLFlBQU4sQ0FBbUJoRCxRQUFuQixDQU5yQjs7QUFRQSxTQUFPK0MsWUFBUDtBQUNEOztBQUVELFNBQVNxQixhQUFULENBQXVCRCxRQUF2QixFQUFpQztBQUFFLFNBQU9BLFNBQVMxQixLQUFULEVBQVA7QUFBMEIsQyxDQUFDIiwiZmlsZSI6ImZhY2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFZGdlID0gcmVxdWlyZSgnLi9lZGdlJyksXG4gICAgICBOb3JtYWwgPSByZXF1aXJlKCcuL25vcm1hbCcpLFxuICAgICAgVmVydGV4ID0gcmVxdWlyZSgnLi92ZXJ0ZXgnKSxcbiAgICAgIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyksXG4gICAgICBmYWNldFV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL2ZhY2V0JyksXG4gICAgICBhcnJheVV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL2FycmF5JyksXG4gICAgICBtaWRQb2ludFV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL21pZFBvaW50JyksXG4gICAgICBhcHByb3hpbWF0ZVV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL2FwcHJveGltYXRlJyksXG4gICAgICBpbnRlcnNlY3Rpb25VdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9pbnRlcnNlY3Rpb24nKTtcblxuY29uc3QgeyBWRVJUSUNFU19MRU5HVEggfSA9IGNvbnN0YW50cyxcbiAgICAgIHsgcHVzaCwgcGVybXV0ZSB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IGlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIH0gPSBhcHByb3hpbWF0ZVV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlRWRnZXMsIGNhbGN1bGF0ZU5vcm1hbCwgY2FsY3VsYXRlQXJlYSB9ID0gZmFjZXRVdGlsaXRpZXMsXG4gICAgICB7IGNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24sIGlzTWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzIH0gPSBtaWRQb2ludFV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlSW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb24sIGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zLCBjYWxjdWxhdGVOdWxsSW50ZXJzZWN0aW9uSW5kZXgsIGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCB9ID0gaW50ZXJzZWN0aW9uVXRpbGl0aWVzO1xuXG5jbGFzcyBGYWNldCB7XG4gIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCBub3JtYWwsIGVkZ2VzKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgIHRoaXMuZWRnZXMgPSBlZGdlcztcbiAgfVxuXG4gIGdldFZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzO1xuICB9XG5cbiAgZ2V0Tm9ybWFsKCkge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbDtcbiAgfVxuXG4gIGdldEVkZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzO1xuICB9XG4gIFxuICBnZXRWZXJ0ZXhQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgdmVydGV4UG9zaXRpb25zID0gdGhpcy52ZXJ0aWNlcy5tYXAoZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICBjb25zdCB2ZXJ0ZXhQb3NpdGlvbiA9IHZlcnRleC5nZXRQb3NpdGlvbigpO1xuICAgICAgXG4gICAgICByZXR1cm4gdmVydGV4UG9zaXRpb247XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHZlcnRleFBvc2l0aW9ucztcbiAgfVxuICBcbiAgZ2V0VmVydGV4Tm9ybWFscygpIHtcbiAgICBjb25zdCBleHRlbnQgPSB0aGlzLm5vcm1hbC5nZXRFeHRlbnQoKSxcbiAgICAgICAgICB2ZXJ0ZXhOb3JtYWwgPSBleHRlbnQsICAvLy9cbiAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzID0gW1xuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgIF07XG4gICAgXG4gICAgcmV0dXJuIHZlcnRleE5vcm1hbHM7XG4gIH1cbiAgXG4gIGdldFZlcnRleEluZGV4ZXMoaW5kZXgpIHsgLy8vXG4gICAgY29uc3QgdmVydGV4SW5kZXggPSBpbmRleCAqIDMsXG4gICAgICAgICAgdmVydGV4SW5kZXhlcyA9IFtcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMCxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMSxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMixcbiAgICAgICAgICBdO1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXhJbmRleGVzO1xuICB9XG5cbiAgaXNUb29TbWFsbCgpIHtcbiAgICBjb25zdCBhcmVhID0gY2FsY3VsYXRlQXJlYSh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICBhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvID0gaXNBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8oYXJlYSksXG4gICAgICAgICAgdG9vU21hbGwgPSBhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvOyAgLy8vXG5cbiAgICByZXR1cm4gdG9vU21hbGw7XG4gIH1cblxuICBpc01hc2tlZChtYXNraW5nRmFjZXQpIHtcbiAgICBjb25zdCBtYXNraW5nRWRnZXMgPSBtYXNraW5nRmFjZXQuZ2V0TWFza2luZ0VkZ2VzKCksXG4gICAgICAgICAgbWlkUG9pbnRQb3NpdGlvbiA9IGNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24odGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgbWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzID0gaXNNaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMobWlkUG9pbnRQb3NpdGlvbiwgbWFza2luZ0VkZ2VzKSxcbiAgICAgICAgICBtYXNrZWQgPSBtaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXM7ICAvLy9cbiAgICBcbiAgICByZXR1cm4gbWFza2VkO1xuICB9XG5cbiAgcGVybXV0ZShwbGFjZXMpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gcGVybXV0ZSh0aGlzLnZlcnRpY2VzLCBwbGFjZXMpO1xuXG4gICAgdGhpcy5ub3JtYWwgPSBjYWxjdWxhdGVOb3JtYWwodGhpcy52ZXJ0aWNlcywgTm9ybWFsKTtcblxuICAgIHRoaXMuZWRnZXMgPSBjYWxjdWxhdGVFZGdlcyh0aGlzLnZlcnRpY2VzLCBFZGdlKTtcbiAgfVxuXG4gIHJvdGF0ZShyb3RhdGlvblF1YXRlcm5pb24pIHtcbiAgICB0aGlzLnZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICB2ZXJ0ZXgucm90YXRlKHJvdGF0aW9uUXVhdGVybmlvbik7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5vcm1hbCA9IGNhbGN1bGF0ZU5vcm1hbCh0aGlzLnZlcnRpY2VzLCBOb3JtYWwpO1xuXG4gICAgdGhpcy5lZGdlcyA9IGNhbGN1bGF0ZUVkZ2VzKHRoaXMudmVydGljZXMsIEVkZ2UpO1xuICB9XG5cbiAgcm90YXRlQWJvdXRaQXhpcyhyb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpIHtcbiAgICB0aGlzLnZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICB2ZXJ0ZXgucm90YXRlQWJvdXRaQXhpcyhyb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5ub3JtYWwgPSBjYWxjdWxhdGVOb3JtYWwodGhpcy52ZXJ0aWNlcywgTm9ybWFsKTtcblxuICAgIHRoaXMuZWRnZXMgPSBjYWxjdWxhdGVFZGdlcyh0aGlzLnZlcnRpY2VzLCBFZGdlKTtcbiAgfVxuXG4gIGFwcGx5VHJhbnNmb3Jtcyh0cmFuc2Zvcm1zKSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgdmVydGV4LmFwcGx5VHJhbnNmb3Jtcyh0cmFuc2Zvcm1zKTtcbiAgICB9KTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICBzcGxpdFdpdGhJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBub25OdWxsSW50ZXJzZWN0aW9ucyA9IGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIG5vbk51bGxJbnRlcnNlY3Rpb25zTGVuZ3RoID0gbm9uTnVsbEludGVyc2VjdGlvbnMubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCkge1xuICAgICAgY2FzZSAyIDpcbiAgICAgICAgdGhpcy5zcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMSA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoT25lTm9uTnVsbEludGVyc2VjdGlvbihpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMCA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoTm9Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICBzcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3QgbnVsbEludGVyc2VjdGlvbkluZGV4ID0gY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4KGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIHBsYWNlcyA9IChWRVJUSUNFU19MRU5HVEggLSBudWxsSW50ZXJzZWN0aW9uSW5kZXgpICUgVkVSVElDRVNfTEVOR1RIO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IHBlcm11dGUoaW50ZXJzZWN0aW9ucywgcGxhY2VzKTtcblxuICAgIGludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDEpOyAvLy9cblxuICAgIHRoaXMucGVybXV0ZShwbGFjZXMpO1xuXG4gICAgY29uc3Qgc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGljZXMgPSBbIDEsIDIgXSxcbiAgICAgICAgICBlbmRWZXJ0ZXhQb3NpdGlvbkluZGljZXMgPSBbIDIsIDAgXSxcbiAgICAgICAgICBzbWFsbGVyRmFjZXRzSW5kaWNlcyA9IFtcblxuICAgICAgICAgICAgWyAwLCAxLCAzIF0sXG4gICAgICAgICAgICBbIDMsIDQsIDAgXSxcbiAgICAgICAgICAgIFsgMywgMiwgNCBdLFxuXG4gICAgICAgICAgXTtcblxuICAgIHRoaXMuc3BsaXRXaXRoSW5kaWNlc0FuZEludGVyc2VjdGlvbnMoc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGljZXMsIGVuZFZlcnRleFBvc2l0aW9uSW5kaWNlcywgc21hbGxlckZhY2V0c0luZGljZXMsIGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpO1xuICB9XG5cbiAgc3BsaXRXaXRoT25lTm9uTnVsbEludGVyc2VjdGlvbihpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3Qgbm9uTnVsbEludGVyc2VjdGlvbkluZGV4ID0gY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbkluZGV4KGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIHBsYWNlcyA9IChWRVJUSUNFU19MRU5HVEggLSBub25OdWxsSW50ZXJzZWN0aW9uSW5kZXgpICUgVkVSVElDRVNfTEVOR1RIO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IHBlcm11dGUoaW50ZXJzZWN0aW9ucywgcGxhY2VzKTtcblxuICAgIGludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDAsIDEpOyAgLy8vXG5cbiAgICB0aGlzLnBlcm11dGUocGxhY2VzKTtcblxuICAgIGNvbnN0IHN0YXJ0VmVydGV4UG9zaXRpb25JbmRpY2VzID0gWyAwIF0sXG4gICAgICAgICAgZW5kVmVydGV4UG9zaXRpb25JbmRpY2VzID0gWyAxIF0sXG4gICAgICAgICAgc21hbGxlckZhY2V0c0luZGljZXMgPSBbXG5cbiAgICAgICAgICAgIFsgMCwgMywgMiBdLFxuICAgICAgICAgICAgWyAzLCAxLCAyIF0sXG5cbiAgICAgICAgICBdO1xuXG4gICAgdGhpcy5zcGxpdFdpdGhJbmRpY2VzQW5kSW50ZXJzZWN0aW9ucyhzdGFydFZlcnRleFBvc2l0aW9uSW5kaWNlcywgZW5kVmVydGV4UG9zaXRpb25JbmRpY2VzLCBzbWFsbGVyRmFjZXRzSW5kaWNlcywgaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gIH1cblxuICBzcGxpdFdpdGhOb05vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBzbWFsbGVyRmFjZXQgPSB0aGlzLmZyb21WZXJ0aWNlcyh0aGlzLnZlcnRpY2VzKTsgIC8vL1xuXG4gICAgc21hbGxlckZhY2V0cy5wdXNoKHNtYWxsZXJGYWNldCk7XG4gIH1cblxuICBzcGxpdFdpdGhJbmRpY2VzQW5kSW50ZXJzZWN0aW9ucyhzdGFydFZlcnRleFBvc2l0aW9uSW5kaWNlcywgZW5kVmVydGV4UG9zaXRpb25JbmRpY2VzLCBzbWFsbGVyRmFjZXRzSW5kaWNlcywgaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IHZlcnRleFBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4UG9zaXRpb25zKCksXG4gICAgICAgICAgaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb25zID0gaW50ZXJzZWN0aW9ucy5tYXAoZnVuY3Rpb24oaW50ZXJzZWN0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4ID0gc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGljZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgZW5kVmVydGV4UG9zaXRpb25JbmRleCA9IGVuZFZlcnRleFBvc2l0aW9uSW5kaWNlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICBzdGFydFZlcnRleFBvc2l0aW9uID0gdmVydGV4UG9zaXRpb25zWyBzdGFydFZlcnRleFBvc2l0aW9uSW5kZXggXSxcbiAgICAgICAgICAgICAgICAgIGVuZFZlcnRleFBvc2l0aW9uID0gdmVydGV4UG9zaXRpb25zWyBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4IF0sXG4gICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbiA9IGNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uKHN0YXJ0VmVydGV4UG9zaXRpb24sIGVuZFZlcnRleFBvc2l0aW9uLCBpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb247XG4gICAgICAgICAgfSk7XG5cbiAgICBwdXNoKHZlcnRleFBvc2l0aW9ucywgaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb25zKTtcblxuICAgIHNtYWxsZXJGYWNldHNJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24oc21hbGxlckZhY2V0SW5kaWNlcykge1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gdmVydGV4UG9zaXRpb25zLCAgLy8vXG4gICAgICAgICAgICBpbmRpY2VzID0gc21hbGxlckZhY2V0SW5kaWNlcywgIC8vL1xuICAgICAgICAgICAgZmFjZXQgPSB0aGlzLCAvLy9cbiAgICAgICAgICAgIHNtYWxsZXJGYWNldCA9IHNtYWxsZXJGYWNldEZyb21Qb3NpdGlvbnNBbmRJbmRpY2VzKHBvc2l0aW9ucywgaW5kaWNlcywgZmFjZXQpLFxuICAgICAgICAgICAgc21hbGxlckZhY2V0VG9vU21hbGwgPSBzbWFsbGVyRmFjZXQuaXNUb29TbWFsbCgpO1xuXG4gICAgICBpZiAoIXNtYWxsZXJGYWNldFRvb1NtYWxsKSB7XG4gICAgICAgIHNtYWxsZXJGYWNldHMucHVzaChzbWFsbGVyRmFjZXQpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGYWNldDtcblxuZnVuY3Rpb24gc21hbGxlckZhY2V0RnJvbVBvc2l0aW9uc0FuZEluZGljZXMocG9zaXRpb25zLCBpbmRpY2VzLCBmYWNldCkge1xuICBjb25zdCB2ZXJ0aWNlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBjbG9uZVBvc2l0aW9uKHBvc2l0aW9uc1tpbmRleF0pLFxuICAgICAgICAgICAgICAgIHZlcnRleCA9IFZlcnRleC5mcm9tUG9zaXRpb24ocG9zaXRpb24pO1xuXG4gICAgICAgICAgcmV0dXJuIHZlcnRleDtcbiAgICAgICAgfSksXG4gICAgICAgIHNtYWxsZXJGYWNldCA9IGZhY2V0LmZyb21WZXJ0aWNlcyh2ZXJ0aWNlcyk7XG5cbiAgcmV0dXJuIHNtYWxsZXJGYWNldDtcbn1cblxuZnVuY3Rpb24gY2xvbmVQb3NpdGlvbihwb3NpdGlvbikgeyByZXR1cm4gcG9zaXRpb24uc2xpY2UoKTsgfSAvLy9cbiJdfQ==
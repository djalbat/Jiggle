'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./edge'),
    Normal = require('./normal'),
    Vertex = require('./vertex'),
    constants = require('./constants'),
    facetUtilities = require('./utilities/facet'),
    arrayUtilities = require('./utilities/array'),
    midPointUtilities = require('./utilities/midPoint'),
    approximateUtilities = require('./utilities/approximate'),
    intersectionUtilities = require('./utilities/intersection');

var VERTICES_LENGTH = constants.VERTICES_LENGTH,
    first = arrayUtilities.first,
    second = arrayUtilities.second,
    third = arrayUtilities.third,
    _permute = arrayUtilities.permute,
    isApproximatelyEqualToZero = approximateUtilities.isApproximatelyEqualToZero,
    calculateEdges = facetUtilities.calculateEdges,
    calculateNormal = facetUtilities.calculateNormal,
    calculateArea = facetUtilities.calculateArea,
    calculateMidPointPosition = midPointUtilities.calculateMidPointPosition,
    isMidPointPositionToOneSideOfMaskingEdges = midPointUtilities.isMidPointPositionToOneSideOfMaskingEdges,
    calculateIntermediateVertex = intersectionUtilities.calculateIntermediateVertex,
    calculateNonNullIntersections = intersectionUtilities.calculateNonNullIntersections,
    calculateNullIntersectionIndex = intersectionUtilities.calculateNullIntersectionIndex,
    calculateNonNullIntersectionIndex = intersectionUtilities.calculateNonNullIntersectionIndex;

var Facet = function () {
  function Facet(vertices, normal, edges) {
    _classCallCheck(this, Facet);

    this.vertices = vertices;
    this.normal = normal;
    this.edges = edges;
  }

  _createClass(Facet, [{
    key: 'getVertices',
    value: function getVertices() {
      return this.vertices;
    }
  }, {
    key: 'getNormal',
    value: function getNormal() {
      return this.normal;
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this.edges;
    }
  }, {
    key: 'getVertexPositions',
    value: function getVertexPositions() {
      var vertexPositions = this.vertices.map(function (vertex) {
        var vertexPosition = vertex.getPosition();

        return vertexPosition;
      });

      return vertexPositions;
    }
  }, {
    key: 'getVertexNormals',
    value: function getVertexNormals() {
      var extent = this.normal.getExtent(),
          vertexNormal = extent,
          ///
      vertexNormals = [vertexNormal, vertexNormal, vertexNormal];

      return vertexNormals;
    }
  }, {
    key: 'getVertexIndexes',
    value: function getVertexIndexes(index) {
      ///
      var vertexIndex = index * 3,
          vertexIndexes = [vertexIndex + 0, vertexIndex + 1, vertexIndex + 2];

      return vertexIndexes;
    }
  }, {
    key: 'isTooSmall',
    value: function isTooSmall() {
      var area = calculateArea(this.vertices),
          areaApproximatelyEqualToZero = isApproximatelyEqualToZero(area),
          tooSmall = areaApproximatelyEqualToZero; ///

      return tooSmall;
    }
  }, {
    key: 'isMasked',
    value: function isMasked(maskingFacet) {
      var maskingEdges = maskingFacet.getMaskingEdges(),
          midPointPosition = calculateMidPointPosition(this.vertices),
          midPointPositionToOneSideOfMaskingEdges = isMidPointPositionToOneSideOfMaskingEdges(midPointPosition, maskingEdges),
          masked = midPointPositionToOneSideOfMaskingEdges; ///

      return masked;
    }
  }, {
    key: 'permute',
    value: function permute(places) {
      this.vertices = _permute(this.vertices, places);

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotate',
    value: function rotate(rotationQuaternion) {
      this.vertices.forEach(function (vertex) {
        vertex.rotate(rotationQuaternion);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotateAboutZAxis',
    value: function rotateAboutZAxis(rotationAboutZAxisMatrix) {
      this.vertices.forEach(function (vertex) {
        vertex.rotateAboutZAxis(rotationAboutZAxisMatrix);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'applyTransforms',
    value: function applyTransforms(transforms) {
      this.vertices.forEach(function (vertex) {
        vertex.applyTransforms(transforms);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'splitWithIntersections',
    value: function splitWithIntersections(intersections, smallerFacets) {
      var nonNullIntersections = calculateNonNullIntersections(intersections),
          nonNullIntersectionsLength = nonNullIntersections.length;

      switch (nonNullIntersectionsLength) {
        case 2:
          this.splitWithTwoNonNullIntersections(intersections, smallerFacets);
          break;

        case 1:
          this.splitWithOneNonNullIntersection(intersections, smallerFacets);
          break;

        case 0:
          this.splitWithNoNonNullIntersections(intersections, smallerFacets);
          break;
      }
    }
  }, {
    key: 'splitWithTwoNonNullIntersections',
    value: function splitWithTwoNonNullIntersections(intersections, smallerFacets) {
      var nullIntersectionIndex = calculateNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(1); ///

      this.permute(places);

      var firstVertex = first(this.vertices),
          secondVertex = second(this.vertices),
          thirdVertex = third(this.vertices),
          firstIntersection = first(intersections),
          secondIntersection = second(intersections),
          firstIntermediateVertex = calculateIntermediateVertex(secondVertex, thirdVertex, firstIntersection, Vertex),
          secondIntermediateVertex = calculateIntermediateVertex(thirdVertex, firstVertex, secondIntersection, Vertex),
          fourthVertex = firstIntermediateVertex,
          ///
      fifthVertex = secondIntermediateVertex,
          ///
      smallerFacetsIndices = [[0, 1, 3], [3, 4, 0], [3, 2, 4]],
          vertices = [firstVertex, secondVertex, thirdVertex, fourthVertex, fifthVertex],
          facet = this; ///

      smallerFacetsIndices.forEach(function (smallerFacetIndices) {
        var indices = smallerFacetIndices,
            ///
        smallerFacet = smallerFacetFromVerticesAndIndices(vertices, indices, facet),
            smallerFacetTooSmall = smallerFacet.isTooSmall();

        if (!smallerFacetTooSmall) {
          smallerFacets.push(smallerFacet);
        }
      });
    }
  }, {
    key: 'splitWithOneNonNullIntersection',
    value: function splitWithOneNonNullIntersection(intersections, smallerFacets) {
      var nonNullIntersectionIndex = calculateNonNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nonNullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      this.permute(places);

      var firstVertex = first(this.vertices),
          secondVertex = second(this.vertices),
          thirdVertex = third(this.vertices),
          firstIntersection = first(intersections),
          intermediateVertex = calculateIntermediateVertex(firstVertex, secondVertex, firstIntersection, Vertex),
          fourthVertex = intermediateVertex,
          ///
      vertices = [firstVertex, secondVertex, thirdVertex, fourthVertex],
          smallerFacetsIndices = [[0, 3, 2], [3, 1, 2]],
          facet = this;

      smallerFacetsIndices.forEach(function (smallerFacetIndices) {
        var indices = smallerFacetIndices,
            ///
        smallerFacet = smallerFacetFromVerticesAndIndices(vertices, indices, facet),
            smallerFacetTooSmall = smallerFacet.isTooSmall();

        if (!smallerFacetTooSmall) {
          smallerFacets.push(smallerFacet);
        }
      });
    }
  }, {
    key: 'splitWithNoNonNullIntersections',
    value: function splitWithNoNonNullIntersections(intersections, smallerFacets) {
      var smallerFacet = this.fromVertices(this.vertices); ///

      smallerFacets.push(smallerFacet);
    }
  }]);

  return Facet;
}();

module.exports = Facet;

function smallerFacetFromVerticesAndIndices(vertices, indices, facet) {
  vertices = indices.map(function (index) {
    var vertex = vertices[index];

    vertex = vertex.clone(); ///

    return vertex;
  });

  var smallerFacet = facet.fromVertices(vertices);

  return smallerFacet;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9mYWNldC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIk5vcm1hbCIsIlZlcnRleCIsImNvbnN0YW50cyIsImZhY2V0VXRpbGl0aWVzIiwiYXJyYXlVdGlsaXRpZXMiLCJtaWRQb2ludFV0aWxpdGllcyIsImFwcHJveGltYXRlVXRpbGl0aWVzIiwiaW50ZXJzZWN0aW9uVXRpbGl0aWVzIiwiVkVSVElDRVNfTEVOR1RIIiwiZmlyc3QiLCJzZWNvbmQiLCJ0aGlyZCIsInBlcm11dGUiLCJpc0FwcHJveGltYXRlbHlFcXVhbFRvWmVybyIsImNhbGN1bGF0ZUVkZ2VzIiwiY2FsY3VsYXRlTm9ybWFsIiwiY2FsY3VsYXRlQXJlYSIsImNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24iLCJpc01pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyIsImNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleCIsImNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zIiwiY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4IiwiY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbkluZGV4IiwiRmFjZXQiLCJ2ZXJ0aWNlcyIsIm5vcm1hbCIsImVkZ2VzIiwidmVydGV4UG9zaXRpb25zIiwibWFwIiwidmVydGV4IiwidmVydGV4UG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsImV4dGVudCIsImdldEV4dGVudCIsInZlcnRleE5vcm1hbCIsInZlcnRleE5vcm1hbHMiLCJpbmRleCIsInZlcnRleEluZGV4IiwidmVydGV4SW5kZXhlcyIsImFyZWEiLCJhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIiwidG9vU21hbGwiLCJtYXNraW5nRmFjZXQiLCJtYXNraW5nRWRnZXMiLCJnZXRNYXNraW5nRWRnZXMiLCJtaWRQb2ludFBvc2l0aW9uIiwibWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzIiwibWFza2VkIiwicGxhY2VzIiwicm90YXRpb25RdWF0ZXJuaW9uIiwiZm9yRWFjaCIsInJvdGF0ZSIsInJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsInJvdGF0ZUFib3V0WkF4aXMiLCJ0cmFuc2Zvcm1zIiwiYXBwbHlUcmFuc2Zvcm1zIiwiaW50ZXJzZWN0aW9ucyIsInNtYWxsZXJGYWNldHMiLCJub25OdWxsSW50ZXJzZWN0aW9ucyIsIm5vbk51bGxJbnRlcnNlY3Rpb25zTGVuZ3RoIiwibGVuZ3RoIiwic3BsaXRXaXRoVHdvTm9uTnVsbEludGVyc2VjdGlvbnMiLCJzcGxpdFdpdGhPbmVOb25OdWxsSW50ZXJzZWN0aW9uIiwic3BsaXRXaXRoTm9Ob25OdWxsSW50ZXJzZWN0aW9ucyIsIm51bGxJbnRlcnNlY3Rpb25JbmRleCIsInNsaWNlIiwiZmlyc3RWZXJ0ZXgiLCJzZWNvbmRWZXJ0ZXgiLCJ0aGlyZFZlcnRleCIsImZpcnN0SW50ZXJzZWN0aW9uIiwic2Vjb25kSW50ZXJzZWN0aW9uIiwiZmlyc3RJbnRlcm1lZGlhdGVWZXJ0ZXgiLCJzZWNvbmRJbnRlcm1lZGlhdGVWZXJ0ZXgiLCJmb3VydGhWZXJ0ZXgiLCJmaWZ0aFZlcnRleCIsInNtYWxsZXJGYWNldHNJbmRpY2VzIiwiZmFjZXQiLCJzbWFsbGVyRmFjZXRJbmRpY2VzIiwiaW5kaWNlcyIsInNtYWxsZXJGYWNldCIsInNtYWxsZXJGYWNldEZyb21WZXJ0aWNlc0FuZEluZGljZXMiLCJzbWFsbGVyRmFjZXRUb29TbWFsbCIsImlzVG9vU21hbGwiLCJwdXNoIiwibm9uTnVsbEludGVyc2VjdGlvbkluZGV4IiwiaW50ZXJtZWRpYXRlVmVydGV4IiwiZnJvbVZlcnRpY2VzIiwibW9kdWxlIiwiZXhwb3J0cyIsImNsb25lIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUEsSUFBTUEsT0FBT0MsUUFBUSxRQUFSLENBQWI7QUFBQSxJQUNNQyxTQUFTRCxRQUFRLFVBQVIsQ0FEZjtBQUFBLElBRU1FLFNBQVNGLFFBQVEsVUFBUixDQUZmO0FBQUEsSUFHTUcsWUFBWUgsUUFB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QWtCLEtBQUs5RCxRQUF2QixDQUFyQixDQUQ0RCxDQUNKOztBQUV4RGlDLG9CQUFjMEIsSUFBZCxDQUFtQkosWUFBbkI7QUFDRDs7Ozs7O0FBR0hRLE9BQU9DLE9BQVAsR0FBaUJqRSxLQUFqQjs7QUFFQSxTQUFTeUQsa0NBQVQsQ0FBNEN4RCxRQUE1QyxFQUFzRHNELE9BQXRELEVBQStERixLQUEvRCxFQUFzRTtBQUNwRXBELGFBQVdzRCxRQUFRbEQsR0FBUixDQUFZLFVBQVNRLEtBQVQsRUFBZ0I7QUFDckMsUUFBSVAsU0FBU0wsU0FBU1ksS0FBVCxDQUFiOztBQUVBUCxhQUFTQSxPQUFPNEQsS0FBUCxFQUFULENBSHFDLENBR1g7O0FBRTFCLFdBQU81RCxNQUFQO0FBQ0QsR0FOVSxDQUFYOztBQVFBLE1BQU1rRCxlQUFlSCxNQUFNVSxZQUFOLENBQW1COUQsUUFBbkIsQ0FBckI7O0FBRUEsU0FBT3VELFlBQVA7QUFDRCIsImZpbGUiOiJmYWNldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRWRnZSA9IHJlcXVpcmUoJy4vZWRnZScpLFxuICAgICAgTm9ybWFsID0gcmVxdWlyZSgnLi9ub3JtYWwnKSxcbiAgICAgIFZlcnRleCA9IHJlcXVpcmUoJy4vdmVydGV4JyksXG4gICAgICBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLFxuICAgICAgZmFjZXRVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9mYWNldCcpLFxuICAgICAgYXJyYXlVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9hcnJheScpLFxuICAgICAgbWlkUG9pbnRVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9taWRQb2ludCcpLFxuICAgICAgYXBwcm94aW1hdGVVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9hcHByb3hpbWF0ZScpLFxuICAgICAgaW50ZXJzZWN0aW9uVXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvaW50ZXJzZWN0aW9uJyk7XG5cbmNvbnN0IHsgVkVSVElDRVNfTEVOR1RIIH0gPSBjb25zdGFudHMsXG4gICAgICB7IGZpcnN0LCBzZWNvbmQsIHRoaXJkLCBwZXJtdXRlIH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgaXNBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8gfSA9IGFwcHJveGltYXRlVXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVFZGdlcywgY2FsY3VsYXRlTm9ybWFsLCBjYWxjdWxhdGVBcmVhIH0gPSBmYWNldFV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlTWlkUG9pbnRQb3NpdGlvbiwgaXNNaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMgfSA9IG1pZFBvaW50VXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVJbnRlcm1lZGlhdGVWZXJ0ZXgsIGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zLCBjYWxjdWxhdGVOdWxsSW50ZXJzZWN0aW9uSW5kZXgsIGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCB9ID0gaW50ZXJzZWN0aW9uVXRpbGl0aWVzO1xuXG5jbGFzcyBGYWNldCB7XG4gIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCBub3JtYWwsIGVkZ2VzKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgIHRoaXMuZWRnZXMgPSBlZGdlcztcbiAgfVxuXG4gIGdldFZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzO1xuICB9XG5cbiAgZ2V0Tm9ybWFsKCkge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbDtcbiAgfVxuXG4gIGdldEVkZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzO1xuICB9XG4gIFxuICBnZXRWZXJ0ZXhQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgdmVydGV4UG9zaXRpb25zID0gdGhpcy52ZXJ0aWNlcy5tYXAoZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICBjb25zdCB2ZXJ0ZXhQb3NpdGlvbiA9IHZlcnRleC5nZXRQb3NpdGlvbigpO1xuICAgICAgXG4gICAgICByZXR1cm4gdmVydGV4UG9zaXRpb247XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHZlcnRleFBvc2l0aW9ucztcbiAgfVxuICBcbiAgZ2V0VmVydGV4Tm9ybWFscygpIHtcbiAgICBjb25zdCBleHRlbnQgPSB0aGlzLm5vcm1hbC5nZXRFeHRlbnQoKSxcbiAgICAgICAgICB2ZXJ0ZXhOb3JtYWwgPSBleHRlbnQsICAvLy9cbiAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzID0gW1xuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgIF07XG4gICAgXG4gICAgcmV0dXJuIHZlcnRleE5vcm1hbHM7XG4gIH1cbiAgXG4gIGdldFZlcnRleEluZGV4ZXMoaW5kZXgpIHsgLy8vXG4gICAgY29uc3QgdmVydGV4SW5kZXggPSBpbmRleCAqIDMsXG4gICAgICAgICAgdmVydGV4SW5kZXhlcyA9IFtcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMCxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMSxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMixcbiAgICAgICAgICBdO1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXhJbmRleGVzO1xuICB9XG5cbiAgaXNUb29TbWFsbCgpIHtcbiAgICBjb25zdCBhcmVhID0gY2FsY3VsYXRlQXJlYSh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICBhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvID0gaXNBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8oYXJlYSksXG4gICAgICAgICAgdG9vU21hbGwgPSBhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvOyAgLy8vXG5cbiAgICByZXR1cm4gdG9vU21hbGw7XG4gIH1cblxuICBpc01hc2tlZChtYXNraW5nRmFjZXQpIHtcbiAgICBjb25zdCBtYXNraW5nRWRnZXMgPSBtYXNraW5nRmFjZXQuZ2V0TWFza2luZ0VkZ2VzKCksXG4gICAgICAgICAgbWlkUG9pbnRQb3NpdGlvbiA9IGNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24odGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgbWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzID0gaXNNaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMobWlkUG9pbnRQb3NpdGlvbiwgbWFza2luZ0VkZ2VzKSxcbiAgICAgICAgICBtYXNrZWQgPSBtaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXM7ICAvLy9cbiAgICBcbiAgICByZXR1cm4gbWFza2VkO1xuICB9XG5cbiAgcGVybXV0ZShwbGFjZXMpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gcGVybXV0ZSh0aGlzLnZlcnRpY2VzLCBwbGFjZXMpO1xuXG4gICAgdGhpcy5ub3JtYWwgPSBjYWxjdWxhdGVOb3JtYWwodGhpcy52ZXJ0aWNlcywgTm9ybWFsKTtcblxuICAgIHRoaXMuZWRnZXMgPSBjYWxjdWxhdGVFZGdlcyh0aGlzLnZlcnRpY2VzLCBFZGdlKTtcbiAgfVxuXG4gIHJvdGF0ZShyb3RhdGlvblF1YXRlcm5pb24pIHtcbiAgICB0aGlzLnZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICB2ZXJ0ZXgucm90YXRlKHJvdGF0aW9uUXVhdGVybmlvbik7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5vcm1hbCA9IGNhbGN1bGF0ZU5vcm1hbCh0aGlzLnZlcnRpY2VzLCBOb3JtYWwpO1xuXG4gICAgdGhpcy5lZGdlcyA9IGNhbGN1bGF0ZUVkZ2VzKHRoaXMudmVydGljZXMsIEVkZ2UpO1xuICB9XG5cbiAgcm90YXRlQWJvdXRaQXhpcyhyb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpIHtcbiAgICB0aGlzLnZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICB2ZXJ0ZXgucm90YXRlQWJvdXRaQXhpcyhyb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5ub3JtYWwgPSBjYWxjdWxhdGVOb3JtYWwodGhpcy52ZXJ0aWNlcywgTm9ybWFsKTtcblxuICAgIHRoaXMuZWRnZXMgPSBjYWxjdWxhdGVFZGdlcyh0aGlzLnZlcnRpY2VzLCBFZGdlKTtcbiAgfVxuXG4gIGFwcGx5VHJhbnNmb3Jtcyh0cmFuc2Zvcm1zKSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgdmVydGV4LmFwcGx5VHJhbnNmb3Jtcyh0cmFuc2Zvcm1zKTtcbiAgICB9KTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICBzcGxpdFdpdGhJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBub25OdWxsSW50ZXJzZWN0aW9ucyA9IGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIG5vbk51bGxJbnRlcnNlY3Rpb25zTGVuZ3RoID0gbm9uTnVsbEludGVyc2VjdGlvbnMubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCkge1xuICAgICAgY2FzZSAyIDpcbiAgICAgICAgdGhpcy5zcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMSA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoT25lTm9uTnVsbEludGVyc2VjdGlvbihpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMCA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoTm9Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICBzcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3QgbnVsbEludGVyc2VjdGlvbkluZGV4ID0gY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4KGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIHBsYWNlcyA9IChWRVJUSUNFU19MRU5HVEggLSBudWxsSW50ZXJzZWN0aW9uSW5kZXgpICUgVkVSVElDRVNfTEVOR1RIO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IHBlcm11dGUoaW50ZXJzZWN0aW9ucywgcGxhY2VzKTtcblxuICAgIGludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDEpOyAvLy9cbiAgICBcbiAgICB0aGlzLnBlcm11dGUocGxhY2VzKTtcblxuICAgIGNvbnN0IGZpcnN0VmVydGV4ID0gZmlyc3QodGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgc2Vjb25kVmVydGV4ID0gc2Vjb25kKHRoaXMudmVydGljZXMpLFxuICAgICAgICAgIHRoaXJkVmVydGV4ID0gdGhpcmQodGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgZmlyc3RJbnRlcnNlY3Rpb24gPSBmaXJzdChpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBzZWNvbmRJbnRlcnNlY3Rpb24gPSBzZWNvbmQoaW50ZXJzZWN0aW9ucyksXG4gICAgICAgICAgZmlyc3RJbnRlcm1lZGlhdGVWZXJ0ZXggPSBjYWxjdWxhdGVJbnRlcm1lZGlhdGVWZXJ0ZXgoc2Vjb25kVmVydGV4LCB0aGlyZFZlcnRleCwgZmlyc3RJbnRlcnNlY3Rpb24sIFZlcnRleCksXG4gICAgICAgICAgc2Vjb25kSW50ZXJtZWRpYXRlVmVydGV4ID0gY2FsY3VsYXRlSW50ZXJtZWRpYXRlVmVydGV4KHRoaXJkVmVydGV4LCBmaXJzdFZlcnRleCwgc2Vjb25kSW50ZXJzZWN0aW9uLCBWZXJ0ZXgpLFxuICAgICAgICAgIGZvdXJ0aFZlcnRleCA9IGZpcnN0SW50ZXJtZWRpYXRlVmVydGV4LCAvLy9cbiAgICAgICAgICBmaWZ0aFZlcnRleCA9IHNlY29uZEludGVybWVkaWF0ZVZlcnRleCwgLy8vXG4gICAgICAgICAgc21hbGxlckZhY2V0c0luZGljZXMgPSBbXG5cbiAgICAgICAgICAgIFsgMCwgMSwgMyBdLFxuICAgICAgICAgICAgWyAzLCA0LCAwIF0sXG4gICAgICAgICAgICBbIDMsIDIsIDQgXSxcblxuICAgICAgICAgIF0sXG4gICAgICAgICAgdmVydGljZXMgPSBbXG4gICAgICAgICAgICBmaXJzdFZlcnRleCxcbiAgICAgICAgICAgIHNlY29uZFZlcnRleCxcbiAgICAgICAgICAgIHRoaXJkVmVydGV4LFxuICAgICAgICAgICAgZm91cnRoVmVydGV4LFxuICAgICAgICAgICAgZmlmdGhWZXJ0ZXhcbiAgICAgICAgICBdLFxuICAgICAgICAgIGZhY2V0ID0gdGhpczsgLy8vXG5cbiAgICBzbWFsbGVyRmFjZXRzSW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNtYWxsZXJGYWNldEluZGljZXMpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBzbWFsbGVyRmFjZXRJbmRpY2VzLCAgLy8vXG4gICAgICAgICAgICBzbWFsbGVyRmFjZXQgPSBzbWFsbGVyRmFjZXRGcm9tVmVydGljZXNBbmRJbmRpY2VzKHZlcnRpY2VzLCBpbmRpY2VzLCBmYWNldCksXG4gICAgICAgICAgICBzbWFsbGVyRmFjZXRUb29TbWFsbCA9IHNtYWxsZXJGYWNldC5pc1Rvb1NtYWxsKCk7XG5cbiAgICAgIGlmICghc21hbGxlckZhY2V0VG9vU21hbGwpIHtcbiAgICAgICAgc21hbGxlckZhY2V0cy5wdXNoKHNtYWxsZXJGYWNldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzcGxpdFdpdGhPbmVOb25OdWxsSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBub25OdWxsSW50ZXJzZWN0aW9uSW5kZXggPSBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9uSW5kZXgoaW50ZXJzZWN0aW9ucyksXG4gICAgICAgICAgcGxhY2VzID0gKFZFUlRJQ0VTX0xFTkdUSCAtIG5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCkgJSBWRVJUSUNFU19MRU5HVEg7XG5cbiAgICBpbnRlcnNlY3Rpb25zID0gcGVybXV0ZShpbnRlcnNlY3Rpb25zLCBwbGFjZXMpO1xuXG4gICAgdGhpcy5wZXJtdXRlKHBsYWNlcyk7XG5cbiAgICBjb25zdCBmaXJzdFZlcnRleCA9IGZpcnN0KHRoaXMudmVydGljZXMpLFxuICAgICAgICAgIHNlY29uZFZlcnRleCA9IHNlY29uZCh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICB0aGlyZFZlcnRleCA9IHRoaXJkKHRoaXMudmVydGljZXMpLFxuICAgICAgICAgIGZpcnN0SW50ZXJzZWN0aW9uID0gZmlyc3QoaW50ZXJzZWN0aW9ucyksXG4gICAgICAgICAgaW50ZXJtZWRpYXRlVmVydGV4ID0gY2FsY3VsYXRlSW50ZXJtZWRpYXRlVmVydGV4KGZpcnN0VmVydGV4LCBzZWNvbmRWZXJ0ZXgsIGZpcnN0SW50ZXJzZWN0aW9uLCBWZXJ0ZXgpLFxuICAgICAgICAgIGZvdXJ0aFZlcnRleCA9IGludGVybWVkaWF0ZVZlcnRleCwgIC8vL1xuICAgICAgICAgIHZlcnRpY2VzID0gW1xuICAgICAgICAgICAgZmlyc3RWZXJ0ZXgsXG4gICAgICAgICAgICBzZWNvbmRWZXJ0ZXgsXG4gICAgICAgICAgICB0aGlyZFZlcnRleCxcbiAgICAgICAgICAgIGZvdXJ0aFZlcnRleFxuICAgICAgICAgIF0sXG4gICAgICAgICAgc21hbGxlckZhY2V0c0luZGljZXMgPSBbXG5cbiAgICAgICAgICAgIFsgMCwgMywgMiBdLFxuICAgICAgICAgICAgWyAzLCAxLCAyIF0sXG5cbiAgICAgICAgICBdLFxuICAgICAgICAgIGZhY2V0ID0gdGhpcztcblxuICAgIHNtYWxsZXJGYWNldHNJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24oc21hbGxlckZhY2V0SW5kaWNlcykge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IHNtYWxsZXJGYWNldEluZGljZXMsICAvLy9cbiAgICAgICAgICAgIHNtYWxsZXJGYWNldCA9IHNtYWxsZXJGYWNldEZyb21WZXJ0aWNlc0FuZEluZGljZXModmVydGljZXMsIGluZGljZXMsIGZhY2V0KSxcbiAgICAgICAgICAgIHNtYWxsZXJGYWNldFRvb1NtYWxsID0gc21hbGxlckZhY2V0LmlzVG9vU21hbGwoKTtcblxuICAgICAgaWYgKCFzbWFsbGVyRmFjZXRUb29TbWFsbCkge1xuICAgICAgICBzbWFsbGVyRmFjZXRzLnB1c2goc21hbGxlckZhY2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNwbGl0V2l0aE5vTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IHNtYWxsZXJGYWNldCA9IHRoaXMuZnJvbVZlcnRpY2VzKHRoaXMudmVydGljZXMpOyAgLy8vXG5cbiAgICBzbWFsbGVyRmFjZXRzLnB1c2goc21hbGxlckZhY2V0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2V0O1xuXG5mdW5jdGlvbiBzbWFsbGVyRmFjZXRGcm9tVmVydGljZXNBbmRJbmRpY2VzKHZlcnRpY2VzLCBpbmRpY2VzLCBmYWNldCkge1xuICB2ZXJ0aWNlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgbGV0IHZlcnRleCA9IHZlcnRpY2VzW2luZGV4XTtcblxuICAgIHZlcnRleCA9IHZlcnRleC5jbG9uZSgpOyAgLy8vXG5cbiAgICByZXR1cm4gdmVydGV4O1xuICB9KTtcblxuICBjb25zdCBzbWFsbGVyRmFjZXQgPSBmYWNldC5mcm9tVmVydGljZXModmVydGljZXMpO1xuXG4gIHJldHVybiBzbWFsbGVyRmFjZXQ7XG59XG4iXX0=
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./edge'),
    Normal = require('./normal'),
    Vertex = require('./vertex'),
    constants = require('./constants'),
    facetUtilities = require('./utilities/facet'),
    arrayUtilities = require('./utilities/array'),
    verticesUtilities = require('./utilities/vertices'),
    midPointUtilities = require('./utilities/midPoint'),
    approximateUtilities = require('./utilities/approximate'),
    intersectionUtilities = require('./utilities/intersection');

var VERTICES_LENGTH = constants.VERTICES_LENGTH,
    cloneVertices = verticesUtilities.cloneVertices,
    first = arrayUtilities.first,
    second = arrayUtilities.second,
    third = arrayUtilities.third,
    _permute = arrayUtilities.permute,
    isApproximatelyEqualToZero = approximateUtilities.isApproximatelyEqualToZero,
    calculateEdges = facetUtilities.calculateEdges,
    calculateNormal = facetUtilities.calculateNormal,
    calculateArea = facetUtilities.calculateArea,
    calculateMidPointPosition = midPointUtilities.calculateMidPointPosition,
    isMidPointPositionToOneSideOfMaskingEdges = midPointUtilities.isMidPointPositionToOneSideOfMaskingEdges,
    calculateIntermediateVertex = intersectionUtilities.calculateIntermediateVertex,
    calculateNonNullIntersections = intersectionUtilities.calculateNonNullIntersections,
    calculateNullIntersectionIndex = intersectionUtilities.calculateNullIntersectionIndex,
    calculateNonNullIntersectionIndex = intersectionUtilities.calculateNonNullIntersectionIndex;

var Facet = function () {
  function Facet(vertices, normal, edges) {
    _classCallCheck(this, Facet);

    this.vertices = vertices;
    this.normal = normal;
    this.edges = edges;
  }

  _createClass(Facet, [{
    key: 'getVertices',
    value: function getVertices() {
      return this.vertices;
    }
  }, {
    key: 'getNormal',
    value: function getNormal() {
      return this.normal;
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this.edges;
    }
  }, {
    key: 'getVertexPositions',
    value: function getVertexPositions() {
      var vertexPositions = this.vertices.map(function (vertex) {
        var vertexPosition = vertex.getPosition();

        return vertexPosition;
      });

      return vertexPositions;
    }
  }, {
    key: 'getVertexNormals',
    value: function getVertexNormals() {
      var extent = this.normal.getExtent(),
          vertexNormal = extent,
          ///
      vertexNormals = [vertexNormal, vertexNormal, vertexNormal];

      return vertexNormals;
    }
  }, {
    key: 'getVertexIndexes',
    value: function getVertexIndexes(index) {
      ///
      var vertexIndex = index * 3,
          vertexIndexes = [vertexIndex + 0, vertexIndex + 1, vertexIndex + 2];

      return vertexIndexes;
    }
  }, {
    key: 'isTooSmall',
    value: function isTooSmall() {
      var area = calculateArea(this.vertices),
          areaApproximatelyEqualToZero = isApproximatelyEqualToZero(area),
          tooSmall = areaApproximatelyEqualToZero; ///

      return tooSmall;
    }
  }, {
    key: 'isMasked',
    value: function isMasked(maskingFacet) {
      var maskingEdges = maskingFacet.getMaskingEdges(),
          midPointPosition = calculateMidPointPosition(this.vertices),
          midPointPositionToOneSideOfMaskingEdges = isMidPointPositionToOneSideOfMaskingEdges(midPointPosition, maskingEdges),
          masked = midPointPositionToOneSideOfMaskingEdges; ///

      return masked;
    }
  }, {
    key: 'permute',
    value: function permute(places) {
      this.vertices = _permute(this.vertices, places);

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotate',
    value: function rotate(rotationQuaternion) {
      this.vertices.forEach(function (vertex) {
        vertex.rotate(rotationQuaternion);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotateAboutZAxis',
    value: function rotateAboutZAxis(rotationAboutZAxisMatrix) {
      this.vertices.forEach(function (vertex) {
        vertex.rotateAboutZAxis(rotationAboutZAxisMatrix);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'applyTransforms',
    value: function applyTransforms(transforms) {
      this.vertices.forEach(function (vertex) {
        vertex.applyTransforms(transforms);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'splitWithIntersections',
    value: function splitWithIntersections(intersections, smallerFacets) {
      var nonNullIntersections = calculateNonNullIntersections(intersections),
          nonNullIntersectionsLength = nonNullIntersections.length;

      switch (nonNullIntersectionsLength) {
        case 2:
          this.splitWithTwoNonNullIntersections(intersections, smallerFacets);
          break;

        case 1:
          this.splitWithOneNonNullIntersection(intersections, smallerFacets);
          break;

        case 0:
          this.splitWithZeroNonNullIntersections(intersections, smallerFacets);
          break;
      }
    }
  }, {
    key: 'splitWithTwoNonNullIntersections',
    value: function splitWithTwoNonNullIntersections(intersections, smallerFacets) {
      var nullIntersectionIndex = calculateNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(1); ///

      this.permute(places);

      var firstVertex = first(this.vertices),
          secondVertex = second(this.vertices),
          thirdVertex = third(this.vertices),
          firstIntersection = first(intersections),
          secondIntersection = second(intersections),
          firstIntermediateVertex = calculateIntermediateVertex(secondVertex, thirdVertex, firstIntersection, Vertex),
          secondIntermediateVertex = calculateIntermediateVertex(thirdVertex, firstVertex, secondIntersection, Vertex),
          fourthVertex = firstIntermediateVertex,
          ///
      fifthVertex = secondIntermediateVertex,
          ///
      smallerFacetsIndices = [[0, 1, 3], [3, 4, 0], [3, 2, 4]],
          vertices = [firstVertex, secondVertex, thirdVertex, fourthVertex, fifthVertex],
          facet = this; ///

      smallerFacetsIndices.forEach(function (smallerFacetIndices) {
        var indices = smallerFacetIndices,
            ///
        smallerFacet = smallerFacetFromVerticesAndIndices(vertices, indices, facet),
            smallerFacetTooSmall = smallerFacet.isTooSmall();

        if (!smallerFacetTooSmall) {
          smallerFacets.push(smallerFacet);
        }
      });
    }
  }, {
    key: 'splitWithOneNonNullIntersection',
    value: function splitWithOneNonNullIntersection(intersections, smallerFacets) {
      var nonNullIntersectionIndex = calculateNonNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nonNullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      this.permute(places);

      var firstVertex = first(this.vertices),
          secondVertex = second(this.vertices),
          thirdVertex = third(this.vertices),
          firstIntersection = first(intersections),
          intermediateVertex = calculateIntermediateVertex(firstVertex, secondVertex, firstIntersection, Vertex),
          fourthVertex = intermediateVertex,
          ///
      vertices = [firstVertex, secondVertex, thirdVertex, fourthVertex],
          smallerFacetsIndices = [[0, 3, 2], [3, 1, 2]],
          facet = this;

      smallerFacetsIndices.forEach(function (smallerFacetIndices) {
        var indices = smallerFacetIndices,
            ///
        smallerFacet = smallerFacetFromVerticesAndIndices(vertices, indices, facet),
            smallerFacetTooSmall = smallerFacet.isTooSmall();

        if (!smallerFacetTooSmall) {
          smallerFacets.push(smallerFacet);
        }
      });
    }
  }, {
    key: 'splitWithZeroNonNullIntersections',
    value: function splitWithZeroNonNullIntersections(intersections, smallerFacets) {
      var smallerFacet = this.fromVertices(this.vertices); ///

      smallerFacets.push(smallerFacet);
    }
  }]);

  return Facet;
}();

module.exports = Facet;

function smallerFacetFromVerticesAndIndices(vertices, indices, facet) {
  vertices = indices.map(function (index) {
    var vertex = vertices[index];

    vertex = vertex.clone(); ///

    return vertex;
  });

  var smallerFacet = facet.fromVertices(vertices);

  return smallerFacet;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9mYWNldC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIk5vcm1hbCIsIlZlcnRleCIsImNvbnN0YW50cyIsImZhY2V0VXRpbGl0aWVzIiwiYXJyYXlVdGlsaXRpZXMiLCJ2ZXJ0aWNlc1V0aWxpdGllcyIsIm1pZFBvaW50VXRpbGl0aWVzIiwiYXBwcm94aW1hdGVVdGlsaXRpZXMiLCJpbnRlcnNlY3Rpb25VdGlsaXRpZXMiLCJWRVJUSUNFU19MRU5HVEgiLCJjbG9uZVZlcnRpY2VzIiwiZmlyc3QiLCJzZWNvbmQiLCJ0aGlyZCIsInBlcm11dGUiLCJpc0FwcHJveGltYXRlbHlFcXVhbFRvWmVybyIsImNhbGN1bGF0ZUVkZ2VzIiwiY2FsY3VsYXRlTm9ybWFsIiwiY2FsY3VsYXRlQXJlYSIsImNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24iLCJpc01pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyIsImNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleCIsImNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zIiwiY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4IiwiY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbkluZGV4IiwiRmFjZXQiLCJ2ZXJ0aWNlcyIsIm5vcm1hbCIsImVkZ2VzIiwidmVydGV4UG9zaXRpb25zIiwibWFwIiwidmVydGV4IiwidmVydGV4UG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsImV4dGVudCIsImdldEV4dGVudCIsInZlcnRleE5vcm1hbCIsInZlcnRleE5vcm1hbHMiLCJpbmRleCIsInZlcnRleEluZGV4IiwidmVydGV4SW5kZXhlcyIsImFyZWEiLCJhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIiwidG9vU21hbGwiLCJtYXNraW5nRmFjZXQiLCJtYXNraW5nRWRnZXMiLCJnZXRNYXNraW5nRWRnZXMiLCJtaWRQb2ludFBvc2l0aW9uIiwibWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzIiwibWFza2VkIiwicGxhY2VzIiwicm90YXRpb25RdWF0ZXJuaW9uIiwiZm9yRWFjaCIsInJvdGF0ZSIsInJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsInJvdGF0ZUFib3V0WkF4aXMiLCJ0cmFuc2Zvcm1zIiwiYXBwbHlUcmFuc2Zvcm1zIiwiaW50ZXJzZWN0aW9ucyIsInNtYWxsZXJGYWNldHMiLCJub25OdWxsSW50ZXJzZWN0aW9ucyIsIm5vbk51bGxJbnRlcnNlY3Rpb25zTGVuZ3RoIiwibGVuZ3RoIiwic3BsaXRXaXRoVHdvTm9uTnVsbEludGVyc2VjdGlvbnMiLCJzcGxpdFdpdGhPbmVOb25OdWxsSW50ZXJzZWN0aW9uIiwic3BsaXRXaXRoWmVyb05vbk51bGxJbnRlcnNlY3Rpb25zIiwibnVsbEludGVyc2VjdGlvbkluZGV4Iiwic2xpY2UiLCJmaXJzdFZlcnRleCIsInNlY29uZFZlcnRleCIsInRoaXJkVmVydGV4IiwiZmlyc3RJbnRlcnNlY3Rpb24iLCJzZWNvbmRJbnRlcnNlY3Rpb24iLCJmaXJzdEludGVybWVkaWF0ZVZlcnRleCIsInNlY29uZEludGVybWVkaWF0ZVZlcnRleCIsImZvdXJ0aFZlcnRleCIsImZpZnRoVmVydGV4Iiwic21hbGxlckZhY2V0c0luZGljZXMiLCJmYWNldCIsInNtYWxsZXJGYWNldEluZGljZXMiLCJpbmRpY2VzIiwic21hbGxlckZhY2V0Iiwic21hbGxlckZhY2V0RnJvbVZlcnRpY2VzQW5kSW5kaWNlcyIsInNtYWxsZXJGYWNldFRvb1NtYWxsIiwiaXNUb29TbWFsbCIsInB1c2giLCJub25OdWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJpbnRlcm1lZGlhdGVWZXJ0ZXgiLCJmcm9tVmVydGljZXMiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2xvbmUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQSxJQUFNQSxPQUFPQyxRQUFRLFFBQVIsQ0FBYjtBQUFBLElBQ01DLFNBQVNELFFBQVEsVUFBUixDQURmO0FBQUEsSUFFTUUsU0FB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RUFBMkI7QUFDekJ4Qix3QkFBYzBCLElBQWQsQ0FBbUJKLFlBQW5CO0FBQ0Q7QUFDRixPQVJEO0FBU0Q7OztzREFFaUN2QixhLEVBQWVDLGEsRUFBZTtBQUM5RCxVQUFNc0IsZUFBZSxLQUFLTyxZQUFMLENBQWtCLEtBQUs5RCxRQUF2QixDQUFyQixDQUQ4RCxDQUNOOztBQUV4RGlDLG9CQUFjMEIsSUFBZCxDQUFtQkosWUFBbkI7QUFDRDs7Ozs7O0FBR0hRLE9BQU9DLE9BQVAsR0FBaUJqRSxLQUFqQjs7QUFFQSxTQUFTeUQsa0NBQVQsQ0FBNEN4RCxRQUE1QyxFQUFzRHNELE9BQXRELEVBQStERixLQUEvRCxFQUFzRTtBQUNwRXBELGFBQVdzRCxRQUFRbEQsR0FBUixDQUFZLFVBQVNRLEtBQVQsRUFBZ0I7QUFDckMsUUFBSVAsU0FBU0wsU0FBU1ksS0FBVCxDQUFiOztBQUVBUCxhQUFTQSxPQUFPNEQsS0FBUCxFQUFULENBSHFDLENBR1g7O0FBRTFCLFdBQU81RCxNQUFQO0FBQ0QsR0FOVSxDQUFYOztBQVFBLE1BQU1rRCxlQUFlSCxNQUFNVSxZQUFOLENBQW1COUQsUUFBbkIsQ0FBckI7O0FBRUEsU0FBT3VELFlBQVA7QUFDRCIsImZpbGUiOiJmYWNldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRWRnZSA9IHJlcXVpcmUoJy4vZWRnZScpLFxuICAgICAgTm9ybWFsID0gcmVxdWlyZSgnLi9ub3JtYWwnKSxcbiAgICAgIFZlcnRleCA9IHJlcXVpcmUoJy4vdmVydGV4JyksXG4gICAgICBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLFxuICAgICAgZmFjZXRVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9mYWNldCcpLFxuICAgICAgYXJyYXlVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9hcnJheScpLFxuICAgICAgdmVydGljZXNVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy92ZXJ0aWNlcycpLFxuICAgICAgbWlkUG9pbnRVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9taWRQb2ludCcpLFxuICAgICAgYXBwcm94aW1hdGVVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9hcHByb3hpbWF0ZScpLFxuICAgICAgaW50ZXJzZWN0aW9uVXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvaW50ZXJzZWN0aW9uJyk7XG5cbmNvbnN0IHsgVkVSVElDRVNfTEVOR1RIIH0gPSBjb25zdGFudHMsXG4gICAgICB7IGNsb25lVmVydGljZXMgfSA9IHZlcnRpY2VzVXRpbGl0aWVzLFxuICAgICAgeyBmaXJzdCwgc2Vjb25kLCB0aGlyZCwgcGVybXV0ZSB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IGlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIH0gPSBhcHByb3hpbWF0ZVV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlRWRnZXMsIGNhbGN1bGF0ZU5vcm1hbCwgY2FsY3VsYXRlQXJlYSB9ID0gZmFjZXRVdGlsaXRpZXMsXG4gICAgICB7IGNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24sIGlzTWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzIH0gPSBtaWRQb2ludFV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlSW50ZXJtZWRpYXRlVmVydGV4LCBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9ucywgY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4LCBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9uSW5kZXggfSA9IGludGVyc2VjdGlvblV0aWxpdGllcztcblxuY2xhc3MgRmFjZXQge1xuICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgbm9ybWFsLCBlZGdlcykge1xuICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICB0aGlzLmVkZ2VzID0gZWRnZXM7XG4gIH1cblxuICBnZXRWZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcztcbiAgfVxuXG4gIGdldE5vcm1hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWw7XG4gIH1cblxuICBnZXRFZGdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcztcbiAgfVxuICBcbiAgZ2V0VmVydGV4UG9zaXRpb25zKCkge1xuICAgIGNvbnN0IHZlcnRleFBvc2l0aW9ucyA9IHRoaXMudmVydGljZXMubWFwKGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgY29uc3QgdmVydGV4UG9zaXRpb24gPSB2ZXJ0ZXguZ2V0UG9zaXRpb24oKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHZlcnRleFBvc2l0aW9uO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXhQb3NpdGlvbnM7XG4gIH1cbiAgXG4gIGdldFZlcnRleE5vcm1hbHMoKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy5ub3JtYWwuZ2V0RXh0ZW50KCksXG4gICAgICAgICAgdmVydGV4Tm9ybWFsID0gZXh0ZW50LCAgLy8vXG4gICAgICAgICAgdmVydGV4Tm9ybWFscyA9IFtcbiAgICAgICAgICAgIHZlcnRleE5vcm1hbCxcbiAgICAgICAgICAgIHZlcnRleE5vcm1hbCxcbiAgICAgICAgICAgIHZlcnRleE5vcm1hbCxcbiAgICAgICAgICBdO1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXhOb3JtYWxzO1xuICB9XG4gIFxuICBnZXRWZXJ0ZXhJbmRleGVzKGluZGV4KSB7IC8vL1xuICAgIGNvbnN0IHZlcnRleEluZGV4ID0gaW5kZXggKiAzLFxuICAgICAgICAgIHZlcnRleEluZGV4ZXMgPSBbXG4gICAgICAgICAgICB2ZXJ0ZXhJbmRleCArIDAsXG4gICAgICAgICAgICB2ZXJ0ZXhJbmRleCArIDEsXG4gICAgICAgICAgICB2ZXJ0ZXhJbmRleCArIDIsXG4gICAgICAgICAgXTtcbiAgICBcbiAgICByZXR1cm4gdmVydGV4SW5kZXhlcztcbiAgfVxuXG4gIGlzVG9vU21hbGwoKSB7XG4gICAgY29uc3QgYXJlYSA9IGNhbGN1bGF0ZUFyZWEodGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgYXJlYUFwcHJveGltYXRlbHlFcXVhbFRvWmVybyA9IGlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvKGFyZWEpLFxuICAgICAgICAgIHRvb1NtYWxsID0gYXJlYUFwcHJveGltYXRlbHlFcXVhbFRvWmVybzsgIC8vL1xuXG4gICAgcmV0dXJuIHRvb1NtYWxsO1xuICB9XG5cbiAgaXNNYXNrZWQobWFza2luZ0ZhY2V0KSB7XG4gICAgY29uc3QgbWFza2luZ0VkZ2VzID0gbWFza2luZ0ZhY2V0LmdldE1hc2tpbmdFZGdlcygpLFxuICAgICAgICAgIG1pZFBvaW50UG9zaXRpb24gPSBjYWxjdWxhdGVNaWRQb2ludFBvc2l0aW9uKHRoaXMudmVydGljZXMpLFxuICAgICAgICAgIG1pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyA9IGlzTWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzKG1pZFBvaW50UG9zaXRpb24sIG1hc2tpbmdFZGdlcyksXG4gICAgICAgICAgbWFza2VkID0gbWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzOyAgLy8vXG4gICAgXG4gICAgcmV0dXJuIG1hc2tlZDtcbiAgfVxuXG4gIHBlcm11dGUocGxhY2VzKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHBlcm11dGUodGhpcy52ZXJ0aWNlcywgcGxhY2VzKTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICByb3RhdGUocm90YXRpb25RdWF0ZXJuaW9uKSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgdmVydGV4LnJvdGF0ZShyb3RhdGlvblF1YXRlcm5pb24pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5ub3JtYWwgPSBjYWxjdWxhdGVOb3JtYWwodGhpcy52ZXJ0aWNlcywgTm9ybWFsKTtcblxuICAgIHRoaXMuZWRnZXMgPSBjYWxjdWxhdGVFZGdlcyh0aGlzLnZlcnRpY2VzLCBFZGdlKTtcbiAgfVxuXG4gIHJvdGF0ZUFib3V0WkF4aXMocm90YXRpb25BYm91dFpBeGlzTWF0cml4KSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgdmVydGV4LnJvdGF0ZUFib3V0WkF4aXMocm90YXRpb25BYm91dFpBeGlzTWF0cml4KTtcbiAgICB9KTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICBhcHBseVRyYW5zZm9ybXModHJhbnNmb3Jtcykge1xuICAgIHRoaXMudmVydGljZXMuZm9yRWFjaChmdW5jdGlvbih2ZXJ0ZXgpIHtcbiAgICAgIHZlcnRleC5hcHBseVRyYW5zZm9ybXModHJhbnNmb3Jtcyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5vcm1hbCA9IGNhbGN1bGF0ZU5vcm1hbCh0aGlzLnZlcnRpY2VzLCBOb3JtYWwpO1xuXG4gICAgdGhpcy5lZGdlcyA9IGNhbGN1bGF0ZUVkZ2VzKHRoaXMudmVydGljZXMsIEVkZ2UpO1xuICB9XG5cbiAgc3BsaXRXaXRoSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3Qgbm9uTnVsbEludGVyc2VjdGlvbnMgPSBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCA9IG5vbk51bGxJbnRlcnNlY3Rpb25zLmxlbmd0aDtcblxuICAgIHN3aXRjaCAobm9uTnVsbEludGVyc2VjdGlvbnNMZW5ndGgpIHtcbiAgICAgIGNhc2UgMiA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoVHdvTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDEgOlxuICAgICAgICB0aGlzLnNwbGl0V2l0aE9uZU5vbk51bGxJbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDAgOlxuICAgICAgICB0aGlzLnNwbGl0V2l0aFplcm9Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICBzcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3QgbnVsbEludGVyc2VjdGlvbkluZGV4ID0gY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4KGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIHBsYWNlcyA9IChWRVJUSUNFU19MRU5HVEggLSBudWxsSW50ZXJzZWN0aW9uSW5kZXgpICUgVkVSVElDRVNfTEVOR1RIO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IHBlcm11dGUoaW50ZXJzZWN0aW9ucywgcGxhY2VzKTtcblxuICAgIGludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDEpOyAvLy9cbiAgICBcbiAgICB0aGlzLnBlcm11dGUocGxhY2VzKTtcblxuICAgIGNvbnN0IGZpcnN0VmVydGV4ID0gZmlyc3QodGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgc2Vjb25kVmVydGV4ID0gc2Vjb25kKHRoaXMudmVydGljZXMpLFxuICAgICAgICAgIHRoaXJkVmVydGV4ID0gdGhpcmQodGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgZmlyc3RJbnRlcnNlY3Rpb24gPSBmaXJzdChpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBzZWNvbmRJbnRlcnNlY3Rpb24gPSBzZWNvbmQoaW50ZXJzZWN0aW9ucyksXG4gICAgICAgICAgZmlyc3RJbnRlcm1lZGlhdGVWZXJ0ZXggPSBjYWxjdWxhdGVJbnRlcm1lZGlhdGVWZXJ0ZXgoc2Vjb25kVmVydGV4LCB0aGlyZFZlcnRleCwgZmlyc3RJbnRlcnNlY3Rpb24sIFZlcnRleCksXG4gICAgICAgICAgc2Vjb25kSW50ZXJtZWRpYXRlVmVydGV4ID0gY2FsY3VsYXRlSW50ZXJtZWRpYXRlVmVydGV4KHRoaXJkVmVydGV4LCBmaXJzdFZlcnRleCwgc2Vjb25kSW50ZXJzZWN0aW9uLCBWZXJ0ZXgpLFxuICAgICAgICAgIGZvdXJ0aFZlcnRleCA9IGZpcnN0SW50ZXJtZWRpYXRlVmVydGV4LCAvLy9cbiAgICAgICAgICBmaWZ0aFZlcnRleCA9IHNlY29uZEludGVybWVkaWF0ZVZlcnRleCwgLy8vXG4gICAgICAgICAgc21hbGxlckZhY2V0c0luZGljZXMgPSBbXG5cbiAgICAgICAgICAgIFsgMCwgMSwgMyBdLFxuICAgICAgICAgICAgWyAzLCA0LCAwIF0sXG4gICAgICAgICAgICBbIDMsIDIsIDQgXSxcblxuICAgICAgICAgIF0sXG4gICAgICAgICAgdmVydGljZXMgPSBbXG4gICAgICAgICAgICBmaXJzdFZlcnRleCxcbiAgICAgICAgICAgIHNlY29uZFZlcnRleCxcbiAgICAgICAgICAgIHRoaXJkVmVydGV4LFxuICAgICAgICAgICAgZm91cnRoVmVydGV4LFxuICAgICAgICAgICAgZmlmdGhWZXJ0ZXhcbiAgICAgICAgICBdLFxuICAgICAgICAgIGZhY2V0ID0gdGhpczsgLy8vXG5cbiAgICBzbWFsbGVyRmFjZXRzSW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNtYWxsZXJGYWNldEluZGljZXMpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBzbWFsbGVyRmFjZXRJbmRpY2VzLCAgLy8vXG4gICAgICAgICAgICBzbWFsbGVyRmFjZXQgPSBzbWFsbGVyRmFjZXRGcm9tVmVydGljZXNBbmRJbmRpY2VzKHZlcnRpY2VzLCBpbmRpY2VzLCBmYWNldCksXG4gICAgICAgICAgICBzbWFsbGVyRmFjZXRUb29TbWFsbCA9IHNtYWxsZXJGYWNldC5pc1Rvb1NtYWxsKCk7XG5cbiAgICAgIGlmICghc21hbGxlckZhY2V0VG9vU21hbGwpIHtcbiAgICAgICAgc21hbGxlckZhY2V0cy5wdXNoKHNtYWxsZXJGYWNldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzcGxpdFdpdGhPbmVOb25OdWxsSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBub25OdWxsSW50ZXJzZWN0aW9uSW5kZXggPSBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9uSW5kZXgoaW50ZXJzZWN0aW9ucyksXG4gICAgICAgICAgcGxhY2VzID0gKFZFUlRJQ0VTX0xFTkdUSCAtIG5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCkgJSBWRVJUSUNFU19MRU5HVEg7XG5cbiAgICBpbnRlcnNlY3Rpb25zID0gcGVybXV0ZShpbnRlcnNlY3Rpb25zLCBwbGFjZXMpO1xuXG4gICAgdGhpcy5wZXJtdXRlKHBsYWNlcyk7XG5cbiAgICBjb25zdCBmaXJzdFZlcnRleCA9IGZpcnN0KHRoaXMudmVydGljZXMpLFxuICAgICAgICAgIHNlY29uZFZlcnRleCA9IHNlY29uZCh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICB0aGlyZFZlcnRleCA9IHRoaXJkKHRoaXMudmVydGljZXMpLFxuICAgICAgICAgIGZpcnN0SW50ZXJzZWN0aW9uID0gZmlyc3QoaW50ZXJzZWN0aW9ucyksXG4gICAgICAgICAgaW50ZXJtZWRpYXRlVmVydGV4ID0gY2FsY3VsYXRlSW50ZXJtZWRpYXRlVmVydGV4KGZpcnN0VmVydGV4LCBzZWNvbmRWZXJ0ZXgsIGZpcnN0SW50ZXJzZWN0aW9uLCBWZXJ0ZXgpLFxuICAgICAgICAgIGZvdXJ0aFZlcnRleCA9IGludGVybWVkaWF0ZVZlcnRleCwgIC8vL1xuICAgICAgICAgIHZlcnRpY2VzID0gW1xuICAgICAgICAgICAgZmlyc3RWZXJ0ZXgsXG4gICAgICAgICAgICBzZWNvbmRWZXJ0ZXgsXG4gICAgICAgICAgICB0aGlyZFZlcnRleCxcbiAgICAgICAgICAgIGZvdXJ0aFZlcnRleFxuICAgICAgICAgIF0sXG4gICAgICAgICAgc21hbGxlckZhY2V0c0luZGljZXMgPSBbXG5cbiAgICAgICAgICAgIFsgMCwgMywgMiBdLFxuICAgICAgICAgICAgWyAzLCAxLCAyIF0sXG5cbiAgICAgICAgICBdLFxuICAgICAgICAgIGZhY2V0ID0gdGhpcztcblxuICAgIHNtYWxsZXJGYWNldHNJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24oc21hbGxlckZhY2V0SW5kaWNlcykge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IHNtYWxsZXJGYWNldEluZGljZXMsICAvLy9cbiAgICAgICAgICAgIHNtYWxsZXJGYWNldCA9IHNtYWxsZXJGYWNldEZyb21WZXJ0aWNlc0FuZEluZGljZXModmVydGljZXMsIGluZGljZXMsIGZhY2V0KSxcbiAgICAgICAgICAgIHNtYWxsZXJGYWNldFRvb1NtYWxsID0gc21hbGxlckZhY2V0LmlzVG9vU21hbGwoKTtcblxuICAgICAgaWYgKCFzbWFsbGVyRmFjZXRUb29TbWFsbCkge1xuICAgICAgICBzbWFsbGVyRmFjZXRzLnB1c2goc21hbGxlckZhY2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNwbGl0V2l0aFplcm9Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3Qgc21hbGxlckZhY2V0ID0gdGhpcy5mcm9tVmVydGljZXModGhpcy52ZXJ0aWNlcyk7ICAvLy9cblxuICAgIHNtYWxsZXJGYWNldHMucHVzaChzbWFsbGVyRmFjZXQpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjZXQ7XG5cbmZ1bmN0aW9uIHNtYWxsZXJGYWNldEZyb21WZXJ0aWNlc0FuZEluZGljZXModmVydGljZXMsIGluZGljZXMsIGZhY2V0KSB7XG4gIHZlcnRpY2VzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBsZXQgdmVydGV4ID0gdmVydGljZXNbaW5kZXhdO1xuXG4gICAgdmVydGV4ID0gdmVydGV4LmNsb25lKCk7ICAvLy9cblxuICAgIHJldHVybiB2ZXJ0ZXg7XG4gIH0pO1xuXG4gIGNvbnN0IHNtYWxsZXJGYWNldCA9IGZhY2V0LmZyb21WZXJ0aWNlcyh2ZXJ0aWNlcyk7XG5cbiAgcmV0dXJuIHNtYWxsZXJGYWNldDtcbn1cbiJdfQ==
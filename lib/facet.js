'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./edge'),
    Normal = require('./normal'),
    Vertex = require('./vertex'),
    constants = require('./constants'),
    facetUtilities = require('./utilities/facet'),
    arrayUtilities = require('./utilities/array'),
    verticesUtilities = require('./utilities/vertices'),
    midPointUtilities = require('./utilities/midPoint'),
    approximateUtilities = require('./utilities/approximate'),
    intersectionUtilities = require('./utilities/intersection');

var VERTICES_LENGTH = constants.VERTICES_LENGTH,
    first = arrayUtilities.first,
    second = arrayUtilities.second,
    third = arrayUtilities.third,
    _permute = arrayUtilities.permute,
    isApproximatelyEqualToZero = approximateUtilities.isApproximatelyEqualToZero,
    calculateEdges = facetUtilities.calculateEdges,
    calculateNormal = facetUtilities.calculateNormal,
    calculateArea = facetUtilities.calculateArea,
    rotateVertices = verticesUtilities.rotateVertices,
    transformVertices = verticesUtilities.transformVertices,
    rotateVerticesAboutZAxis = verticesUtilities.rotateVerticesAboutZAxis,
    calculateMidPointPosition = midPointUtilities.calculateMidPointPosition,
    isMidPointPositionToOneSideOfMaskingEdges = midPointUtilities.isMidPointPositionToOneSideOfMaskingEdges,
    calculateIntermediateVertex = intersectionUtilities.calculateIntermediateVertex,
    calculateNonNullIntersections = intersectionUtilities.calculateNonNullIntersections,
    calculateNullIntersectionIndex = intersectionUtilities.calculateNullIntersectionIndex,
    calculateNonNullIntersectionIndex = intersectionUtilities.calculateNonNullIntersectionIndex;

var Facet = function () {
  function Facet(vertices, normal, edges) {
    _classCallCheck(this, Facet);

    this.vertices = vertices;
    this.normal = normal;
    this.edges = edges;
  }

  _createClass(Facet, [{
    key: 'getVertices',
    value: function getVertices() {
      return this.vertices;
    }
  }, {
    key: 'getNormal',
    value: function getNormal() {
      return this.normal;
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this.edges;
    }
  }, {
    key: 'getVertexPositions',
    value: function getVertexPositions() {
      var vertexPositions = this.vertices.map(function (vertex) {
        var vertexPosition = vertex.getPosition();

        return vertexPosition;
      });

      return vertexPositions;
    }
  }, {
    key: 'getVertexNormals',
    value: function getVertexNormals() {
      var extent = this.normal.getExtent(),
          vertexNormal = extent,
          ///
      vertexNormals = [vertexNormal, vertexNormal, vertexNormal];

      return vertexNormals;
    }
  }, {
    key: 'getVertexIndexes',
    value: function getVertexIndexes(index) {
      ///
      var vertexIndex = index * 3,
          vertexIndexes = [vertexIndex + 0, vertexIndex + 1, vertexIndex + 2];

      return vertexIndexes;
    }
  }, {
    key: 'isMasked',
    value: function isMasked(maskingFacet) {
      var maskingEdges = maskingFacet.getMaskingEdges(),
          midPointPosition = calculateMidPointPosition(this.vertices),
          midPointPositionToOneSideOfMaskingEdges = isMidPointPositionToOneSideOfMaskingEdges(midPointPosition, maskingEdges),
          masked = midPointPositionToOneSideOfMaskingEdges; ///

      return masked;
    }
  }, {
    key: 'isTooSmall',
    value: function isTooSmall() {
      var area = calculateArea(this.vertices),
          areaApproximatelyEqualToZero = isApproximatelyEqualToZero(area),
          tooSmall = areaApproximatelyEqualToZero; ///

      return tooSmall;
    }
  }, {
    key: 'permute',
    value: function permute(places) {
      this.vertices = _permute(this.vertices, places);
    }
  }, {
    key: 'rotate',
    value: function rotate(rotationQuaternion) {
      this.vertices = rotateVertices(this.vertices, rotationQuaternion);

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotateAboutZAxis',
    value: function rotateAboutZAxis(rotationAboutZAxisMatrix) {
      this.vertices = rotateVerticesAboutZAxis(this.vertices, rotationAboutZAxisMatrix);

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'applyTransforms',
    value: function applyTransforms(transforms) {
      this.vertices = transformVertices(this.vertices, transforms);

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'splitWithIntersections',
    value: function splitWithIntersections(intersections, smallerFacets) {
      var nonNullIntersections = calculateNonNullIntersections(intersections),
          nonNullIntersectionsLength = nonNullIntersections.length;

      switch (nonNullIntersectionsLength) {
        case 2:
          this.splitWithTwoNonNullIntersections(intersections, smallerFacets);
          break;

        case 1:
          this.splitWithOneNonNullIntersection(intersections, smallerFacets);
          break;

        case 0:
          this.splitWithZeroNonNullIntersections(intersections, smallerFacets);
          break;
      }
    }
  }, {
    key: 'splitWithTwoNonNullIntersections',
    value: function splitWithTwoNonNullIntersections(intersections, smallerFacets) {
      var nullIntersectionIndex = calculateNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(1); ///

      this.permute(places);

      var firstVertex = first(this.vertices),
          secondVertex = second(this.vertices),
          thirdVertex = third(this.vertices),
          firstIntersection = first(intersections),
          secondIntersection = second(intersections),
          firstIntermediateVertex = calculateIntermediateVertex(secondVertex, thirdVertex, firstIntersection, Vertex),
          secondIntermediateVertex = calculateIntermediateVertex(thirdVertex, firstVertex, secondIntersection, Vertex),
          firstVertices = [firstVertex, secondVertex, firstIntermediateVertex],
          secondVertices = [firstIntermediateVertex, secondIntermediateVertex, firstVertex],
          thirdVertices = [firstIntermediateVertex, thirdVertex, secondIntermediateVertex],
          firstFacet = this.fromVertices(firstVertices),
          secondFacet = this.fromVertices(secondVertices),
          thirdFacet = this.fromVertices(thirdVertices),
          firstFacetTooSmall = firstFacet.isTooSmall(),
          secondFacetTooSmall = secondFacet.isTooSmall(),
          thirdFacetTooSmall = thirdFacet.isTooSmall();

      if (!firstFacetTooSmall) {
        smallerFacets.push(firstFacet);
      }

      if (!secondFacetTooSmall) {
        smallerFacets.push(secondFacet);
      }

      if (!thirdFacetTooSmall) {
        smallerFacets.push(thirdFacet);
      }
    }
  }, {
    key: 'splitWithOneNonNullIntersection',
    value: function splitWithOneNonNullIntersection(intersections, smallerFacets) {
      var nonNullIntersectionIndex = calculateNonNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nonNullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      this.permute(places);

      var firstVertex = first(this.vertices),
          secondVertex = second(this.vertices),
          thirdVertex = third(this.vertices),
          firstIntersection = first(intersections),
          intermediateVertex = calculateIntermediateVertex(firstVertex, secondVertex, firstIntersection, Vertex),
          firstVertices = [firstVertex, intermediateVertex, thirdVertex],
          secondVertices = [intermediateVertex, secondVertex, thirdVertex],
          firstFacet = this.fromVertices(firstVertices),
          secondFacet = this.fromVertices(secondVertices),
          firstFacetTooSmall = firstFacet.isTooSmall(),
          secondFacetTooSmall = secondFacet.isTooSmall();

      if (!firstFacetTooSmall) {
        smallerFacets.push(firstFacet);
      }

      if (!secondFacetTooSmall) {
        smallerFacets.push(secondFacet);
      }
    }
  }, {
    key: 'splitWithZeroNonNullIntersections',
    value: function splitWithZeroNonNullIntersections(intersections, smallerFacets) {
      var smallerFacet = this; ///

      smallerFacets.push(smallerFacet);
    }
  }]);

  return Facet;
}();

module.exports = Facet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9mYWNldC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIk5vcm1hbCIsIlZlcnRleCIsImNvbnN0YW50cyIsImZhY2V0VXRpbGl0aWVzIiwiYXJyYXlVdGlsaXRpZXMiLCJ2ZXJ0aWNlc1V0aWxpdGllcyIsIm1pZFBvaW50VXRpbGl0aWVzIiwiYXBwcm94aW1hdGVVdGlsaXRpZXMiLCJpbnRlcnNlY3Rpb25VdGlsaXRpZXMiLCJWRVJUSUNFU19MRU5HVEgiLCJmaXJzdCIsInNlY29uZCIsInRoaXJkIiwicGVybXV0ZSIsImlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIiwiY2FsY3VsYXRlRWRnZXMiLCJjYWxjdWxhdGVOb3JtYWwiLCJjYWxjdWxhdGVBcmVhIiwicm90YXRlVmVydGljZXMiLCJ0cmFuc2Zvcm1WZXJ0aWNlcyIsInJvdGF0ZVZlcnRpY2VzQWJvdXRaQXhpcyIsImNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24iLCJpc01pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyIsImNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleCIsImNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zIiwiY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4IiwiY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbkluZGV4IiwiRmFjZXQiLCJ2ZXJ0aWNlcyIsIm5vcm1hbCIsImVkZ2VzIiwidmVydGV4UG9zaXRpb25zIiwibWFwIiwidmVydGV4IiwidmVydGV4UG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsImV4dGVudCIsImdldEV4dGVudCIsInZlcnRleE5vcm1hbCIsInZlcnRleE5vcm1hbHMiLCJpbmRleCIsInZlcnRleEluZGV4IiwidmVydGV4SW5kZXhlcyIsIm1hc2tpbmdGYWNldCIsIm1hc2tpbmdFZGdlcyIsImdldE1hc2tpbmdFZGdlcyIsIm1pZFBvaW50UG9zaXRpb24iLCJtaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMiLCJtYXNrZWQiLCJhcmVhIiwiYXJlYUFwcHJveGltYXRlbHlFcXVhbFRvWmVybyIsInRvb1NtYWxsIiwicGxhY2VzIiwicm90YXRpb25RdWF0ZXJuaW9uIiwicm90YXRpb25BYm91dFpBeGlzTWF0cml4IiwidHJhbnNmb3JtcyIsImludGVyc2VjdGlvbnMiLCJzbWFsbGVyRmFjZXRzIiwibm9uTnVsbEludGVyc2VjdGlvbnMiLCJub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCIsImxlbmd0aCIsInNwbGl0V2l0aFR3b05vbk51bGxJbnRlcnNlY3Rpb25zIiwic3BsaXRXaXRoT25lTm9uTnVsbEludGVyc2VjdGlvbiIsInNwbGl0V2l0aFplcm9Ob25OdWxsSW50ZXJzZWN0aW9ucyIsIm51bGxJbnRlcnNlY3Rpb25JbmRleCIsInNsaWNlIiwiZmlyc3RWZXJ0ZXgiLCJzZWNvbmRWZXJ0ZXgiLCJ0aGlyZFZlcnRleCIsImZpcnN0SW50ZXJzZWN0aW9uIiwic2Vjb25kSW50ZXJzZWN0aW9uIiwiZmlyc3RJbnRlcm1lZGlhdGVWZXJ0ZXgiLCJzZWNvbmRJbnRlcm1lZGlhdGVWZXJ0ZXgiLCJmaXJzdFZlcnRpY2VzIiwic2Vjb25kVmVydGljZXMiLCJ0aGlyZFZlcnRpY2VzIiwiZmlyc3RGYWNldCIsImZyb21WZXJ0aWNlcyIsInNlY29uZEZhY2V0IiwidGhpcmRGYWNldCIsImZpcnN0RmFjZXRUb29TbWFsbCIsImlzVG9vU21hbGwiLCJzZWNvbmRGYWNldFRvb1NtYWxsIiwidGhpcmRGYWNldFRvb1NtYWxsIiwicHVzaCIsIm5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCIsImludGVybWVkaWF0ZVZlcnRleCIsInNtYWxsZXJGYWNldCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQSxJQUFNQSxPQUFPQyxRQUFRLFFBQVIsQ0FBYjtBQUFBLElBQ01DLFNBQVNELFFBQVEsVUFBUixDQURmO0FBQUEsSUFFTUUsU0FBU0YsUUFBUSxVQUFSLENB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QUFtQkcsWUFBbkI7QUFDRDs7Ozs7O0FBR0hDLE9BQU9DLE9BQVAsR0FBaUI5RCxLQUFqQiIsImZpbGUiOiJmYWNldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRWRnZSA9IHJlcXVpcmUoJy4vZWRnZScpLFxuICAgICAgTm9ybWFsID0gcmVxdWlyZSgnLi9ub3JtYWwnKSxcbiAgICAgIFZlcnRleCA9IHJlcXVpcmUoJy4vdmVydGV4JyksXG4gICAgICBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLFxuICAgICAgZmFjZXRVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9mYWNldCcpLFxuICAgICAgYXJyYXlVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9hcnJheScpLFxuICAgICAgdmVydGljZXNVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy92ZXJ0aWNlcycpLFxuICAgICAgbWlkUG9pbnRVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9taWRQb2ludCcpLFxuICAgICAgYXBwcm94aW1hdGVVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9hcHByb3hpbWF0ZScpLFxuICAgICAgaW50ZXJzZWN0aW9uVXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvaW50ZXJzZWN0aW9uJyk7XG5cbmNvbnN0IHsgVkVSVElDRVNfTEVOR1RIIH0gPSBjb25zdGFudHMsXG4gICAgICB7IGZpcnN0LCBzZWNvbmQsIHRoaXJkLCBwZXJtdXRlIH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgaXNBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8gfSA9IGFwcHJveGltYXRlVXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVFZGdlcywgY2FsY3VsYXRlTm9ybWFsLCBjYWxjdWxhdGVBcmVhIH0gPSBmYWNldFV0aWxpdGllcyxcbiAgICAgIHsgcm90YXRlVmVydGljZXMsIHRyYW5zZm9ybVZlcnRpY2VzLCByb3RhdGVWZXJ0aWNlc0Fib3V0WkF4aXMgfSA9IHZlcnRpY2VzVXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVNaWRQb2ludFBvc2l0aW9uLCBpc01pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyB9ID0gbWlkUG9pbnRVdGlsaXRpZXMsXG4gICAgICB7IGNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleCwgY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbnMsIGNhbGN1bGF0ZU51bGxJbnRlcnNlY3Rpb25JbmRleCwgY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbkluZGV4IH0gPSBpbnRlcnNlY3Rpb25VdGlsaXRpZXM7XG5cbmNsYXNzIEZhY2V0IHtcbiAgY29uc3RydWN0b3IodmVydGljZXMsIG5vcm1hbCwgZWRnZXMpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICB9XG5cbiAgZ2V0VmVydGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVydGljZXM7XG4gIH1cblxuICBnZXROb3JtYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsO1xuICB9XG5cbiAgZ2V0RWRnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXM7XG4gIH1cbiAgXG4gIGdldFZlcnRleFBvc2l0aW9ucygpIHtcbiAgICBjb25zdCB2ZXJ0ZXhQb3NpdGlvbnMgPSB0aGlzLnZlcnRpY2VzLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHtcbiAgICAgIGNvbnN0IHZlcnRleFBvc2l0aW9uID0gdmVydGV4LmdldFBvc2l0aW9uKCk7XG4gICAgICBcbiAgICAgIHJldHVybiB2ZXJ0ZXhQb3NpdGlvbjtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdmVydGV4UG9zaXRpb25zO1xuICB9XG4gIFxuICBnZXRWZXJ0ZXhOb3JtYWxzKCkge1xuICAgIGNvbnN0IGV4dGVudCA9IHRoaXMubm9ybWFsLmdldEV4dGVudCgpLFxuICAgICAgICAgIHZlcnRleE5vcm1hbCA9IGV4dGVudCwgIC8vL1xuICAgICAgICAgIHZlcnRleE5vcm1hbHMgPSBbXG4gICAgICAgICAgICB2ZXJ0ZXhOb3JtYWwsXG4gICAgICAgICAgICB2ZXJ0ZXhOb3JtYWwsXG4gICAgICAgICAgICB2ZXJ0ZXhOb3JtYWwsXG4gICAgICAgICAgXTtcbiAgICBcbiAgICByZXR1cm4gdmVydGV4Tm9ybWFscztcbiAgfVxuICBcbiAgZ2V0VmVydGV4SW5kZXhlcyhpbmRleCkgeyAvLy9cbiAgICBjb25zdCB2ZXJ0ZXhJbmRleCA9IGluZGV4ICogMyxcbiAgICAgICAgICB2ZXJ0ZXhJbmRleGVzID0gW1xuICAgICAgICAgICAgdmVydGV4SW5kZXggKyAwLFxuICAgICAgICAgICAgdmVydGV4SW5kZXggKyAxLFxuICAgICAgICAgICAgdmVydGV4SW5kZXggKyAyLFxuICAgICAgICAgIF07XG4gICAgXG4gICAgcmV0dXJuIHZlcnRleEluZGV4ZXM7XG4gIH1cblxuICBpc01hc2tlZChtYXNraW5nRmFjZXQpIHtcbiAgICBjb25zdCBtYXNraW5nRWRnZXMgPSBtYXNraW5nRmFjZXQuZ2V0TWFza2luZ0VkZ2VzKCksXG4gICAgICAgICAgbWlkUG9pbnRQb3NpdGlvbiA9IGNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24odGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgbWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzID0gaXNNaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMobWlkUG9pbnRQb3NpdGlvbiwgbWFza2luZ0VkZ2VzKSxcbiAgICAgICAgICBtYXNrZWQgPSBtaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXM7ICAvLy9cbiAgICBcbiAgICByZXR1cm4gbWFza2VkO1xuICB9XG5cbiAgaXNUb29TbWFsbCgpIHtcbiAgICBjb25zdCBhcmVhID0gY2FsY3VsYXRlQXJlYSh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICBhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvID0gaXNBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8oYXJlYSksXG4gICAgICAgICAgdG9vU21hbGwgPSBhcmVhQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvOyAgLy8vXG5cbiAgICByZXR1cm4gdG9vU21hbGw7XG4gIH1cblxuICBwZXJtdXRlKHBsYWNlcykge1xuICAgIHRoaXMudmVydGljZXMgPSBwZXJtdXRlKHRoaXMudmVydGljZXMsIHBsYWNlcyk7XG4gIH1cblxuICByb3RhdGUocm90YXRpb25RdWF0ZXJuaW9uKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHJvdGF0ZVZlcnRpY2VzKHRoaXMudmVydGljZXMsIHJvdGF0aW9uUXVhdGVybmlvbik7XG4gICAgXG4gICAgdGhpcy5ub3JtYWwgPSBjYWxjdWxhdGVOb3JtYWwodGhpcy52ZXJ0aWNlcywgTm9ybWFsKTtcblxuICAgIHRoaXMuZWRnZXMgPSBjYWxjdWxhdGVFZGdlcyh0aGlzLnZlcnRpY2VzLCBFZGdlKTtcbiAgfVxuXG4gIHJvdGF0ZUFib3V0WkF4aXMocm90YXRpb25BYm91dFpBeGlzTWF0cml4KSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHJvdGF0ZVZlcnRpY2VzQWJvdXRaQXhpcyh0aGlzLnZlcnRpY2VzLCByb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpO1xuICAgIFxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICBhcHBseVRyYW5zZm9ybXModHJhbnNmb3Jtcykge1xuICAgIHRoaXMudmVydGljZXMgPSB0cmFuc2Zvcm1WZXJ0aWNlcyh0aGlzLnZlcnRpY2VzLCB0cmFuc2Zvcm1zKTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICBzcGxpdFdpdGhJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBub25OdWxsSW50ZXJzZWN0aW9ucyA9IGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIG5vbk51bGxJbnRlcnNlY3Rpb25zTGVuZ3RoID0gbm9uTnVsbEludGVyc2VjdGlvbnMubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCkge1xuICAgICAgY2FzZSAyIDpcbiAgICAgICAgdGhpcy5zcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMSA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoT25lTm9uTnVsbEludGVyc2VjdGlvbihpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMCA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoWmVyb05vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgXG4gIHNwbGl0V2l0aFR3b05vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBudWxsSW50ZXJzZWN0aW9uSW5kZXggPSBjYWxjdWxhdGVOdWxsSW50ZXJzZWN0aW9uSW5kZXgoaW50ZXJzZWN0aW9ucyksXG4gICAgICAgICAgcGxhY2VzID0gKFZFUlRJQ0VTX0xFTkdUSCAtIG51bGxJbnRlcnNlY3Rpb25JbmRleCkgJSBWRVJUSUNFU19MRU5HVEg7XG5cbiAgICBpbnRlcnNlY3Rpb25zID0gcGVybXV0ZShpbnRlcnNlY3Rpb25zLCBwbGFjZXMpO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdGlvbnMuc2xpY2UoMSk7IC8vL1xuICAgIFxuICAgIHRoaXMucGVybXV0ZShwbGFjZXMpO1xuXG4gICAgY29uc3QgZmlyc3RWZXJ0ZXggPSBmaXJzdCh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICBzZWNvbmRWZXJ0ZXggPSBzZWNvbmQodGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgdGhpcmRWZXJ0ZXggPSB0aGlyZCh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICBmaXJzdEludGVyc2VjdGlvbiA9IGZpcnN0KGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIHNlY29uZEludGVyc2VjdGlvbiA9IHNlY29uZChpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBmaXJzdEludGVybWVkaWF0ZVZlcnRleCA9IGNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleChzZWNvbmRWZXJ0ZXgsIHRoaXJkVmVydGV4LCBmaXJzdEludGVyc2VjdGlvbiwgVmVydGV4KSxcbiAgICAgICAgICBzZWNvbmRJbnRlcm1lZGlhdGVWZXJ0ZXggPSBjYWxjdWxhdGVJbnRlcm1lZGlhdGVWZXJ0ZXgodGhpcmRWZXJ0ZXgsIGZpcnN0VmVydGV4LCBzZWNvbmRJbnRlcnNlY3Rpb24sIFZlcnRleCksXG4gICAgICAgICAgZmlyc3RWZXJ0aWNlcyA9IFtcbiAgICAgICAgICAgIGZpcnN0VmVydGV4LFxuICAgICAgICAgICAgc2Vjb25kVmVydGV4LFxuICAgICAgICAgICAgZmlyc3RJbnRlcm1lZGlhdGVWZXJ0ZXhcbiAgICAgICAgICBdLFxuICAgICAgICAgIHNlY29uZFZlcnRpY2VzID0gW1xuICAgICAgICAgICAgZmlyc3RJbnRlcm1lZGlhdGVWZXJ0ZXgsXG4gICAgICAgICAgICBzZWNvbmRJbnRlcm1lZGlhdGVWZXJ0ZXgsXG4gICAgICAgICAgICBmaXJzdFZlcnRleFxuICAgICAgICAgIF0sXG4gICAgICAgICAgdGhpcmRWZXJ0aWNlcyA9IFtcbiAgICAgICAgICAgIGZpcnN0SW50ZXJtZWRpYXRlVmVydGV4LFxuICAgICAgICAgICAgdGhpcmRWZXJ0ZXgsXG4gICAgICAgICAgICBzZWNvbmRJbnRlcm1lZGlhdGVWZXJ0ZXhcbiAgICAgICAgICBdLFxuICAgICAgICAgIGZpcnN0RmFjZXQgPSB0aGlzLmZyb21WZXJ0aWNlcyhmaXJzdFZlcnRpY2VzKSxcbiAgICAgICAgICBzZWNvbmRGYWNldCA9IHRoaXMuZnJvbVZlcnRpY2VzKHNlY29uZFZlcnRpY2VzKSxcbiAgICAgICAgICB0aGlyZEZhY2V0ID0gdGhpcy5mcm9tVmVydGljZXModGhpcmRWZXJ0aWNlcyksXG4gICAgICAgICAgZmlyc3RGYWNldFRvb1NtYWxsID0gZmlyc3RGYWNldC5pc1Rvb1NtYWxsKCksXG4gICAgICAgICAgc2Vjb25kRmFjZXRUb29TbWFsbCA9IHNlY29uZEZhY2V0LmlzVG9vU21hbGwoKSxcbiAgICAgICAgICB0aGlyZEZhY2V0VG9vU21hbGwgPSB0aGlyZEZhY2V0LmlzVG9vU21hbGwoKTtcblxuICAgIGlmICghZmlyc3RGYWNldFRvb1NtYWxsKSB7XG4gICAgICBzbWFsbGVyRmFjZXRzLnB1c2goZmlyc3RGYWNldCk7XG4gICAgfVxuXG4gICAgaWYgKCFzZWNvbmRGYWNldFRvb1NtYWxsKSB7XG4gICAgICBzbWFsbGVyRmFjZXRzLnB1c2goc2Vjb25kRmFjZXQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcmRGYWNldFRvb1NtYWxsKSB7XG4gICAgICBzbWFsbGVyRmFjZXRzLnB1c2godGhpcmRGYWNldCk7XG4gICAgfVxuICB9XG5cbiAgc3BsaXRXaXRoT25lTm9uTnVsbEludGVyc2VjdGlvbihpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3Qgbm9uTnVsbEludGVyc2VjdGlvbkluZGV4ID0gY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbkluZGV4KGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIHBsYWNlcyA9IChWRVJUSUNFU19MRU5HVEggLSBub25OdWxsSW50ZXJzZWN0aW9uSW5kZXgpICUgVkVSVElDRVNfTEVOR1RIO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IHBlcm11dGUoaW50ZXJzZWN0aW9ucywgcGxhY2VzKTtcblxuICAgIHRoaXMucGVybXV0ZShwbGFjZXMpO1xuXG4gICAgY29uc3QgZmlyc3RWZXJ0ZXggPSBmaXJzdCh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICBzZWNvbmRWZXJ0ZXggPSBzZWNvbmQodGhpcy52ZXJ0aWNlcyksXG4gICAgICAgICAgdGhpcmRWZXJ0ZXggPSB0aGlyZCh0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICBmaXJzdEludGVyc2VjdGlvbiA9IGZpcnN0KGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIGludGVybWVkaWF0ZVZlcnRleCA9IGNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleChmaXJzdFZlcnRleCwgc2Vjb25kVmVydGV4LCBmaXJzdEludGVyc2VjdGlvbiwgVmVydGV4KSxcbiAgICAgICAgICBmaXJzdFZlcnRpY2VzID0gW1xuICAgICAgICAgICAgZmlyc3RWZXJ0ZXgsXG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVWZXJ0ZXgsXG4gICAgICAgICAgICB0aGlyZFZlcnRleFxuICAgICAgICAgIF0sXG4gICAgICAgICAgc2Vjb25kVmVydGljZXMgPSBbXG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVWZXJ0ZXgsXG4gICAgICAgICAgICBzZWNvbmRWZXJ0ZXgsXG4gICAgICAgICAgICB0aGlyZFZlcnRleFxuICAgICAgICAgIF0sXG4gICAgICAgICAgZmlyc3RGYWNldCA9IHRoaXMuZnJvbVZlcnRpY2VzKGZpcnN0VmVydGljZXMpLFxuICAgICAgICAgIHNlY29uZEZhY2V0ID0gdGhpcy5mcm9tVmVydGljZXMoc2Vjb25kVmVydGljZXMpLFxuICAgICAgICAgIGZpcnN0RmFjZXRUb29TbWFsbCA9IGZpcnN0RmFjZXQuaXNUb29TbWFsbCgpLFxuICAgICAgICAgIHNlY29uZEZhY2V0VG9vU21hbGwgPSBzZWNvbmRGYWNldC5pc1Rvb1NtYWxsKCk7XG5cbiAgICBpZiAoIWZpcnN0RmFjZXRUb29TbWFsbCkge1xuICAgICAgc21hbGxlckZhY2V0cy5wdXNoKGZpcnN0RmFjZXQpO1xuICAgIH1cblxuICAgIGlmICghc2Vjb25kRmFjZXRUb29TbWFsbCkge1xuICAgICAgc21hbGxlckZhY2V0cy5wdXNoKHNlY29uZEZhY2V0KTtcbiAgICB9XG4gIH1cblxuICBzcGxpdFdpdGhaZXJvTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IHNtYWxsZXJGYWNldCA9IHRoaXM7ICAvLy9cblxuICAgIHNtYWxsZXJGYWNldHMucHVzaChzbWFsbGVyRmFjZXQpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjZXQ7XG4iXX0=
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayUtilities = require('../../utilities/array'),
    vectorUtilities = require('../../utilities/vector'),
    vertexUtilities = require('../../utilities/vertex'),
    rotationUtilities = require('../../utilities/rotation'),
    approximateUtilities = require('../../utilities/approximate');

var first = arrayUtilities.first,
    second = arrayUtilities.second,
    rotateAboutZAxis = vertexUtilities.rotateAboutZAxis,
    normalise3 = vectorUtilities.normalise3,
    isApproximatelyEqualToZero = approximateUtilities.isApproximatelyEqualToZero,
    calculateForwardsRotationAboutZAxisMatrix = rotationUtilities.calculateForwardsRotationAboutZAxisMatrix,
    calculateBackwardsRotationAboutZAxisMatrix = rotationUtilities.calculateBackwardsRotationAboutZAxisMatrix;

var VerticalLineInXYPlane = function () {
  function VerticalLineInXYPlane(position, rotationAboutZAxisMatrix) {
    _classCallCheck(this, VerticalLineInXYPlane);

    this.position = position;

    this.rotationAboutZAxisMatrix = rotationAboutZAxisMatrix;
  }

  _createClass(VerticalLineInXYPlane, [{
    key: 'getRotationAboutZAxisMatrix',
    value: function getRotationAboutZAxisMatrix() {
      return this.rotationAboutZAxisMatrix;
    }
  }, {
    key: 'splitFacets',
    value: function splitFacets(facets) {
      var smallerFacets = [],
          forwardsRotationAboutZAxisMatrix = calculateForwardsRotationAboutZAxisMatrix(this.rotationAboutZAxisMatrix),
          backwardsRotationAboutZAxisMatrix = calculateBackwardsRotationAboutZAxisMatrix(this.rotationAboutZAxisMatrix);

      facets.forEach(function (facet) {
        facet.rotateAboutZAxis(forwardsRotationAboutZAxisMatrix);

        this.splitFacet(facet, smallerFacets);
      }.bind(this));

      smallerFacets.forEach(function (smallerFacet) {
        smallerFacet.rotateAboutZAxis(backwardsRotationAboutZAxisMatrix);
      });

      return smallerFacets;
    }
  }, {
    key: 'splitFacet',
    value: function splitFacet(facet, smallerFacets) {
      var intersections = this.calculateIntersectionsWithFacet(facet);

      facet.split(intersections, smallerFacets);
    }
  }, {
    key: 'calculateIntersectionsWithFacet',
    value: function calculateIntersectionsWithFacet(facet) {
      var lines = facet.getLines(),
          intersections = lines.map(function (line) {
        var intersection = this.calculateIntersection(line);

        return intersection;
      }.bind(this));

      return intersections;
    }
  }, {
    key: 'calculateIntersection',
    value: function calculateIntersection(line) {
      var intersection = null;

      var lineNonParallel = isLineNonParallel(line);

      if (lineNonParallel) {
        var lineIntersection = this.calculateLineIntersection(line),
            lineIntersectionNonTrivial = isIntersectionNonTrivial(lineIntersection);

        if (lineIntersectionNonTrivial) {
          intersection = lineIntersection; ///
        }
      }

      return intersection;
    }
  }, {
    key: 'calculateLineIntersection',
    value: function calculateLineIntersection(line) {
      var linePosition = line.getPosition(),
          lineExtent = line.getExtent(),
          positionComponents = this.position,
          ///
      linePositionComponents = linePosition,
          ///
      lineExtentComponents = lineExtent,
          ///
      firstPositionComponent = first(positionComponents),
          firstLinePositionComponent = first(linePositionComponents),
          firstLineExtentComponent = first(lineExtentComponents),
          lineIntersection = (firstPositionComponent - firstLinePositionComponent) / firstLineExtentComponent;

      return lineIntersection;
    }
  }], [{
    key: 'fromLineInXYPlane',
    value: function fromLineInXYPlane(lineInXYPlane) {
      var lineInXYPlanePosition = lineInXYPlane.getPosition(),
          lineInXYPlaneExtent = lineInXYPlane.getExtent(),
          unitLineInXYPlaneExtent = normalise3(lineInXYPlaneExtent),
          unitLineInXYPlaneExtentComponents = unitLineInXYPlaneExtent,
          ///
      firstUnitLineInXYPlaneExtentComponent = first(unitLineInXYPlaneExtentComponents),
          secondUnitLineInXYPlaneExtentComponent = second(unitLineInXYPlaneExtentComponents),
          angleOfRotationCosine = +secondUnitLineInXYPlaneExtentComponent,
          ///
      angleOfRotationSine = -firstUnitLineInXYPlaneExtentComponent,
          ///
      c = angleOfRotationCosine,
          s = angleOfRotationSine,
          rotationAboutZAxisMatrix = [c, -s, 0, +s, c, 0, 0, 0, 1],
          ///
      position = rotateAboutZAxis(lineInXYPlanePosition, rotationAboutZAxisMatrix);

      var verticalLineInXYPlane = new VerticalLineInXYPlane(position, rotationAboutZAxisMatrix);

      return verticalLineInXYPlane;
    }
  }]);

  return VerticalLineInXYPlane;
}();

module.exports = VerticalLineInXYPlane;

function isLineNonParallel(line) {
  var lineExtent = line.getExtent(),
      lineExtentComponents = lineExtent,
      ///
  firstLineExtentComponent = first(lineExtentComponents),
      secondLineExtentComponent = second(lineExtentComponents),
      lineAngleTangent = firstLineExtentComponent / secondLineExtentComponent,
      lineAngleTangentApproximatelyEqualToZero = isApproximatelyEqualToZero(lineAngleTangent),
      lineParallel = lineAngleTangentApproximatelyEqualToZero,
      ///
  lineNonParallel = !lineParallel;

  return lineNonParallel;
}

function isIntersectionNonTrivial(intersection) {
  var intersectionNonTrivial = intersection > 0 && intersection < 1;

  return intersectionNonTrivial;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2VzNi9mYWNldC92ZXJ0aWNhbC5qcyJdLCJuYW1lcyI6WyJhcnJheVV0aWxpdGllcyIsInJlcXVpcmUiLCJ2ZWN0b3JVdGlsaXRpZXMiLCJ2ZXJ0ZXhVdGlsaXRpZXMiLCJyb3RhdGlvblV0aWxpdGllcyIsImFwcHJveGltYXRlVXRpbGl0aWVzIiwiZmlyc3QiLCJzZWNvbmQiLCJyb3RhdGVBYm91dFpBeGlzIiwibm9ybWFsaXNlMyIsImlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvIiwiY2FsY3VsYXRlRm9yd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgiLCJjYWxjdWxhdGVCYWNrd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgiLCJWZXJ0aWNhbExpbmVJblhZUGxhbmUiLCJwb3NpdGlvbiIsInJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsImZhY2V0cyIsInNtYWxsZXJGYWNldHMiLCJmb3J3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsImJhY2t3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCIsImZvckVhY2giLCJmYWNldCIsInNwbGl0RmFjZXQiLCJiaW5kIiwic21hbGxlckZhY2V0IiwiaW50ZXJzZWN0aW9ucyIsImNhbGN1bGF0ZUludGVyc2VjdGlvbnNXaXRoRmFjZXQiLCJzcGxpdCIsImxpbmVzIiwiZ2V0TGluZXMiLCJtYXAiLCJsaW5lIiwiaW50ZXJzZWN0aW9uIiwiY2FsY3VsYXRlSW50ZXJzZWN0aW9uIiwibGluZU5vblBhcmFsbGVsIiwiaXNMaW5lTm9uUGFyYWxsZWwiLCJsaW5lSW50ZXJzZWN0aW9uIiwiY2FsY3VsYXRlTGluZUludGVyc2VjdGlvbiIsImxpbmVJbnRlcnNlY3Rpb25Ob25Ucml2aWFsIiwiaXNJbnRlcnNlY3Rpb25Ob25Ucml2aWFsIiwibGluZVBvc2l0aW9uIiwiZ2V0UG9zaXRpb24iLCJsaW5lRXh0ZW50IiwiZ2V0RXh0ZW50IiwicG9zaXRpb25Db21wb25lbnRzIiwibGluZVBvc2l0aW9uQ29tcG9uZW50cyIsImxpbmVFeHRlbnRDb21wb25lbnRzIiwiZmlyc3RQb3NpdGlvbkNvbXBvbmVudCIsImZpcnN0TGluZVBvc2l0aW9uQ29tcG9uZW50IiwiZmlyc3RMaW5lRXh0ZW50Q29tcG9uZW50IiwibGluZUluWFlQbGFuZSIsImxpbmVJblhZUGxhbmVQb3NpdGlvbiIsImxpbmVJblhZUGxhbmVFeHRlbnQiLCJ1bml0TGluZUluWFlQbGFuZUV4dGVudCIsInVuaXRMaW5lSW5YWVBsYW5lRXh0ZW50Q29tcG9uZW50cyIsImZpcnN0VW5pdExpbmVJblhZUGxhbmVFeHRlbnRDb21wb25lbnQiLCJzZWNvbmRVbml0TGluZUluWFlQbGFuZUV4dGVudENvbXBvbmVudCIsImFuZ2xlT2ZSb3RhdGlvbkNvc2luZSIsImFuZ2xlT2ZSb3RhdGlvblNpbmUiLCJjIiwicyIsInZlcnRpY2FsTGluZUluWFlQbGFuZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZWNvbmRMaW5lRXh0ZW50Q29tcG9uZW50IiwibGluZUFuZ2xlVGFuZ2VudCIsImxpbmVBbmdsZVRhbmdlbnRBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8iLCJsaW5lUGFyYWxsZWwiLCJpbnRlcnNlY3Rpb25Ob25Ucml2aWFsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUEsSUFBTUEsaUJBQWlCQyxRQUFRLHVCQUFSLENBQXZCO0FBQUEsSUFDTUMsa0JBQWtCRCxRQUFRLHdCQUFSLENBRHhCO0FBQUEsSUFFTUUsa0JBQWtCRixRQUFRLHdCQUFSLENBRnhCO0FBQUEsSUFHTUcsb0JBQW9CSCxRQUFRLDBCQUFSLENBSDFCO0FBQUEsSUFJTUksdUJBQXVCSixRQUFRLDZCQUFSLENBSjdCOztJQU1RSyxLLEdBQWtCTixjLENBQWxCTSxLO0lBQU9DLE0sR0FBV1AsYyxDQUFYTyxNO0lBQ1BDLGdCLEdBQXFCTCxlLENBQXJCSyxnQjtJQUNBQyxVLEdBQWVQLGUsQ0FBZk8sVTtJQUNBQywwQixHQUErQkwsb0IsQ0FBL0JLLDBCO0lBQ0FDLHlDLEdBQTBGUCxpQixDQUExRk8seUM7SUFBMkNDLDBDLEdBQStDUixpQixDQUEvQ1EsMEM7O0lBRTdDQyxxQjtBQUNKLGlDQUFZQyxRQUFaLEVBQXNCQyx3QkFBdEIsRUFBZ0Q7QUFBQTs7QUFDOUMsU0FBS0QsUUFBTCxHQUFnQkEsUUFBaEI7O0FBRUEsU0FBS0Msd0JBQUwsR0FBZ0NBLHdCQUFoQztBQUNEOzs7O2tEQUU2QjtBQUM1QixhQUFPLEtBQUtBLHdCQUFaO0FBQ0Q7OztnQ0FFV0MsTSxFQUFRO0FBQ2xCLFVBQU1DLGdCQUFnQixFQUF0QjtBQUFBLFVBQ01DLG1DQUFtQ1AsMENBQTBDLEtBQUtJLHdCQUEvQyxDQUR6QztBQUFBLFVBRU1JLG9DQUFvQ1AsMkNBQTJDLEtBQUtHLHdCQUFoRCxDQUYxQzs7QUFJQUMsYUFBT0ksT0FBUCxDQUFlLFVBQVNDLEtBQVQsRUFBZ0I7QUFDN0JBLGNBQU1iLGdCQUFOLENBQXVCVSxnQ0FBdkI7O0FBRUEsYUFBS0ksVUFBTCxDQUFnQkQsS0FBaEIsRUFBdUJKLGFBQXZCO0FBQ0QsT0FKYyxDQUliTSxJQUphLENBSVIsSUFKUSxDQUFmOztBQU1BTixvQkFBY0csT0FBZCxDQUFzQixVQUFTSSxZQUFULEVBQXVCO0FBQzNDQSxxQkFBYWhCLGdCQUFiLENBQThCVyxpQ0FBOUI7QUFDRCxPQUZEOztBQUlBLGFBQU9GLGFBQVA7QUFDRDs7OytCQUVVSSxLLEVBQU9KLGEsRUFBZTtBQUMvQixVQUFNUSxnQkFBZ0IsS0FBS0MsK0JBQUwsQ0FBcUNMLEtBQXJDLENBQXRCOztBQUVBQSxZQUFNTSxLQUFOLENBQVlGLGFBQVosRUFBMkJSLGFBQTNCO0FBQ0Q7OztvREFFK0JJLEssRUFBTztBQUNyQyxVQUFNTyxRQUFRUCxNQUFNUSxRQUFOLEVBQWQ7QUFBQSxVQUNNSixnQkFBZ0JHLE1BQU1FLEdBQU4sQ0FBVSxVQUFTQyxJQUFULEVBQWU7QUFDdkMsWUFBTUMsZUFBZSxLQUFLQyxxQkFBTCxDQUEyQkYsSUFBM0IsQ0FBckI7O0FBRUEsZUFBT0MsWUFBUDtBQUNELE9BSnlCLENBSXhCVCxJQUp3QixDQUluQixJQUptQixDQUFWLENBRHRCOztBQU9BLGFBQU9FLGFBQVA7QUFDRDs7OzBDQUVxQk0sSSxFQUFNO0FBQzFCLFVBQUlDLGVBQWUsSUFBbkI7O0FBRUEsVUFBTUUsa0JBQWtCQyxrQkFBa0JKLElBQWxCLENBQXhCOztBQUVBLFVBQUlHLGVBQUosRUFBcUI7QUFDbkIsWUFBTUUsbUJBQW1CLEtBQUtDLHlCQUFMLENBQStCTixJQUEvQixDQUF6QjtBQUFBLFlBQ01PLDZCQUE2QkMseUJBQXlCSCxnQkFBekIsQ0FEbkM7O0FBR0EsWUFBSUUsMEJBQUosRUFBZ0M7QUFDOUJOLHlCQUFlSSxnQkFBZixDQUQ4QixDQUNJO0FBQ25DO0FBQ0Y7O0FBRUQsYUFBT0osWUFBUDtBQUNEOzs7OENBRXlCRCxJLEVBQU07QUFDOUIsVUFBTVMsZUFBZVQsS0FBS1UsV0FBTCxFQUFyQjtBQUFBLFVBQ01DLGFBQWFYLEtBQUtZLFNBQUwsRUFEbkI7QUFBQSxVQUVNQyxxQkFBcUIsS0FBSzlCLFFBRmhDO0FBQUEsVUFFMEM7QUFDcEMrQiwrQkFBeUJMLFlBSC9CO0FBQUEsVUFHNkM7QUFDdkNNLDZCQUF1QkosVUFKN0I7QUFBQSxVQUl5QztBQUNuQ0ssK0JBQXlCekMsTUFBTXNDLGtCQUFOLENBTC9CO0FBQUEsVUFNTUksNkJBQTZCMUMsTUFBTXVDLHNCQUFOLENBTm5DO0FBQUEsVUFPTUksMkJBQTJCM0MsTUFBTXdDLG9CQUFOLENBUGpDO0FBQUEsVUFRTVYsbUJBQW1CLENBQUNXLHlCQUF5QkMsMEJBQTFCLElBQXdEQyx3QkFSakY7O0FBVUEsYUFBT2IsZ0JBQVA7QUFDRDs7O3NDQUV3QmMsYSxFQUFlO0FBQ3RDLFVBQU1DLHdCQUF3QkQsY0FBY1QsV0FBZCxFQUE5QjtBQUFBLFVBQ01XLHNCQUFzQkYsY0FBY1AsU0FBZCxFQUQ1QjtBQUFBLFVBRU1VLDBCQUEwQjVDLFdBQVcyQyxtQkFBWCxDQUZoQztBQUFBLFVBR01FLG9DQUFvQ0QsdUJBSDFDO0FBQUEsVUFHb0U7QUFDOURFLDhDQUF3Q2pELE1BQU1nRCxpQ0FBTixDQUo5QztBQUFBLFVBS01FLHlDQUF5Q2pELE9BQU8rQyxpQ0FBUCxDQUwvQztBQUFBLFVBTU1HLHdCQUF3QixDQUFDRCxzQ0FOL0I7QUFBQSxVQU13RTtBQUNsRUUsNEJBQXNCLENBQUNILHFDQVA3QjtBQUFBLFVBT29FO0FBQzlESSxVQUFJRixxQkFSVjtBQUFBLFVBU01HLElBQUlGLG1CQVRWO0FBQUEsVUFVTTNDLDJCQUEyQixDQUFFNEMsQ0FBRixFQUFLLENBQUNDLENBQU4sRUFBUyxDQUFULEVBQVksQ0FBQ0EsQ0FBYixFQUFnQkQsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsQ0FWakM7QUFBQSxVQVVtRTtBQUM3RDdDLGlCQUFXTixpQkFBaUIyQyxxQkFBakIsRUFBd0NwQyx3QkFBeEMsQ0FYakI7O0FBYUEsVUFBTThDLHdCQUF3QixJQUFJaEQscUJBQUosQ0FBMEJDLFFBQTFCLEVBQW9DQyx3QkFBcEMsQ0FBOUI7O0FBRUEsYUFBTzhDLHFCQUFQO0FBQ0Q7Ozs7OztBQUdIQyxPQUFPQyxPQUFQLEdBQWlCbEQscUJBQWpCOztBQUVBLFNBQVNzQixpQkFBVCxDQUEyQkosSUFBM0IsRUFBaUM7QUFDL0IsTUFBTVcsYUFBYVgsS0FBS1ksU0FBTCxFQUFuQjtBQUFBLE1BQ01HLHVCQUF1QkosVUFEN0I7QUFBQSxNQUN5QztBQUNuQ08sNkJBQTJCM0MsTUFBTXdDLG9CQUFOLENBRmpDO0FBQUEsTUFHTWtCLDRCQUE0QnpELE9BQU91QyxvQkFBUCxDQUhsQztBQUFBLE1BSU1tQixtQkFBbUJoQiwyQkFBMkJlLHlCQUpwRDtBQUFBLE1BS01FLDJDQUEyQ3hELDJCQUEyQnVELGdCQUEzQixDQUxqRDtBQUFBLE1BTU1FLGVBQWVELHdDQU5yQjtBQUFBLE1BTStEO0FBQ3pEaEMsb0JBQWtCLENBQUNpQyxZQVB6Qjs7QUFTQSxTQUFPakMsZUFBUDtBQUNEOztBQUVELFNBQVNLLHdCQUFULENBQWtDUCxZQUFsQyxFQUFnRDtBQUM5QyxNQUFNb0MseUJBQTJCcEMsZUFBZSxDQUFoQixJQUF3QkEsZUFBZSxDQUF2RTs7QUFFQSxTQUFPb0Msc0JBQVA7QUFDRCIsImZpbGUiOiJ2ZXJ0aWNhbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXJyYXlVdGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMvYXJyYXknKSxcbiAgICAgIHZlY3RvclV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcy92ZWN0b3InKSxcbiAgICAgIHZlcnRleFV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcy92ZXJ0ZXgnKSxcbiAgICAgIHJvdGF0aW9uVXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0aWVzL3JvdGF0aW9uJyksXG4gICAgICBhcHByb3hpbWF0ZVV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcy9hcHByb3hpbWF0ZScpO1xuXG5jb25zdCB7IGZpcnN0LCBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzLFxuICAgICAgeyByb3RhdGVBYm91dFpBeGlzIH0gPSB2ZXJ0ZXhVdGlsaXRpZXMsXG4gICAgICB7IG5vcm1hbGlzZTMgfSA9IHZlY3RvclV0aWxpdGllcyxcbiAgICAgIHsgaXNBcHByb3hpbWF0ZWx5RXF1YWxUb1plcm8gfSA9IGFwcHJveGltYXRlVXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVGb3J3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCwgY2FsY3VsYXRlQmFja3dhcmRzUm90YXRpb25BYm91dFpBeGlzTWF0cml4IH0gPSByb3RhdGlvblV0aWxpdGllcztcblxuY2xhc3MgVmVydGljYWxMaW5lSW5YWVBsYW5lIHtcbiAgY29uc3RydWN0b3IocG9zaXRpb24sIHJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCkge1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcblxuICAgIHRoaXMucm90YXRpb25BYm91dFpBeGlzTWF0cml4ID0gcm90YXRpb25BYm91dFpBeGlzTWF0cml4O1xuICB9XG4gIFxuICBnZXRSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRpb25BYm91dFpBeGlzTWF0cml4O1xuICB9XG5cbiAgc3BsaXRGYWNldHMoZmFjZXRzKSB7XG4gICAgY29uc3Qgc21hbGxlckZhY2V0cyA9IFtdLFxuICAgICAgICAgIGZvcndhcmRzUm90YXRpb25BYm91dFpBeGlzTWF0cml4ID0gY2FsY3VsYXRlRm9yd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgodGhpcy5yb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpLFxuICAgICAgICAgIGJhY2t3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCA9IGNhbGN1bGF0ZUJhY2t3YXJkc1JvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCh0aGlzLnJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCk7XG4gICAgXG4gICAgZmFjZXRzLmZvckVhY2goZnVuY3Rpb24oZmFjZXQpIHtcbiAgICAgIGZhY2V0LnJvdGF0ZUFib3V0WkF4aXMoZm9yd2FyZHNSb3RhdGlvbkFib3V0WkF4aXNNYXRyaXgpO1xuXG4gICAgICB0aGlzLnNwbGl0RmFjZXQoZmFjZXQsIHNtYWxsZXJGYWNldHMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgXG4gICAgc21hbGxlckZhY2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHNtYWxsZXJGYWNldCkge1xuICAgICAgc21hbGxlckZhY2V0LnJvdGF0ZUFib3V0WkF4aXMoYmFja3dhcmRzUm90YXRpb25BYm91dFpBeGlzTWF0cml4KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzbWFsbGVyRmFjZXRzOyAgICBcbiAgfVxuXG4gIHNwbGl0RmFjZXQoZmFjZXQsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gdGhpcy5jYWxjdWxhdGVJbnRlcnNlY3Rpb25zV2l0aEZhY2V0KGZhY2V0KTtcblxuICAgIGZhY2V0LnNwbGl0KGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpO1xuICB9XG5cbiAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uc1dpdGhGYWNldChmYWNldCkge1xuICAgIGNvbnN0IGxpbmVzID0gZmFjZXQuZ2V0TGluZXMoKSxcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zID0gbGluZXMubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHRoaXMuY2FsY3VsYXRlSW50ZXJzZWN0aW9uKGxpbmUpO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuICBcbiAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uKGxpbmUpIHtcbiAgICBsZXQgaW50ZXJzZWN0aW9uID0gbnVsbDtcblxuICAgIGNvbnN0IGxpbmVOb25QYXJhbGxlbCA9IGlzTGluZU5vblBhcmFsbGVsKGxpbmUpO1xuXG4gICAgaWYgKGxpbmVOb25QYXJhbGxlbCkge1xuICAgICAgY29uc3QgbGluZUludGVyc2VjdGlvbiA9IHRoaXMuY2FsY3VsYXRlTGluZUludGVyc2VjdGlvbihsaW5lKSxcbiAgICAgICAgICAgIGxpbmVJbnRlcnNlY3Rpb25Ob25Ucml2aWFsID0gaXNJbnRlcnNlY3Rpb25Ob25Ucml2aWFsKGxpbmVJbnRlcnNlY3Rpb24pO1xuXG4gICAgICBpZiAobGluZUludGVyc2VjdGlvbk5vblRyaXZpYWwpIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdGlvbjsgIC8vL1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gIH1cblxuICBjYWxjdWxhdGVMaW5lSW50ZXJzZWN0aW9uKGxpbmUpIHtcbiAgICBjb25zdCBsaW5lUG9zaXRpb24gPSBsaW5lLmdldFBvc2l0aW9uKCksXG4gICAgICAgICAgbGluZUV4dGVudCA9IGxpbmUuZ2V0RXh0ZW50KCksXG4gICAgICAgICAgcG9zaXRpb25Db21wb25lbnRzID0gdGhpcy5wb3NpdGlvbiwgLy8vXG4gICAgICAgICAgbGluZVBvc2l0aW9uQ29tcG9uZW50cyA9IGxpbmVQb3NpdGlvbiwgLy8vXG4gICAgICAgICAgbGluZUV4dGVudENvbXBvbmVudHMgPSBsaW5lRXh0ZW50LCAvLy9cbiAgICAgICAgICBmaXJzdFBvc2l0aW9uQ29tcG9uZW50ID0gZmlyc3QocG9zaXRpb25Db21wb25lbnRzKSxcbiAgICAgICAgICBmaXJzdExpbmVQb3NpdGlvbkNvbXBvbmVudCA9IGZpcnN0KGxpbmVQb3NpdGlvbkNvbXBvbmVudHMpLFxuICAgICAgICAgIGZpcnN0TGluZUV4dGVudENvbXBvbmVudCA9IGZpcnN0KGxpbmVFeHRlbnRDb21wb25lbnRzKSxcbiAgICAgICAgICBsaW5lSW50ZXJzZWN0aW9uID0gKGZpcnN0UG9zaXRpb25Db21wb25lbnQgLSBmaXJzdExpbmVQb3NpdGlvbkNvbXBvbmVudCkgLyBmaXJzdExpbmVFeHRlbnRDb21wb25lbnQ7XG4gICAgXG4gICAgcmV0dXJuIGxpbmVJbnRlcnNlY3Rpb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUxpbmVJblhZUGxhbmUobGluZUluWFlQbGFuZSkge1xuICAgIGNvbnN0IGxpbmVJblhZUGxhbmVQb3NpdGlvbiA9IGxpbmVJblhZUGxhbmUuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgICBsaW5lSW5YWVBsYW5lRXh0ZW50ID0gbGluZUluWFlQbGFuZS5nZXRFeHRlbnQoKSxcbiAgICAgICAgICB1bml0TGluZUluWFlQbGFuZUV4dGVudCA9IG5vcm1hbGlzZTMobGluZUluWFlQbGFuZUV4dGVudCksXG4gICAgICAgICAgdW5pdExpbmVJblhZUGxhbmVFeHRlbnRDb21wb25lbnRzID0gdW5pdExpbmVJblhZUGxhbmVFeHRlbnQsICAvLy9cbiAgICAgICAgICBmaXJzdFVuaXRMaW5lSW5YWVBsYW5lRXh0ZW50Q29tcG9uZW50ID0gZmlyc3QodW5pdExpbmVJblhZUGxhbmVFeHRlbnRDb21wb25lbnRzKSxcbiAgICAgICAgICBzZWNvbmRVbml0TGluZUluWFlQbGFuZUV4dGVudENvbXBvbmVudCA9IHNlY29uZCh1bml0TGluZUluWFlQbGFuZUV4dGVudENvbXBvbmVudHMpLFxuICAgICAgICAgIGFuZ2xlT2ZSb3RhdGlvbkNvc2luZSA9ICtzZWNvbmRVbml0TGluZUluWFlQbGFuZUV4dGVudENvbXBvbmVudCwgIC8vL1xuICAgICAgICAgIGFuZ2xlT2ZSb3RhdGlvblNpbmUgPSAtZmlyc3RVbml0TGluZUluWFlQbGFuZUV4dGVudENvbXBvbmVudCwgLy8vXG4gICAgICAgICAgYyA9IGFuZ2xlT2ZSb3RhdGlvbkNvc2luZSxcbiAgICAgICAgICBzID0gYW5nbGVPZlJvdGF0aW9uU2luZSxcbiAgICAgICAgICByb3RhdGlvbkFib3V0WkF4aXNNYXRyaXggPSBbIGMsIC1zLCAwLCArcywgYywgMCwgMCwgMCwgMSBdLCAgLy8vXG4gICAgICAgICAgcG9zaXRpb24gPSByb3RhdGVBYm91dFpBeGlzKGxpbmVJblhZUGxhbmVQb3NpdGlvbiwgcm90YXRpb25BYm91dFpBeGlzTWF0cml4KTtcblxuICAgIGNvbnN0IHZlcnRpY2FsTGluZUluWFlQbGFuZSA9IG5ldyBWZXJ0aWNhbExpbmVJblhZUGxhbmUocG9zaXRpb24sIHJvdGF0aW9uQWJvdXRaQXhpc01hdHJpeCk7XG5cbiAgICByZXR1cm4gdmVydGljYWxMaW5lSW5YWVBsYW5lO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGljYWxMaW5lSW5YWVBsYW5lO1xuXG5mdW5jdGlvbiBpc0xpbmVOb25QYXJhbGxlbChsaW5lKSB7XG4gIGNvbnN0IGxpbmVFeHRlbnQgPSBsaW5lLmdldEV4dGVudCgpLFxuICAgICAgICBsaW5lRXh0ZW50Q29tcG9uZW50cyA9IGxpbmVFeHRlbnQsIC8vL1xuICAgICAgICBmaXJzdExpbmVFeHRlbnRDb21wb25lbnQgPSBmaXJzdChsaW5lRXh0ZW50Q29tcG9uZW50cyksXG4gICAgICAgIHNlY29uZExpbmVFeHRlbnRDb21wb25lbnQgPSBzZWNvbmQobGluZUV4dGVudENvbXBvbmVudHMpLFxuICAgICAgICBsaW5lQW5nbGVUYW5nZW50ID0gZmlyc3RMaW5lRXh0ZW50Q29tcG9uZW50IC8gc2Vjb25kTGluZUV4dGVudENvbXBvbmVudCxcbiAgICAgICAgbGluZUFuZ2xlVGFuZ2VudEFwcHJveGltYXRlbHlFcXVhbFRvWmVybyA9IGlzQXBwcm94aW1hdGVseUVxdWFsVG9aZXJvKGxpbmVBbmdsZVRhbmdlbnQpLFxuICAgICAgICBsaW5lUGFyYWxsZWwgPSBsaW5lQW5nbGVUYW5nZW50QXBwcm94aW1hdGVseUVxdWFsVG9aZXJvLCAvLy9cbiAgICAgICAgbGluZU5vblBhcmFsbGVsID0gIWxpbmVQYXJhbGxlbDtcblxuICByZXR1cm4gbGluZU5vblBhcmFsbGVsO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyc2VjdGlvbk5vblRyaXZpYWwoaW50ZXJzZWN0aW9uKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbk5vblRyaXZpYWwgPSAoKGludGVyc2VjdGlvbiA+IDAgKSAmJiAoaW50ZXJzZWN0aW9uIDwgMSkpO1xuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25Ob25Ucml2aWFsO1xufVxuIl19
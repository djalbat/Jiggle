'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./edge'),
    Normal = require('./normal'),
    Vertex = require('./vertex'),
    constants = require('../constants'),
    facetUtilities = require('../utilities/facet'),
    arrayUtilities = require('../utilities/array'),
    midPointUtilities = require('../utilities/midPoint'),
    intersectionUtilities = require('../utilities/intersection');

var VERTICES_LENGTH = constants.VERTICES_LENGTH,
    push = arrayUtilities.push,
    _permute = arrayUtilities.permute,
    calculateEdges = facetUtilities.calculateEdges,
    calculateNormal = facetUtilities.calculateNormal,
    calculateMidPointPosition = midPointUtilities.calculateMidPointPosition,
    isMidPointPositionToOneSideOfMaskingEdges = midPointUtilities.isMidPointPositionToOneSideOfMaskingEdges,
    calculateIntermediateVertexPosition = intersectionUtilities.calculateIntermediateVertexPosition,
    calculateNonNullIntersections = intersectionUtilities.calculateNonNullIntersections,
    calculateNullIntersectionIndex = intersectionUtilities.calculateNullIntersectionIndex,
    calculateNonNullIntersectionIndex = intersectionUtilities.calculateNonNullIntersectionIndex;

var Facet = function () {
  function Facet(vertices, normal, edges) {
    _classCallCheck(this, Facet);

    this.vertices = vertices;
    this.normal = normal;
    this.edges = edges;
  }

  _createClass(Facet, [{
    key: 'getVertices',
    value: function getVertices() {
      return this.vertices;
    }
  }, {
    key: 'getNormal',
    value: function getNormal() {
      return this.normal;
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this.edges;
    }
  }, {
    key: 'getVertexPositions',
    value: function getVertexPositions() {
      var vertexPositions = this.vertices.map(function (vertex) {
        return vertex.getPosition();
      });

      return vertexPositions;
    }
  }, {
    key: 'getVertexNormals',
    value: function getVertexNormals() {
      var normalExtent = this.normal.getExtent(),
          vertexNormal = normalExtent,
          ///
      vertexNormals = [vertexNormal, vertexNormal, vertexNormal];

      return vertexNormals;
    }
  }, {
    key: 'getVertexIndexes',
    value: function getVertexIndexes(index) {
      ///
      var vertexIndex = index * 3,
          vertexIndexes = [vertexIndex + 0, vertexIndex + 1, vertexIndex + 2];

      return vertexIndexes;
    }
  }, {
    key: 'isMasked',
    value: function isMasked(maskingFacet) {
      var maskingEdges = maskingFacet.getMaskingEdges(),
          midPointPosition = calculateMidPointPosition(this.vertices),
          midPointPositionToOneSideOfMaskingEdges = isMidPointPositionToOneSideOfMaskingEdges(midPointPosition, maskingEdges),
          masked = midPointPositionToOneSideOfMaskingEdges; ///

      return masked;
    }
  }, {
    key: 'permute',
    value: function permute(places) {
      this.vertices = _permute(this.vertices, places);

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotate',
    value: function rotate(rotationQuaternion) {
      this.vertices.forEach(function (vertex) {
        return vertex.rotate(rotationQuaternion);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'applyTransforms',
    value: function applyTransforms(transforms) {
      this.vertices.forEach(function (vertex) {
        return vertex.applyTransforms(transforms);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'splitWithIntersections',
    value: function splitWithIntersections(intersections, smallerFacets) {
      var nonNullIntersections = calculateNonNullIntersections(intersections),
          nonNullIntersectionsLength = nonNullIntersections.length;

      switch (nonNullIntersectionsLength) {
        case 2:
          this.splitWithTwoNonNullIntersections(intersections, smallerFacets);
          break;

        case 1:
          this.splitWithOneNonNullIntersection(intersections, smallerFacets);
          break;

        case 0:
          this.splitWithNoNonNullIntersections(intersections, smallerFacets);
          break;
      }
    }
  }, {
    key: 'splitWithTwoNonNullIntersections',
    value: function splitWithTwoNonNullIntersections(intersections, smallerFacets) {
      var nullIntersectionIndex = calculateNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(1); ///

      this.permute(places);

      var startVertexPositionIndexes = [1, 2],
          endVertexPositionIndexes = [2, 0],
          indexTuples = [[0, 1, 3], [3, 4, 0], [3, 2, 4]];

      this.splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets);
    }
  }, {
    key: 'splitWithOneNonNullIntersection',
    value: function splitWithOneNonNullIntersection(intersections, smallerFacets) {
      var nonNullIntersectionIndex = calculateNonNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nonNullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(0, 1); ///

      this.permute(places);

      var startVertexPositionIndexes = [0],
          endVertexPositionIndexes = [1],
          indexTuples = [[0, 3, 2], [3, 1, 2]];

      this.splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets);
    }
  }, {
    key: 'splitWithNoNonNullIntersections',
    value: function splitWithNoNonNullIntersections(intersections, smallerFacets) {
      var smallerFacet = this.fromVertices(this.vertices); ///

      smallerFacets.push(smallerFacet);
    }
  }, {
    key: 'splitWithIndexTuplesAndIntersections',
    value: function splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets) {
      var _this = this;

      var vertexPositions = this.getVertexPositions(),
          intermediateVertexPositions = intersections.map(function (intersection, index) {
        var startVertexPositionIndex = startVertexPositionIndexes[index],
            endVertexPositionIndex = endVertexPositionIndexes[index],
            startVertexPosition = vertexPositions[startVertexPositionIndex],
            endVertexPosition = vertexPositions[endVertexPositionIndex],
            intermediateVertexPosition = calculateIntermediateVertexPosition(startVertexPosition, endVertexPosition, intersection);

        return intermediateVertexPosition;
      });

      push(vertexPositions, intermediateVertexPositions);

      indexTuples.forEach(function (indexTuple) {
        var positions = vertexPositions,
            ///
        indexes = indexTuple,
            ///
        facet = _this,
            smallerFacet = smallerFacetFromPositionsIndexesAndFacet(positions, indexes, facet);

        if (smallerFacet !== null) {
          smallerFacets.push(smallerFacet);
        }
      });
    }
  }]);

  return Facet;
}();

module.exports = Facet;

function smallerFacetFromPositionsIndexesAndFacet(positions, indexes, facet) {
  var vertices = indexes.map(function (index) {
    var position = positions[index];

    position = position.slice(); ///

    var vertex = Vertex.fromPosition(position);

    return vertex;
  }),
      smallerFacet = facet.fromVertices(vertices);

  return smallerFacet;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2VzNi9wcmltaXRpdmUvZmFjZXQuanMiXSwibmFtZXMiOlsiRWRnZSIsInJlcXVpcmUiLCJOb3JtYWwiLCJWZXJ0ZXgiLCJjb25zdGFudHMiLCJmYWNldFV0aWxpdGllcyIsImFycmF5VXRpbGl0aWVzIiwibWlkUG9pbnRVdGlsaXRpZXMiLCJpbnRlcnNlY3Rpb25VdGlsaXRpZXMiLCJWRVJUSUNFU19MRU5HVEgiLCJwdXNoIiwicGVybXV0ZSIsImNhbGN1bGF0ZUVkZ2VzIiwiY2FsY3VsYXRlTm9ybWFsIiwiY2FsY3VsYXRlTWlkUG9pbnRQb3NpdGlvbiIsImlzTWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzIiwiY2FsY3VsYXRlSW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb24iLCJjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9ucyIsImNhbGN1bGF0ZU51bGxJbnRlcnNlY3Rpb25JbmRleCIsImNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCIsIkZhY2V0IiwidmVydGljZXMiLCJub3JtYWwiLCJlZGdlcyIsInZlcnRleFBvc2l0aW9ucyIsIm1hcCIsInZlcnRleCIsImdldFBvc2l0aW9uIiwibm9ybWFsRXh0ZW50IiwiZ2V0RXh0ZW50IiwidmVydGV4Tm9ybWFsIiwidmVydGV4Tm9ybWFscyIsImluZGV4IiwidmVydGV4SW5kZXgiLCJ2ZXJ0ZXhJbmRleGVzIiwibWFza2luZ0ZhY2V0IiwibWFza2luZ0VkZ2VzIiwiZ2V0TWFza2luZ0VkZ2VzIiwibWlkUG9pbnRQb3NpdGlvbiIsIm1pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyIsIm1hc2tlZCIsInBsYWNlcyIsInJvdGF0aW9uUXVhdGVybmlvbiIsImZvckVhY2giLCJyb3RhdGUiLCJ0cmFuc2Zvcm1zIiwiYXBwbHlUcmFuc2Zvcm1zIiwiaW50ZXJzZWN0aW9ucyIsInNtYWxsZXJGYWNldHMiLCJub25OdWxsSW50ZXJzZWN0aW9ucyIsIm5vbk51bGxJbnRlcnNlY3Rpb25zTGVuZ3RoIiwibGVuZ3RoIiwic3BsaXRXaXRoVHdvTm9uTnVsbEludGVyc2VjdGlvbnMiLCJzcGxpdFdpdGhPbmVOb25OdWxsSW50ZXJzZWN0aW9uIiwic3BsaXRXaXRoTm9Ob25OdWxsSW50ZXJzZWN0aW9ucyIsIm51bGxJbnRlcnNlY3Rpb25JbmRleCIsInNsaWNlIiwic3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMiLCJlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMiLCJpbmRleFR1cGxlcyIsInNwbGl0V2l0aEluZGV4VHVwbGVzQW5kSW50ZXJzZWN0aW9ucyIsIm5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCIsInNtYWxsZXJGYWNldCIsImZyb21WZXJ0aWNlcyIsImdldFZlcnRleFBvc2l0aW9ucyIsImludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9ucyIsImludGVyc2VjdGlvbiIsInN0YXJ0VmVydGV4UG9zaXRpb25JbmRleCIsImVuZFZlcnRleFBvc2l0aW9uSW5kZXgiLCJzdGFydFZlcnRleFBvc2l0aW9uIiwiZW5kVmVydGV4UG9zaXRpb24iLCJpbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbiIsImluZGV4VHVwbGUiLCJwb3NpdGlvbnMiLCJpbmRleGVzIiwiZmFjZXQiLCJzbWFsbGVyRmFjZXRGcm9tUG9zaXRpb25zSW5kZXhlc0FuZEZhY2V0IiwibW9kdWxlIiwiZXhwb3J0cyIsInBvc2l0aW9uIiwiZnJvbVBvc2l0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUEsSUFBTUEsT0FBT0MsUUFBUSxRQUFSLENBQWI7QUFBQSxJQUNNQyxTQUFTRCxRQUFRLFVBQVIsQ0FEZjtBQUFBLElBRU1FLFNBQVNGLFFBQVEsVUFBUixDQUZmO0FBQUEsSUFHTUcsWUFBWUgsUUFBUSxjQUFSLENBSGxCO0FBQUEsSUFJTUksaUJBQWlCSixRQUFRLG9CQUFSLENBSnZCO0FBQUEsSUFLTUssaUJBQWlCTCxRQUFRLG9CQUFSLENBTHZCO0FBQUEsSUFNTU0sb0JB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a0RILFNBQWxELEVBQTZEQyxPQUE3RCxFQUFzRUMsS0FBdEUsRUFBNkU7QUFDM0UsTUFBTXRELFdBQVdxRCxRQUFRakQsR0FBUixDQUFZLFVBQUNPLEtBQUQsRUFBVztBQUNoQyxRQUFJK0MsV0FBV04sVUFBVXpDLEtBQVYsQ0FBZjs7QUFFQStDLGVBQVdBLFNBQVN2QixLQUFULEVBQVgsQ0FIZ0MsQ0FHSDs7QUFFN0IsUUFBTTlCLFNBQVN2QixPQUFPNkUsWUFBUCxDQUFvQkQsUUFBcEIsQ0FBZjs7QUFFQSxXQUFPckQsTUFBUDtBQUNELEdBUlUsQ0FBakI7QUFBQSxNQVNNb0MsZUFBZWEsTUFBTVosWUFBTixDQUFtQjFDLFFBQW5CLENBVHJCOztBQVdBLFNBQU95QyxZQUFQO0FBQ0QiLCJmaWxlIjoiZmFjZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEVkZ2UgPSByZXF1aXJlKCcuL2VkZ2UnKSxcbiAgICAgIE5vcm1hbCA9IHJlcXVpcmUoJy4vbm9ybWFsJyksXG4gICAgICBWZXJ0ZXggPSByZXF1aXJlKCcuL3ZlcnRleCcpLFxuICAgICAgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyksXG4gICAgICBmYWNldFV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9mYWNldCcpLFxuICAgICAgYXJyYXlVdGlsaXRpZXMgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvYXJyYXknKSxcbiAgICAgIG1pZFBvaW50VXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL21pZFBvaW50JyksXG4gICAgICBpbnRlcnNlY3Rpb25VdGlsaXRpZXMgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvaW50ZXJzZWN0aW9uJyk7XG5cbmNvbnN0IHsgVkVSVElDRVNfTEVOR1RIIH0gPSBjb25zdGFudHMsXG4gICAgICB7IHB1c2gsIHBlcm11dGUgfSA9IGFycmF5VXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVFZGdlcywgY2FsY3VsYXRlTm9ybWFsIH0gPSBmYWNldFV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlTWlkUG9pbnRQb3NpdGlvbiwgaXNNaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMgfSA9IG1pZFBvaW50VXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVJbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbiwgY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbnMsIGNhbGN1bGF0ZU51bGxJbnRlcnNlY3Rpb25JbmRleCwgY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbkluZGV4IH0gPSBpbnRlcnNlY3Rpb25VdGlsaXRpZXM7XG5cbmNsYXNzIEZhY2V0IHtcbiAgY29uc3RydWN0b3IodmVydGljZXMsIG5vcm1hbCwgZWRnZXMpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICB9XG5cbiAgZ2V0VmVydGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVydGljZXM7XG4gIH1cblxuICBnZXROb3JtYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsO1xuICB9XG5cbiAgZ2V0RWRnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXM7XG4gIH1cbiAgXG4gIGdldFZlcnRleFBvc2l0aW9ucygpIHtcbiAgICBjb25zdCB2ZXJ0ZXhQb3NpdGlvbnMgPSB0aGlzLnZlcnRpY2VzLm1hcCgodmVydGV4KSA9PiB2ZXJ0ZXguZ2V0UG9zaXRpb24oKSk7XG4gICAgXG4gICAgcmV0dXJuIHZlcnRleFBvc2l0aW9ucztcbiAgfVxuICBcbiAgZ2V0VmVydGV4Tm9ybWFscygpIHtcbiAgICBjb25zdCBub3JtYWxFeHRlbnQgPSB0aGlzLm5vcm1hbC5nZXRFeHRlbnQoKSxcbiAgICAgICAgICB2ZXJ0ZXhOb3JtYWwgPSBub3JtYWxFeHRlbnQsICAvLy9cbiAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzID0gW1xuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgICAgdmVydGV4Tm9ybWFsLFxuICAgICAgICAgIF07XG4gICAgXG4gICAgcmV0dXJuIHZlcnRleE5vcm1hbHM7XG4gIH1cbiAgXG4gIGdldFZlcnRleEluZGV4ZXMoaW5kZXgpIHsgLy8vXG4gICAgY29uc3QgdmVydGV4SW5kZXggPSBpbmRleCAqIDMsXG4gICAgICAgICAgdmVydGV4SW5kZXhlcyA9IFtcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMCxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMSxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMixcbiAgICAgICAgICBdO1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXhJbmRleGVzO1xuICB9XG5cbiAgaXNNYXNrZWQobWFza2luZ0ZhY2V0KSB7XG4gICAgY29uc3QgbWFza2luZ0VkZ2VzID0gbWFza2luZ0ZhY2V0LmdldE1hc2tpbmdFZGdlcygpLFxuICAgICAgICAgIG1pZFBvaW50UG9zaXRpb24gPSBjYWxjdWxhdGVNaWRQb2ludFBvc2l0aW9uKHRoaXMudmVydGljZXMpLFxuICAgICAgICAgIG1pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyA9IGlzTWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzKG1pZFBvaW50UG9zaXRpb24sIG1hc2tpbmdFZGdlcyksXG4gICAgICAgICAgbWFza2VkID0gbWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzOyAgLy8vXG4gICAgXG4gICAgcmV0dXJuIG1hc2tlZDtcbiAgfVxuXG4gIHBlcm11dGUocGxhY2VzKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHBlcm11dGUodGhpcy52ZXJ0aWNlcywgcGxhY2VzKTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICByb3RhdGUocm90YXRpb25RdWF0ZXJuaW9uKSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKCh2ZXJ0ZXgpID0+IHZlcnRleC5yb3RhdGUocm90YXRpb25RdWF0ZXJuaW9uKSk7XG5cbiAgICB0aGlzLm5vcm1hbCA9IGNhbGN1bGF0ZU5vcm1hbCh0aGlzLnZlcnRpY2VzLCBOb3JtYWwpO1xuXG4gICAgdGhpcy5lZGdlcyA9IGNhbGN1bGF0ZUVkZ2VzKHRoaXMudmVydGljZXMsIEVkZ2UpO1xuICB9XG5cbiAgYXBwbHlUcmFuc2Zvcm1zKHRyYW5zZm9ybXMpIHtcbiAgICB0aGlzLnZlcnRpY2VzLmZvckVhY2goKHZlcnRleCkgPT4gdmVydGV4LmFwcGx5VHJhbnNmb3Jtcyh0cmFuc2Zvcm1zKSk7XG5cbiAgICB0aGlzLm5vcm1hbCA9IGNhbGN1bGF0ZU5vcm1hbCh0aGlzLnZlcnRpY2VzLCBOb3JtYWwpO1xuXG4gICAgdGhpcy5lZGdlcyA9IGNhbGN1bGF0ZUVkZ2VzKHRoaXMudmVydGljZXMsIEVkZ2UpO1xuICB9XG5cbiAgc3BsaXRXaXRoSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3Qgbm9uTnVsbEludGVyc2VjdGlvbnMgPSBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCA9IG5vbk51bGxJbnRlcnNlY3Rpb25zLmxlbmd0aDtcblxuICAgIHN3aXRjaCAobm9uTnVsbEludGVyc2VjdGlvbnNMZW5ndGgpIHtcbiAgICAgIGNhc2UgMiA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoVHdvTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDEgOlxuICAgICAgICB0aGlzLnNwbGl0V2l0aE9uZU5vbk51bGxJbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDAgOlxuICAgICAgICB0aGlzLnNwbGl0V2l0aE5vTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgc3BsaXRXaXRoVHdvTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IG51bGxJbnRlcnNlY3Rpb25JbmRleCA9IGNhbGN1bGF0ZU51bGxJbnRlcnNlY3Rpb25JbmRleChpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBwbGFjZXMgPSAoVkVSVElDRVNfTEVOR1RIIC0gbnVsbEludGVyc2VjdGlvbkluZGV4KSAlIFZFUlRJQ0VTX0xFTkdUSDtcblxuICAgIGludGVyc2VjdGlvbnMgPSBwZXJtdXRlKGludGVyc2VjdGlvbnMsIHBsYWNlcyk7XG5cbiAgICBpbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0aW9ucy5zbGljZSgxKTsgLy8vXG5cbiAgICB0aGlzLnBlcm11dGUocGxhY2VzKTtcblxuICAgIGNvbnN0IHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleGVzID0gWyAxLCAyIF0sXG4gICAgICAgICAgZW5kVmVydGV4UG9zaXRpb25JbmRleGVzID0gWyAyLCAwIF0sXG4gICAgICAgICAgaW5kZXhUdXBsZXMgPSBbXG5cbiAgICAgICAgICAgIFsgMCwgMSwgMyBdLFxuICAgICAgICAgICAgWyAzLCA0LCAwIF0sXG4gICAgICAgICAgICBbIDMsIDIsIDQgXSxcblxuICAgICAgICAgIF07XG5cbiAgICB0aGlzLnNwbGl0V2l0aEluZGV4VHVwbGVzQW5kSW50ZXJzZWN0aW9ucyhzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcywgZW5kVmVydGV4UG9zaXRpb25JbmRleGVzLCBpbmRleFR1cGxlcywgaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gIH1cblxuICBzcGxpdFdpdGhPbmVOb25OdWxsSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBub25OdWxsSW50ZXJzZWN0aW9uSW5kZXggPSBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9uSW5kZXgoaW50ZXJzZWN0aW9ucyksXG4gICAgICAgICAgcGxhY2VzID0gKFZFUlRJQ0VTX0xFTkdUSCAtIG5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCkgJSBWRVJUSUNFU19MRU5HVEg7XG5cbiAgICBpbnRlcnNlY3Rpb25zID0gcGVybXV0ZShpbnRlcnNlY3Rpb25zLCBwbGFjZXMpO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdGlvbnMuc2xpY2UoMCwgMSk7ICAvLy9cblxuICAgIHRoaXMucGVybXV0ZShwbGFjZXMpO1xuXG4gICAgY29uc3Qgc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMgPSBbIDAgXSxcbiAgICAgICAgICBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMgPSBbIDEgXSxcbiAgICAgICAgICBpbmRleFR1cGxlcyA9IFtcblxuICAgICAgICAgICAgWyAwLCAzLCAyIF0sXG4gICAgICAgICAgICBbIDMsIDEsIDIgXSxcblxuICAgICAgICAgIF07XG5cbiAgICB0aGlzLnNwbGl0V2l0aEluZGV4VHVwbGVzQW5kSW50ZXJzZWN0aW9ucyhzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcywgZW5kVmVydGV4UG9zaXRpb25JbmRleGVzLCBpbmRleFR1cGxlcywgaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gIH1cblxuICBzcGxpdFdpdGhOb05vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBzbWFsbGVyRmFjZXQgPSB0aGlzLmZyb21WZXJ0aWNlcyh0aGlzLnZlcnRpY2VzKTsgIC8vL1xuXG4gICAgc21hbGxlckZhY2V0cy5wdXNoKHNtYWxsZXJGYWNldCk7XG4gIH1cblxuICBzcGxpdFdpdGhJbmRleFR1cGxlc0FuZEludGVyc2VjdGlvbnMoc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMsIGVuZFZlcnRleFBvc2l0aW9uSW5kZXhlcywgaW5kZXhUdXBsZXMsIGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCB2ZXJ0ZXhQb3NpdGlvbnMgPSB0aGlzLmdldFZlcnRleFBvc2l0aW9ucygpLFxuICAgICAgICAgIGludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9ucyA9IGludGVyc2VjdGlvbnMubWFwKChpbnRlcnNlY3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFZlcnRleFBvc2l0aW9uSW5kZXggPSBzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ID0gZW5kVmVydGV4UG9zaXRpb25JbmRleGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VmVydGV4UG9zaXRpb24gPSB2ZXJ0ZXhQb3NpdGlvbnNbc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4XSxcbiAgICAgICAgICAgICAgICAgIGVuZFZlcnRleFBvc2l0aW9uID0gdmVydGV4UG9zaXRpb25zW2VuZFZlcnRleFBvc2l0aW9uSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb24gPSBjYWxjdWxhdGVJbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbihzdGFydFZlcnRleFBvc2l0aW9uLCBlbmRWZXJ0ZXhQb3NpdGlvbiwgaW50ZXJzZWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uO1xuICAgICAgICAgIH0pO1xuXG4gICAgcHVzaCh2ZXJ0ZXhQb3NpdGlvbnMsIGludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9ucyk7XG5cbiAgICBpbmRleFR1cGxlcy5mb3JFYWNoKChpbmRleFR1cGxlKSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSB2ZXJ0ZXhQb3NpdGlvbnMsICAvLy9cbiAgICAgICAgICAgIGluZGV4ZXMgPSBpbmRleFR1cGxlLCAgLy8vXG4gICAgICAgICAgICBmYWNldCA9IHRoaXMsIFxuICAgICAgICAgICAgc21hbGxlckZhY2V0ID0gc21hbGxlckZhY2V0RnJvbVBvc2l0aW9uc0luZGV4ZXNBbmRGYWNldChwb3NpdGlvbnMsIGluZGV4ZXMsIGZhY2V0KTtcblxuICAgICAgaWYgKHNtYWxsZXJGYWNldCAhPT0gbnVsbCkge1xuICAgICAgICBzbWFsbGVyRmFjZXRzLnB1c2goc21hbGxlckZhY2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2V0O1xuXG5mdW5jdGlvbiBzbWFsbGVyRmFjZXRGcm9tUG9zaXRpb25zSW5kZXhlc0FuZEZhY2V0KHBvc2l0aW9ucywgaW5kZXhlcywgZmFjZXQpIHtcbiAgY29uc3QgdmVydGljZXMgPSBpbmRleGVzLm1hcCgoaW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQgcG9zaXRpb24gPSBwb3NpdGlvbnNbaW5kZXhdO1xuICAgIFxuICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24uc2xpY2UoKTsgLy8vXG4gICAgXG4gICAgICAgICAgY29uc3QgdmVydGV4ID0gVmVydGV4LmZyb21Qb3NpdGlvbihwb3NpdGlvbik7XG5cbiAgICAgICAgICByZXR1cm4gdmVydGV4O1xuICAgICAgICB9KSxcbiAgICAgICAgc21hbGxlckZhY2V0ID0gZmFjZXQuZnJvbVZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICByZXR1cm4gc21hbGxlckZhY2V0O1xufVxuIl19
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Edge = require('./edge'),
    Normal = require('./normal'),
    Vertex = require('./vertex'),
    constants = require('../constants'),
    facetUtilities = require('../utilities/facet'),
    arrayUtilities = require('../utilities/array'),
    midPointUtilities = require('../utilities/midPoint'),
    intersectionUtilities = require('../utilities/intersection');

var VERTICES_LENGTH = constants.VERTICES_LENGTH,
    push = arrayUtilities.push,
    _permute = arrayUtilities.permute,
    calculateEdges = facetUtilities.calculateEdges,
    calculateNormal = facetUtilities.calculateNormal,
    calculateMidPointPosition = midPointUtilities.calculateMidPointPosition,
    isMidPointPositionToOneSideOfMaskingEdges = midPointUtilities.isMidPointPositionToOneSideOfMaskingEdges,
    calculateIntermediateVertexPosition = intersectionUtilities.calculateIntermediateVertexPosition,
    calculateNonNullIntersections = intersectionUtilities.calculateNonNullIntersections,
    calculateNullIntersectionIndex = intersectionUtilities.calculateNullIntersectionIndex,
    calculateNonNullIntersectionIndex = intersectionUtilities.calculateNonNullIntersectionIndex;

var Facet = /*#__PURE__*/function () {
  function Facet(vertices, normal, edges) {
    _classCallCheck(this, Facet);

    this.vertices = vertices;
    this.normal = normal;
    this.edges = edges;
  }

  _createClass(Facet, [{
    key: "getVertices",
    value: function getVertices() {
      return this.vertices;
    }
  }, {
    key: "getNormal",
    value: function getNormal() {
      return this.normal;
    }
  }, {
    key: "getEdges",
    value: function getEdges() {
      return this.edges;
    }
  }, {
    key: "getVertexPositions",
    value: function getVertexPositions() {
      var vertexPositions = this.vertices.map(function (vertex) {
        return vertex.getPosition();
      });
      return vertexPositions;
    }
  }, {
    key: "getVertexNormals",
    value: function getVertexNormals() {
      var normalExtent = this.normal.getExtent(),
          vertexNormal = normalExtent,
          ///
      vertexNormals = [vertexNormal, vertexNormal, vertexNormal];
      return vertexNormals;
    }
  }, {
    key: "getVertexIndexes",
    value: function getVertexIndexes(index) {
      var vertexIndex = index * 3,
          vertexIndexes = [vertexIndex + 0, vertexIndex + 1, vertexIndex + 2];
      return vertexIndexes;
    }
  }, {
    key: "isMasked",
    value: function isMasked(maskingFacet) {
      var maskingEdges = maskingFacet.getMaskingEdges(),
          midPointPosition = calculateMidPointPosition(this.vertices),
          midPointPositionToOneSideOfMaskingEdges = isMidPointPositionToOneSideOfMaskingEdges(midPointPosition, maskingEdges),
          masked = midPointPositionToOneSideOfMaskingEdges; ///

      return masked;
    }
  }, {
    key: "permute",
    value: function permute(places) {
      this.vertices = _permute(this.vertices, places);
      this.normal = calculateNormal(this.vertices, Normal);
      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: "rotate",
    value: function rotate(rotationQuaternion) {
      this.vertices.forEach(function (vertex) {
        return vertex.rotate(rotationQuaternion);
      });
      this.normal = calculateNormal(this.vertices, Normal);
      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: "applyTransform",
    value: function applyTransform(transform) {
      this.vertices.forEach(function (vertex) {
        return vertex.applyTransform(transform);
      });
      this.normal = calculateNormal(this.vertices, Normal);
      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: "splitWithIntersections",
    value: function splitWithIntersections(intersections, smallerFacets) {
      var nonNullIntersections = calculateNonNullIntersections(intersections),
          nonNullIntersectionsLength = nonNullIntersections.length;

      switch (nonNullIntersectionsLength) {
        case 2:
          this.splitWithTwoNonNullIntersections(intersections, smallerFacets);
          break;

        case 1:
          this.splitWithOneNonNullIntersection(intersections, smallerFacets);
          break;

        case 0:
          this.splitWithNoNonNullIntersections(intersections, smallerFacets);
          break;
      }
    }
  }, {
    key: "splitWithTwoNonNullIntersections",
    value: function splitWithTwoNonNullIntersections(intersections, smallerFacets) {
      var nullIntersectionIndex = calculateNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nullIntersectionIndex) % VERTICES_LENGTH;
      intersections = _permute(intersections, places);
      intersections = intersections.slice(1); ///

      this.permute(places);
      var startVertexPositionIndexes = [1, 2],
          endVertexPositionIndexes = [2, 0],
          indexTuples = [[0, 1, 3], [3, 4, 0], [3, 2, 4]];
      this.splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets);
    }
  }, {
    key: "splitWithOneNonNullIntersection",
    value: function splitWithOneNonNullIntersection(intersections, smallerFacets) {
      var nonNullIntersectionIndex = calculateNonNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nonNullIntersectionIndex) % VERTICES_LENGTH;
      intersections = _permute(intersections, places);
      intersections = intersections.slice(0, 1); ///

      this.permute(places);
      var startVertexPositionIndexes = [0],
          endVertexPositionIndexes = [1],
          indexTuples = [[0, 3, 2], [3, 1, 2]];
      this.splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets);
    }
  }, {
    key: "splitWithNoNonNullIntersections",
    value: function splitWithNoNonNullIntersections(intersections, smallerFacets) {
      var smallerFacet = this.fromVertices(this.vertices); ///

      smallerFacets.push(smallerFacet);
    }
  }, {
    key: "splitWithIndexTuplesAndIntersections",
    value: function splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets) {
      var _this = this;

      var vertexPositions = this.getVertexPositions(),
          intermediateVertexPositions = intersections.map(function (intersection, index) {
        var startVertexPositionIndex = startVertexPositionIndexes[index],
            endVertexPositionIndex = endVertexPositionIndexes[index],
            startVertexPosition = vertexPositions[startVertexPositionIndex],
            endVertexPosition = vertexPositions[endVertexPositionIndex],
            intermediateVertexPosition = calculateIntermediateVertexPosition(startVertexPosition, endVertexPosition, intersection);
        return intermediateVertexPosition;
      });
      push(vertexPositions, intermediateVertexPositions);
      indexTuples.forEach(function (indexTuple) {
        var positions = vertexPositions,
            ///
        indexes = indexTuple,
            ///
        facet = _this,
            smallerFacet = smallerFacetFromPositionsIndexesAndFacet(positions, indexes, facet);

        if (smallerFacet !== null) {
          smallerFacets.push(smallerFacet);
        }
      });
    }
  }]);

  return Facet;
}();

module.exports = Facet;

function smallerFacetFromPositionsIndexesAndFacet(positions, indexes, facet) {
  var vertices = indexes.map(function (index) {
    var position = positions[index];
    position = position.slice(); ///

    var vertex = Vertex.fromPosition(position);
    return vertex;
  }),
      smallerFacet = facet.fromVertices(vertices);
  return smallerFacet;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZhY2V0LmpzIl0sIm5hbWVzIjpbIkVkZ2UiLCJyZXF1aXJlIiwiTm9ybWFsIiwiVmVydGV4IiwiY29uc3RhbnRzIiwiZmFjZXRVdGlsaXRpZXMiLCJhcnJheVV0aWxpdGllcyIsIm1pZFBvaW50VXRpbGl0aWVzIiwiaW50ZXJzZWN0aW9uVXRpbGl0aWVzIiwiVkVSVElDRVNfTEVOR1RIIiwicHVzaCIsInBlcm11dGUiLCJjYWxjdWxhdGVFZGdlcyIsImNhbGN1bGF0ZU5vcm1hbCIsImNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24iLCJpc01pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyIsImNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uIiwiY2FsY3VsYXRlTm9uTnVsbEludGVyc2VjdGlvbnMiLCJjYWxjdWxhdGVOdWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJGYWNldCIsInZlcnRpY2VzIiwibm9ybWFsIiwiZWRnZXMiLCJ2ZXJ0ZXhQb3NpdGlvbnMiLCJtYXAiLCJ2ZXJ0ZXgiLCJnZXRQb3NpdGlvbiIsIm5vcm1hbEV4dGVudCIsImdldEV4dGVudCIsInZlcnRleE5vcm1hbCIsInZlcnRleE5vcm1hbHMiLCJpbmRleCIsInZlcnRleEluZGV4IiwidmVydGV4SW5kZXhlcyIsIm1hc2tpbmdGYWNldCIsIm1hc2tpbmdFZGdlcyIsImdldE1hc2tpbmdFZGdlcyIsIm1pZFBvaW50UG9zaXRpb24iLCJtaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMiLCJtYXNrZWQiLCJwbGFjZXMiLCJyb3RhdGlvblF1YXRlcm5pb24iLCJmb3JFYWNoIiwicm90YXRlIiwidHJhbnNmb3JtIiwiYXBwbHlUcmFuc2Zvcm0iLCJpbnRlcnNlY3Rpb25zIiwic21hbGxlckZhY2V0cyIsIm5vbk51bGxJbnRlcnNlY3Rpb25zIiwibm9uTnVsbEludGVyc2VjdGlvbnNMZW5ndGgiLCJsZW5ndGgiLCJzcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyIsInNwbGl0V2l0aE9uZU5vbk51bGxJbnRlcnNlY3Rpb24iLCJzcGxpdFdpdGhOb05vbk51bGxJbnRlcnNlY3Rpb25zIiwibnVsbEludGVyc2VjdGlvbkluZGV4Iiwic2xpY2UiLCJzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcyIsImVuZFZlcnRleFBvc2l0aW9uSW5kZXhlcyIsImluZGV4VHVwbGVzIiwic3BsaXRXaXRoSW5kZXhUdXBsZXNBbmRJbnRlcnNlY3Rpb25zIiwibm9uTnVsbEludGVyc2VjdGlvbkluZGV4Iiwic21hbGxlckZhY2V0IiwiZnJvbVZlcnRpY2VzIiwiZ2V0VmVydGV4UG9zaXRpb25zIiwiaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb25zIiwiaW50ZXJzZWN0aW9uIiwic3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4IiwiZW5kVmVydGV4UG9zaXRpb25JbmRleCIsInN0YXJ0VmVydGV4UG9zaXRpb24iLCJlbmRWZXJ0ZXhQb3NpdGlvbiIsImludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uIiwiaW5kZXhUdXBsZSIsInBvc2l0aW9ucyIsImluZGV4ZXMiLCJmYWNldCIsInNtYWxsZXJGYWNldEZyb21Qb3NpdGlvbnNJbmRleGVzQW5kRmFjZXQiLCJtb2R1bGUiLCJleHBvcnRzIiwicG9zaXRpb24iLCJmcm9tUG9zaXRpb24iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQUVBLElBQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLFFBQUQsQ0FBcEI7QUFBQSxJQUNNQyxNQUFNLEdBQUdELE9BQU8sQ0FBQyxVQUFELENBRHRCO0FBQUEsSUFFTUUsTUFBTSxHQUFHRixPQUFPLENBQUMsVUFBRCxDQUZ0QjtBQUFBLElBR01HLFNBQVMsR0FBR0gsT0FBTyxDQUFDLGNBQUQsQ0FIekI7QUFBQSxJQUlNSSxjQUFjLEdBQUdKLE9BQU8sQ0FBQyxvQkFBRCxDQUo5QjtBQUFBLElBS01LLGNBQWMsR0FB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ICAgICBOb3JtYWwgPSByZXF1aXJlKCcuL25vcm1hbCcpLFxuICAgICAgVmVydGV4ID0gcmVxdWlyZSgnLi92ZXJ0ZXgnKSxcbiAgICAgIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLFxuICAgICAgZmFjZXRVdGlsaXRpZXMgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvZmFjZXQnKSxcbiAgICAgIGFycmF5VXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2FycmF5JyksXG4gICAgICBtaWRQb2ludFV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9taWRQb2ludCcpLFxuICAgICAgaW50ZXJzZWN0aW9uVXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2ludGVyc2VjdGlvbicpO1xuXG5jb25zdCB7IFZFUlRJQ0VTX0xFTkdUSCB9ID0gY29uc3RhbnRzLFxuICAgICAgeyBwdXNoLCBwZXJtdXRlIH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlRWRnZXMsIGNhbGN1bGF0ZU5vcm1hbCB9ID0gZmFjZXRVdGlsaXRpZXMsXG4gICAgICB7IGNhbGN1bGF0ZU1pZFBvaW50UG9zaXRpb24sIGlzTWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzIH0gPSBtaWRQb2ludFV0aWxpdGllcyxcbiAgICAgIHsgY2FsY3VsYXRlSW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb24sIGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zLCBjYWxjdWxhdGVOdWxsSW50ZXJzZWN0aW9uSW5kZXgsIGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCB9ID0gaW50ZXJzZWN0aW9uVXRpbGl0aWVzO1xuXG5jbGFzcyBGYWNldCB7XG4gIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCBub3JtYWwsIGVkZ2VzKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgIHRoaXMuZWRnZXMgPSBlZGdlcztcbiAgfVxuXG4gIGdldFZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzO1xuICB9XG5cbiAgZ2V0Tm9ybWFsKCkge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbDtcbiAgfVxuXG4gIGdldEVkZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzO1xuICB9XG4gIFxuICBnZXRWZXJ0ZXhQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgdmVydGV4UG9zaXRpb25zID0gdGhpcy52ZXJ0aWNlcy5tYXAoKHZlcnRleCkgPT4gdmVydGV4LmdldFBvc2l0aW9uKCkpO1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXhQb3NpdGlvbnM7XG4gIH1cbiAgXG4gIGdldFZlcnRleE5vcm1hbHMoKSB7XG4gICAgY29uc3Qgbm9ybWFsRXh0ZW50ID0gdGhpcy5ub3JtYWwuZ2V0RXh0ZW50KCksXG4gICAgICAgICAgdmVydGV4Tm9ybWFsID0gbm9ybWFsRXh0ZW50LCAgLy8vXG4gICAgICAgICAgdmVydGV4Tm9ybWFscyA9IFtcbiAgICAgICAgICAgIHZlcnRleE5vcm1hbCxcbiAgICAgICAgICAgIHZlcnRleE5vcm1hbCxcbiAgICAgICAgICAgIHZlcnRleE5vcm1hbCxcbiAgICAgICAgICBdO1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXhOb3JtYWxzO1xuICB9XG4gIFxuICBnZXRWZXJ0ZXhJbmRleGVzKGluZGV4KSB7XG4gICAgY29uc3QgdmVydGV4SW5kZXggPSBpbmRleCAqIDMsXG4gICAgICAgICAgdmVydGV4SW5kZXhlcyA9IFtcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMCxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMSxcbiAgICAgICAgICAgIHZlcnRleEluZGV4ICsgMixcbiAgICAgICAgICBdO1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXhJbmRleGVzO1xuICB9XG5cbiAgaXNNYXNrZWQobWFza2luZ0ZhY2V0KSB7XG4gICAgY29uc3QgbWFza2luZ0VkZ2VzID0gbWFza2luZ0ZhY2V0LmdldE1hc2tpbmdFZGdlcygpLFxuICAgICAgICAgIG1pZFBvaW50UG9zaXRpb24gPSBjYWxjdWxhdGVNaWRQb2ludFBvc2l0aW9uKHRoaXMudmVydGljZXMpLFxuICAgICAgICAgIG1pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyA9IGlzTWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzKG1pZFBvaW50UG9zaXRpb24sIG1hc2tpbmdFZGdlcyksXG4gICAgICAgICAgbWFza2VkID0gbWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzOyAgLy8vXG4gICAgXG4gICAgcmV0dXJuIG1hc2tlZDtcbiAgfVxuXG4gIHBlcm11dGUocGxhY2VzKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHBlcm11dGUodGhpcy52ZXJ0aWNlcywgcGxhY2VzKTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICByb3RhdGUocm90YXRpb25RdWF0ZXJuaW9uKSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKCh2ZXJ0ZXgpID0+IHZlcnRleC5yb3RhdGUocm90YXRpb25RdWF0ZXJuaW9uKSk7XG5cbiAgICB0aGlzLm5vcm1hbCA9IGNhbGN1bGF0ZU5vcm1hbCh0aGlzLnZlcnRpY2VzLCBOb3JtYWwpO1xuXG4gICAgdGhpcy5lZGdlcyA9IGNhbGN1bGF0ZUVkZ2VzKHRoaXMudmVydGljZXMsIEVkZ2UpO1xuICB9XG5cbiAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKCh2ZXJ0ZXgpID0+IHZlcnRleC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pKTtcblxuICAgIHRoaXMubm9ybWFsID0gY2FsY3VsYXRlTm9ybWFsKHRoaXMudmVydGljZXMsIE5vcm1hbCk7XG5cbiAgICB0aGlzLmVkZ2VzID0gY2FsY3VsYXRlRWRnZXModGhpcy52ZXJ0aWNlcywgRWRnZSk7XG4gIH1cblxuICBzcGxpdFdpdGhJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBub25OdWxsSW50ZXJzZWN0aW9ucyA9IGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIG5vbk51bGxJbnRlcnNlY3Rpb25zTGVuZ3RoID0gbm9uTnVsbEludGVyc2VjdGlvbnMubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCkge1xuICAgICAgY2FzZSAyIDpcbiAgICAgICAgdGhpcy5zcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMSA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoT25lTm9uTnVsbEludGVyc2VjdGlvbihpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMCA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoTm9Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICBzcGxpdFdpdGhUd29Ob25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3QgbnVsbEludGVyc2VjdGlvbkluZGV4ID0gY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4KGludGVyc2VjdGlvbnMpLFxuICAgICAgICAgIHBsYWNlcyA9IChWRVJUSUNFU19MRU5HVEggLSBudWxsSW50ZXJzZWN0aW9uSW5kZXgpICUgVkVSVElDRVNfTEVOR1RIO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IHBlcm11dGUoaW50ZXJzZWN0aW9ucywgcGxhY2VzKTtcblxuICAgIGludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDEpOyAvLy9cblxuICAgIHRoaXMucGVybXV0ZShwbGFjZXMpO1xuXG4gICAgY29uc3Qgc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMgPSBbIDEsIDIgXSxcbiAgICAgICAgICBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMgPSBbIDIsIDAgXSxcbiAgICAgICAgICBpbmRleFR1cGxlcyA9IFtcblxuICAgICAgICAgICAgWyAwLCAxLCAzIF0sXG4gICAgICAgICAgICBbIDMsIDQsIDAgXSxcbiAgICAgICAgICAgIFsgMywgMiwgNCBdLFxuXG4gICAgICAgICAgXTtcblxuICAgIHRoaXMuc3BsaXRXaXRoSW5kZXhUdXBsZXNBbmRJbnRlcnNlY3Rpb25zKHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleGVzLCBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMsIGluZGV4VHVwbGVzLCBpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgfVxuXG4gIHNwbGl0V2l0aE9uZU5vbk51bGxJbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IG5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCA9IGNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25JbmRleChpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBwbGFjZXMgPSAoVkVSVElDRVNfTEVOR1RIIC0gbm9uTnVsbEludGVyc2VjdGlvbkluZGV4KSAlIFZFUlRJQ0VTX0xFTkdUSDtcblxuICAgIGludGVyc2VjdGlvbnMgPSBwZXJtdXRlKGludGVyc2VjdGlvbnMsIHBsYWNlcyk7XG5cbiAgICBpbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0aW9ucy5zbGljZSgwLCAxKTsgIC8vL1xuXG4gICAgdGhpcy5wZXJtdXRlKHBsYWNlcyk7XG5cbiAgICBjb25zdCBzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcyA9IFsgMCBdLFxuICAgICAgICAgIGVuZFZlcnRleFBvc2l0aW9uSW5kZXhlcyA9IFsgMSBdLFxuICAgICAgICAgIGluZGV4VHVwbGVzID0gW1xuXG4gICAgICAgICAgICBbIDAsIDMsIDIgXSxcbiAgICAgICAgICAgIFsgMywgMSwgMiBdLFxuXG4gICAgICAgICAgXTtcblxuICAgIHRoaXMuc3BsaXRXaXRoSW5kZXhUdXBsZXNBbmRJbnRlcnNlY3Rpb25zKHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleGVzLCBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMsIGluZGV4VHVwbGVzLCBpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKTtcbiAgfVxuXG4gIHNwbGl0V2l0aE5vTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IHNtYWxsZXJGYWNldCA9IHRoaXMuZnJvbVZlcnRpY2VzKHRoaXMudmVydGljZXMpOyAgLy8vXG5cbiAgICBzbWFsbGVyRmFjZXRzLnB1c2goc21hbGxlckZhY2V0KTtcbiAgfVxuXG4gIHNwbGl0V2l0aEluZGV4VHVwbGVzQW5kSW50ZXJzZWN0aW9ucyhzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcywgZW5kVmVydGV4UG9zaXRpb25JbmRleGVzLCBpbmRleFR1cGxlcywgaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IHZlcnRleFBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4UG9zaXRpb25zKCksXG4gICAgICAgICAgaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb25zID0gaW50ZXJzZWN0aW9ucy5tYXAoKGludGVyc2VjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleCA9IHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgIGVuZFZlcnRleFBvc2l0aW9uSW5kZXggPSBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgc3RhcnRWZXJ0ZXhQb3NpdGlvbiA9IHZlcnRleFBvc2l0aW9uc1tzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgZW5kVmVydGV4UG9zaXRpb24gPSB2ZXJ0ZXhQb3NpdGlvbnNbZW5kVmVydGV4UG9zaXRpb25JbmRleF0sXG4gICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbiA9IGNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uKHN0YXJ0VmVydGV4UG9zaXRpb24sIGVuZFZlcnRleFBvc2l0aW9uLCBpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb247XG4gICAgICAgICAgfSk7XG5cbiAgICBwdXNoKHZlcnRleFBvc2l0aW9ucywgaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb25zKTtcblxuICAgIGluZGV4VHVwbGVzLmZvckVhY2goKGluZGV4VHVwbGUpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHZlcnRleFBvc2l0aW9ucywgIC8vL1xuICAgICAgICAgICAgaW5kZXhlcyA9IGluZGV4VHVwbGUsICAvLy9cbiAgICAgICAgICAgIGZhY2V0ID0gdGhpcywgXG4gICAgICAgICAgICBzbWFsbGVyRmFjZXQgPSBzbWFsbGVyRmFjZXRGcm9tUG9zaXRpb25zSW5kZXhlc0FuZEZhY2V0KHBvc2l0aW9ucywgaW5kZXhlcywgZmFjZXQpO1xuXG4gICAgICBpZiAoc21hbGxlckZhY2V0ICE9PSBudWxsKSB7XG4gICAgICAgIHNtYWxsZXJGYWNldHMucHVzaChzbWFsbGVyRmFjZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjZXQ7XG5cbmZ1bmN0aW9uIHNtYWxsZXJGYWNldEZyb21Qb3NpdGlvbnNJbmRleGVzQW5kRmFjZXQocG9zaXRpb25zLCBpbmRleGVzLCBmYWNldCkge1xuICBjb25zdCB2ZXJ0aWNlcyA9IGluZGV4ZXMubWFwKChpbmRleCkgPT4ge1xuICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHBvc2l0aW9uc1tpbmRleF07XG4gICAgXG4gICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbi5zbGljZSgpOyAvLy9cbiAgICBcbiAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSBWZXJ0ZXguZnJvbVBvc2l0aW9uKHBvc2l0aW9uKTtcblxuICAgICAgICAgIHJldHVybiB2ZXJ0ZXg7XG4gICAgICAgIH0pLFxuICAgICAgICBzbWFsbGVyRmFjZXQgPSBmYWNldC5mcm9tVmVydGljZXModmVydGljZXMpO1xuXG4gIHJldHVybiBzbWFsbGVyRmFjZXQ7XG59XG4iXX0=
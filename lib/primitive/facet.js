'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./edge'),
    Normal = require('./normal'),
    Vertex = require('./vertex'),
    constants = require('../constants'),
    facetUtilities = require('../utilities/facet'),
    arrayUtilities = require('../utilities/array'),
    midPointUtilities = require('../utilities/midPoint'),
    intersectionUtilities = require('../utilities/intersection');

var VERTICES_LENGTH = constants.VERTICES_LENGTH,
    push = arrayUtilities.push,
    _permute = arrayUtilities.permute,
    calculateEdges = facetUtilities.calculateEdges,
    calculateNormal = facetUtilities.calculateNormal,
    calculateMidPointPosition = midPointUtilities.calculateMidPointPosition,
    isMidPointPositionToOneSideOfMaskingEdges = midPointUtilities.isMidPointPositionToOneSideOfMaskingEdges,
    calculateIntermediateVertexPosition = intersectionUtilities.calculateIntermediateVertexPosition,
    calculateNonNullIntersections = intersectionUtilities.calculateNonNullIntersections,
    calculateNullIntersectionIndex = intersectionUtilities.calculateNullIntersectionIndex,
    calculateNonNullIntersectionIndex = intersectionUtilities.calculateNonNullIntersectionIndex;

var Facet = function () {
  function Facet(vertices, normal, edges) {
    _classCallCheck(this, Facet);

    this.vertices = vertices;
    this.normal = normal;
    this.edges = edges;
  }

  _createClass(Facet, [{
    key: 'getVertices',
    value: function getVertices() {
      return this.vertices;
    }
  }, {
    key: 'getNormal',
    value: function getNormal() {
      return this.normal;
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this.edges;
    }
  }, {
    key: 'getVertexPositions',
    value: function getVertexPositions() {
      var vertexPositions = this.vertices.map(function (vertex) {
        return vertex.getPosition();
      });

      return vertexPositions;
    }
  }, {
    key: 'getVertexNormals',
    value: function getVertexNormals() {
      var normalExtent = this.normal.getExtent(),
          vertexNormal = normalExtent,
          ///
      vertexNormals = [vertexNormal, vertexNormal, vertexNormal];

      return vertexNormals;
    }
  }, {
    key: 'getVertexIndexes',
    value: function getVertexIndexes(index) {
      var vertexIndex = index * 3,
          vertexIndexes = [vertexIndex + 0, vertexIndex + 1, vertexIndex + 2];

      return vertexIndexes;
    }
  }, {
    key: 'isMasked',
    value: function isMasked(maskingFacet) {
      var maskingEdges = maskingFacet.getMaskingEdges(),
          midPointPosition = calculateMidPointPosition(this.vertices),
          midPointPositionToOneSideOfMaskingEdges = isMidPointPositionToOneSideOfMaskingEdges(midPointPosition, maskingEdges),
          masked = midPointPositionToOneSideOfMaskingEdges; ///

      return masked;
    }
  }, {
    key: 'permute',
    value: function permute(places) {
      this.vertices = _permute(this.vertices, places);

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'rotate',
    value: function rotate(rotationQuaternion) {
      this.vertices.forEach(function (vertex) {
        return vertex.rotate(rotationQuaternion);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'applyTransform',
    value: function applyTransform(transform) {
      this.vertices.forEach(function (vertex) {
        return vertex.applyTransform(transform);
      });

      this.normal = calculateNormal(this.vertices, Normal);

      this.edges = calculateEdges(this.vertices, Edge);
    }
  }, {
    key: 'splitWithIntersections',
    value: function splitWithIntersections(intersections, smallerFacets) {
      var nonNullIntersections = calculateNonNullIntersections(intersections),
          nonNullIntersectionsLength = nonNullIntersections.length;

      switch (nonNullIntersectionsLength) {
        case 2:
          this.splitWithTwoNonNullIntersections(intersections, smallerFacets);
          break;

        case 1:
          this.splitWithOneNonNullIntersection(intersections, smallerFacets);
          break;

        case 0:
          this.splitWithNoNonNullIntersections(intersections, smallerFacets);
          break;
      }
    }
  }, {
    key: 'splitWithTwoNonNullIntersections',
    value: function splitWithTwoNonNullIntersections(intersections, smallerFacets) {
      var nullIntersectionIndex = calculateNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(1); ///

      this.permute(places);

      var startVertexPositionIndexes = [1, 2],
          endVertexPositionIndexes = [2, 0],
          indexTuples = [[0, 1, 3], [3, 4, 0], [3, 2, 4]];

      this.splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets);
    }
  }, {
    key: 'splitWithOneNonNullIntersection',
    value: function splitWithOneNonNullIntersection(intersections, smallerFacets) {
      var nonNullIntersectionIndex = calculateNonNullIntersectionIndex(intersections),
          places = (VERTICES_LENGTH - nonNullIntersectionIndex) % VERTICES_LENGTH;

      intersections = _permute(intersections, places);

      intersections = intersections.slice(0, 1); ///

      this.permute(places);

      var startVertexPositionIndexes = [0],
          endVertexPositionIndexes = [1],
          indexTuples = [[0, 3, 2], [3, 1, 2]];

      this.splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets);
    }
  }, {
    key: 'splitWithNoNonNullIntersections',
    value: function splitWithNoNonNullIntersections(intersections, smallerFacets) {
      var smallerFacet = this.fromVertices(this.vertices); ///

      smallerFacets.push(smallerFacet);
    }
  }, {
    key: 'splitWithIndexTuplesAndIntersections',
    value: function splitWithIndexTuplesAndIntersections(startVertexPositionIndexes, endVertexPositionIndexes, indexTuples, intersections, smallerFacets) {
      var _this = this;

      var vertexPositions = this.getVertexPositions(),
          intermediateVertexPositions = intersections.map(function (intersection, index) {
        var startVertexPositionIndex = startVertexPositionIndexes[index],
            endVertexPositionIndex = endVertexPositionIndexes[index],
            startVertexPosition = vertexPositions[startVertexPositionIndex],
            endVertexPosition = vertexPositions[endVertexPositionIndex],
            intermediateVertexPosition = calculateIntermediateVertexPosition(startVertexPosition, endVertexPosition, intersection);

        return intermediateVertexPosition;
      });

      push(vertexPositions, intermediateVertexPositions);

      indexTuples.forEach(function (indexTuple) {
        var positions = vertexPositions,
            ///
        indexes = indexTuple,
            ///
        facet = _this,
            smallerFacet = smallerFacetFromPositionsIndexesAndFacet(positions, indexes, facet);

        if (smallerFacet !== null) {
          smallerFacets.push(smallerFacet);
        }
      });
    }
  }]);

  return Facet;
}();

module.exports = Facet;

function smallerFacetFromPositionsIndexesAndFacet(positions, indexes, facet) {
  var vertices = indexes.map(function (index) {
    var position = positions[index];

    position = position.slice(); ///

    var vertex = Vertex.fromPosition(position);

    return vertex;
  }),
      smallerFacet = facet.fromVertices(vertices);

  return smallerFacet;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2VzNi9wcmltaXRpdmUvZmFjZXQuanMiXSwibmFtZXMiOlsiRWRnZSIsInJlcXVpcmUiLCJOb3JtYWwiLCJWZXJ0ZXgiLCJjb25zdGFudHMiLCJmYWNldFV0aWxpdGllcyIsImFycmF5VXRpbGl0aWVzIiwibWlkUG9pbnRVdGlsaXRpZXMiLCJpbnRlcnNlY3Rpb25VdGlsaXRpZXMiLCJWRVJUSUNFU19MRU5HVEgiLCJwdXNoIiwicGVybXV0ZSIsImNhbGN1bGF0ZUVkZ2VzIiwiY2FsY3VsYXRlTm9ybWFsIiwiY2FsY3VsYXRlTWlkUG9pbnRQb3NpdGlvbiIsImlzTWlkUG9pbnRQb3NpdGlvblRvT25lU2lkZU9mTWFza2luZ0VkZ2VzIiwiY2FsY3VsYXRlSW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb24iLCJjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9ucyIsImNhbGN1bGF0ZU51bGxJbnRlcnNlY3Rpb25JbmRleCIsImNhbGN1bGF0ZU5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCIsIkZhY2V0IiwidmVydGljZXMiLCJub3JtYWwiLCJlZGdlcyIsInZlcnRleFBvc2l0aW9ucyIsIm1hcCIsInZlcnRleCIsImdldFBvc2l0aW9uIiwibm9ybWFsRXh0ZW50IiwiZ2V0RXh0ZW50IiwidmVydGV4Tm9ybWFsIiwidmVydGV4Tm9ybWFscyIsImluZGV4IiwidmVydGV4SW5kZXgiLCJ2ZXJ0ZXhJbmRleGVzIiwibWFza2luZ0ZhY2V0IiwibWFza2luZ0VkZ2VzIiwiZ2V0TWFza2luZ0VkZ2VzIiwibWlkUG9pbnRQb3NpdGlvbiIsIm1pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyIsIm1hc2tlZCIsInBsYWNlcyIsInJvdGF0aW9uUXVhdGVybmlvbiIsImZvckVhY2giLCJyb3RhdGUiLCJ0cmFuc2Zvcm0iLCJhcHBseVRyYW5zZm9ybSIsImludGVyc2VjdGlvbnMiLCJzbWFsbGVyRmFjZXRzIiwibm9uTnVsbEludGVyc2VjdGlvbnMiLCJub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCIsImxlbmd0aCIsInNwbGl0V2l0aFR3b05vbk51bGxJbnRlcnNlY3Rpb25zIiwic3BsaXRXaXRoT25lTm9uTnVsbEludGVyc2VjdGlvbiIsInNwbGl0V2l0aE5vTm9uTnVsbEludGVyc2VjdGlvbnMiLCJudWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJzbGljZSIsInN0YXJ0VmVydGV4UG9zaXRpb25JbmRleGVzIiwiZW5kVmVydGV4UG9zaXRpb25JbmRleGVzIiwiaW5kZXhUdXBsZXMiLCJzcGxpdFdpdGhJbmRleFR1cGxlc0FuZEludGVyc2VjdGlvbnMiLCJub25OdWxsSW50ZXJzZWN0aW9uSW5kZXgiLCJzbWFsbGVyRmFjZXQiLCJmcm9tVmVydGljZXMiLCJnZXRWZXJ0ZXhQb3NpdGlvbnMiLCJpbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbnMiLCJpbnRlcnNlY3Rpb24iLCJzdGFydFZlcnRleFBvc2l0aW9uSW5kZXgiLCJlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4Iiwic3RhcnRWZXJ0ZXhQb3NpdGlvbiIsImVuZFZlcnRleFBvc2l0aW9uIiwiaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb24iLCJpbmRleFR1cGxlIiwicG9zaXRpb25zIiwiaW5kZXhlcyIsImZhY2V0Iiwic21hbGxlckZhY2V0RnJvbVBvc2l0aW9uc0luZGV4ZXNBbmRGYWNldCIsIm1vZHVsZSIsImV4cG9ydHMiLCJwb3NpdGlvbiIsImZyb21Qb3NpdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBLElBQU1BLE9BQU9DLFFBQVEsUUFBUixDQUFiO0FBQUEsSUFDTUMsU0FBU0QsUUFBUSxVQUFSLENBRGY7QUFBQSxJQUVNRSxTQUFTRixRQUFRLFVBQVIsQ0FGZjtBQUFBLElBR01HLFlBQVlILFFBQVEsY0FBUixDQUhsQjtBQUFBLElBSU1JLGlCQUFpQkosUUFBUSxvQkFBUixDQUp2QjtBQUFBLElBS01LLGlCQUFpQkwsUUFBUSxvQkFBUixDQUx2QjtBQUFBLElBTU1NLG9CQUFv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bEQsRUFBNkRDLE9BQTdELEVBQXNFQyxLQUF0RSxFQUE2RTtBQUMzRSxNQUFNdEQsV0FBV3FELFFBQVFqRCxHQUFSLENBQVksVUFBQ08sS0FBRCxFQUFXO0FBQ2hDLFFBQUkrQyxXQUFXTixVQUFVekMsS0FBVixDQUFmOztBQUVBK0MsZUFBV0EsU0FBU3ZCLEtBQVQsRUFBWCxDQUhnQyxDQUdIOztBQUU3QixRQUFNOUIsU0FBU3ZCLE9BQU82RSxZQUFQLENBQW9CRCxRQUFwQixDQUFmOztBQUVBLFdBQU9yRCxNQUFQO0FBQ0QsR0FSVSxDQUFqQjtBQUFBLE1BU01vQyxlQUFlYSxNQUFNWixZQUFOLENBQW1CMUMsUUFBbkIsQ0FUckI7O0FBV0EsU0FBT3lDLFlBQVA7QUFDRCIsImZpbGUiOiJmYWNldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRWRnZSA9IHJlcXVpcmUoJy4vZWRnZScpLFxuICAgICAgTm9ybWFsID0gcmVxdWlyZSgnLi9ub3JtYWwnKSxcbiAgICAgIFZlcnRleCA9IHJlcXVpcmUoJy4vdmVydGV4JyksXG4gICAgICBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKSxcbiAgICAgIGZhY2V0VXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2ZhY2V0JyksXG4gICAgICBhcnJheVV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9hcnJheScpLFxuICAgICAgbWlkUG9pbnRVdGlsaXRpZXMgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvbWlkUG9pbnQnKSxcbiAgICAgIGludGVyc2VjdGlvblV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9pbnRlcnNlY3Rpb24nKTtcblxuY29uc3QgeyBWRVJUSUNFU19MRU5HVEggfSA9IGNvbnN0YW50cyxcbiAgICAgIHsgcHVzaCwgcGVybXV0ZSB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IGNhbGN1bGF0ZUVkZ2VzLCBjYWxjdWxhdGVOb3JtYWwgfSA9IGZhY2V0VXRpbGl0aWVzLFxuICAgICAgeyBjYWxjdWxhdGVNaWRQb2ludFBvc2l0aW9uLCBpc01pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyB9ID0gbWlkUG9pbnRVdGlsaXRpZXMsXG4gICAgICB7IGNhbGN1bGF0ZUludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uLCBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9ucywgY2FsY3VsYXRlTnVsbEludGVyc2VjdGlvbkluZGV4LCBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9uSW5kZXggfSA9IGludGVyc2VjdGlvblV0aWxpdGllcztcblxuY2xhc3MgRmFjZXQge1xuICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgbm9ybWFsLCBlZGdlcykge1xuICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICB0aGlzLmVkZ2VzID0gZWRnZXM7XG4gIH1cblxuICBnZXRWZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcztcbiAgfVxuXG4gIGdldE5vcm1hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWw7XG4gIH1cblxuICBnZXRFZGdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcztcbiAgfVxuICBcbiAgZ2V0VmVydGV4UG9zaXRpb25zKCkge1xuICAgIGNvbnN0IHZlcnRleFBvc2l0aW9ucyA9IHRoaXMudmVydGljZXMubWFwKCh2ZXJ0ZXgpID0+IHZlcnRleC5nZXRQb3NpdGlvbigpKTtcbiAgICBcbiAgICByZXR1cm4gdmVydGV4UG9zaXRpb25zO1xuICB9XG4gIFxuICBnZXRWZXJ0ZXhOb3JtYWxzKCkge1xuICAgIGNvbnN0IG5vcm1hbEV4dGVudCA9IHRoaXMubm9ybWFsLmdldEV4dGVudCgpLFxuICAgICAgICAgIHZlcnRleE5vcm1hbCA9IG5vcm1hbEV4dGVudCwgIC8vL1xuICAgICAgICAgIHZlcnRleE5vcm1hbHMgPSBbXG4gICAgICAgICAgICB2ZXJ0ZXhOb3JtYWwsXG4gICAgICAgICAgICB2ZXJ0ZXhOb3JtYWwsXG4gICAgICAgICAgICB2ZXJ0ZXhOb3JtYWwsXG4gICAgICAgICAgXTtcbiAgICBcbiAgICByZXR1cm4gdmVydGV4Tm9ybWFscztcbiAgfVxuICBcbiAgZ2V0VmVydGV4SW5kZXhlcyhpbmRleCkge1xuICAgIGNvbnN0IHZlcnRleEluZGV4ID0gaW5kZXggKiAzLFxuICAgICAgICAgIHZlcnRleEluZGV4ZXMgPSBbXG4gICAgICAgICAgICB2ZXJ0ZXhJbmRleCArIDAsXG4gICAgICAgICAgICB2ZXJ0ZXhJbmRleCArIDEsXG4gICAgICAgICAgICB2ZXJ0ZXhJbmRleCArIDIsXG4gICAgICAgICAgXTtcbiAgICBcbiAgICByZXR1cm4gdmVydGV4SW5kZXhlcztcbiAgfVxuXG4gIGlzTWFza2VkKG1hc2tpbmdGYWNldCkge1xuICAgIGNvbnN0IG1hc2tpbmdFZGdlcyA9IG1hc2tpbmdGYWNldC5nZXRNYXNraW5nRWRnZXMoKSxcbiAgICAgICAgICBtaWRQb2ludFBvc2l0aW9uID0gY2FsY3VsYXRlTWlkUG9pbnRQb3NpdGlvbih0aGlzLnZlcnRpY2VzKSxcbiAgICAgICAgICBtaWRQb2ludFBvc2l0aW9uVG9PbmVTaWRlT2ZNYXNraW5nRWRnZXMgPSBpc01pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlcyhtaWRQb2ludFBvc2l0aW9uLCBtYXNraW5nRWRnZXMpLFxuICAgICAgICAgIG1hc2tlZCA9IG1pZFBvaW50UG9zaXRpb25Ub09uZVNpZGVPZk1hc2tpbmdFZGdlczsgIC8vL1xuICAgIFxuICAgIHJldHVybiBtYXNrZWQ7XG4gIH1cblxuICBwZXJtdXRlKHBsYWNlcykge1xuICAgIHRoaXMudmVydGljZXMgPSBwZXJtdXRlKHRoaXMudmVydGljZXMsIHBsYWNlcyk7XG5cbiAgICB0aGlzLm5vcm1hbCA9IGNhbGN1bGF0ZU5vcm1hbCh0aGlzLnZlcnRpY2VzLCBOb3JtYWwpO1xuXG4gICAgdGhpcy5lZGdlcyA9IGNhbGN1bGF0ZUVkZ2VzKHRoaXMudmVydGljZXMsIEVkZ2UpO1xuICB9XG5cbiAgcm90YXRlKHJvdGF0aW9uUXVhdGVybmlvbikge1xuICAgIHRoaXMudmVydGljZXMuZm9yRWFjaCgodmVydGV4KSA9PiB2ZXJ0ZXgucm90YXRlKHJvdGF0aW9uUXVhdGVybmlvbikpO1xuXG4gICAgdGhpcy5ub3JtYWwgPSBjYWxjdWxhdGVOb3JtYWwodGhpcy52ZXJ0aWNlcywgTm9ybWFsKTtcblxuICAgIHRoaXMuZWRnZXMgPSBjYWxjdWxhdGVFZGdlcyh0aGlzLnZlcnRpY2VzLCBFZGdlKTtcbiAgfVxuXG4gIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgIHRoaXMudmVydGljZXMuZm9yRWFjaCgodmVydGV4KSA9PiB2ZXJ0ZXguYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKSk7XG5cbiAgICB0aGlzLm5vcm1hbCA9IGNhbGN1bGF0ZU5vcm1hbCh0aGlzLnZlcnRpY2VzLCBOb3JtYWwpO1xuXG4gICAgdGhpcy5lZGdlcyA9IGNhbGN1bGF0ZUVkZ2VzKHRoaXMudmVydGljZXMsIEVkZ2UpO1xuICB9XG5cbiAgc3BsaXRXaXRoSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBzbWFsbGVyRmFjZXRzKSB7XG4gICAgY29uc3Qgbm9uTnVsbEludGVyc2VjdGlvbnMgPSBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBub25OdWxsSW50ZXJzZWN0aW9uc0xlbmd0aCA9IG5vbk51bGxJbnRlcnNlY3Rpb25zLmxlbmd0aDtcblxuICAgIHN3aXRjaCAobm9uTnVsbEludGVyc2VjdGlvbnNMZW5ndGgpIHtcbiAgICAgIGNhc2UgMiA6XG4gICAgICAgIHRoaXMuc3BsaXRXaXRoVHdvTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDEgOlxuICAgICAgICB0aGlzLnNwbGl0V2l0aE9uZU5vbk51bGxJbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDAgOlxuICAgICAgICB0aGlzLnNwbGl0V2l0aE5vTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgc3BsaXRXaXRoVHdvTm9uTnVsbEludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cykge1xuICAgIGNvbnN0IG51bGxJbnRlcnNlY3Rpb25JbmRleCA9IGNhbGN1bGF0ZU51bGxJbnRlcnNlY3Rpb25JbmRleChpbnRlcnNlY3Rpb25zKSxcbiAgICAgICAgICBwbGFjZXMgPSAoVkVSVElDRVNfTEVOR1RIIC0gbnVsbEludGVyc2VjdGlvbkluZGV4KSAlIFZFUlRJQ0VTX0xFTkdUSDtcblxuICAgIGludGVyc2VjdGlvbnMgPSBwZXJtdXRlKGludGVyc2VjdGlvbnMsIHBsYWNlcyk7XG5cbiAgICBpbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0aW9ucy5zbGljZSgxKTsgLy8vXG5cbiAgICB0aGlzLnBlcm11dGUocGxhY2VzKTtcblxuICAgIGNvbnN0IHN0YXJ0VmVydGV4UG9zaXRpb25JbmRleGVzID0gWyAxLCAyIF0sXG4gICAgICAgICAgZW5kVmVydGV4UG9zaXRpb25JbmRleGVzID0gWyAyLCAwIF0sXG4gICAgICAgICAgaW5kZXhUdXBsZXMgPSBbXG5cbiAgICAgICAgICAgIFsgMCwgMSwgMyBdLFxuICAgICAgICAgICAgWyAzLCA0LCAwIF0sXG4gICAgICAgICAgICBbIDMsIDIsIDQgXSxcblxuICAgICAgICAgIF07XG5cbiAgICB0aGlzLnNwbGl0V2l0aEluZGV4VHVwbGVzQW5kSW50ZXJzZWN0aW9ucyhzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcywgZW5kVmVydGV4UG9zaXRpb25JbmRleGVzLCBpbmRleFR1cGxlcywgaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gIH1cblxuICBzcGxpdFdpdGhPbmVOb25OdWxsSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBub25OdWxsSW50ZXJzZWN0aW9uSW5kZXggPSBjYWxjdWxhdGVOb25OdWxsSW50ZXJzZWN0aW9uSW5kZXgoaW50ZXJzZWN0aW9ucyksXG4gICAgICAgICAgcGxhY2VzID0gKFZFUlRJQ0VTX0xFTkdUSCAtIG5vbk51bGxJbnRlcnNlY3Rpb25JbmRleCkgJSBWRVJUSUNFU19MRU5HVEg7XG5cbiAgICBpbnRlcnNlY3Rpb25zID0gcGVybXV0ZShpbnRlcnNlY3Rpb25zLCBwbGFjZXMpO1xuXG4gICAgaW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdGlvbnMuc2xpY2UoMCwgMSk7ICAvLy9cblxuICAgIHRoaXMucGVybXV0ZShwbGFjZXMpO1xuXG4gICAgY29uc3Qgc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMgPSBbIDAgXSxcbiAgICAgICAgICBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMgPSBbIDEgXSxcbiAgICAgICAgICBpbmRleFR1cGxlcyA9IFtcblxuICAgICAgICAgICAgWyAwLCAzLCAyIF0sXG4gICAgICAgICAgICBbIDMsIDEsIDIgXSxcblxuICAgICAgICAgIF07XG5cbiAgICB0aGlzLnNwbGl0V2l0aEluZGV4VHVwbGVzQW5kSW50ZXJzZWN0aW9ucyhzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlcywgZW5kVmVydGV4UG9zaXRpb25JbmRleGVzLCBpbmRleFR1cGxlcywgaW50ZXJzZWN0aW9ucywgc21hbGxlckZhY2V0cyk7XG4gIH1cblxuICBzcGxpdFdpdGhOb05vbk51bGxJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCBzbWFsbGVyRmFjZXQgPSB0aGlzLmZyb21WZXJ0aWNlcyh0aGlzLnZlcnRpY2VzKTsgIC8vL1xuXG4gICAgc21hbGxlckZhY2V0cy5wdXNoKHNtYWxsZXJGYWNldCk7XG4gIH1cblxuICBzcGxpdFdpdGhJbmRleFR1cGxlc0FuZEludGVyc2VjdGlvbnMoc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4ZXMsIGVuZFZlcnRleFBvc2l0aW9uSW5kZXhlcywgaW5kZXhUdXBsZXMsIGludGVyc2VjdGlvbnMsIHNtYWxsZXJGYWNldHMpIHtcbiAgICBjb25zdCB2ZXJ0ZXhQb3NpdGlvbnMgPSB0aGlzLmdldFZlcnRleFBvc2l0aW9ucygpLFxuICAgICAgICAgIGludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9ucyA9IGludGVyc2VjdGlvbnMubWFwKChpbnRlcnNlY3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFZlcnRleFBvc2l0aW9uSW5kZXggPSBzdGFydFZlcnRleFBvc2l0aW9uSW5kZXhlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICBlbmRWZXJ0ZXhQb3NpdGlvbkluZGV4ID0gZW5kVmVydGV4UG9zaXRpb25JbmRleGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VmVydGV4UG9zaXRpb24gPSB2ZXJ0ZXhQb3NpdGlvbnNbc3RhcnRWZXJ0ZXhQb3NpdGlvbkluZGV4XSxcbiAgICAgICAgICAgICAgICAgIGVuZFZlcnRleFBvc2l0aW9uID0gdmVydGV4UG9zaXRpb25zW2VuZFZlcnRleFBvc2l0aW9uSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlVmVydGV4UG9zaXRpb24gPSBjYWxjdWxhdGVJbnRlcm1lZGlhdGVWZXJ0ZXhQb3NpdGlvbihzdGFydFZlcnRleFBvc2l0aW9uLCBlbmRWZXJ0ZXhQb3NpdGlvbiwgaW50ZXJzZWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9uO1xuICAgICAgICAgIH0pO1xuXG4gICAgcHVzaCh2ZXJ0ZXhQb3NpdGlvbnMsIGludGVybWVkaWF0ZVZlcnRleFBvc2l0aW9ucyk7XG5cbiAgICBpbmRleFR1cGxlcy5mb3JFYWNoKChpbmRleFR1cGxlKSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSB2ZXJ0ZXhQb3NpdGlvbnMsICAvLy9cbiAgICAgICAgICAgIGluZGV4ZXMgPSBpbmRleFR1cGxlLCAgLy8vXG4gICAgICAgICAgICBmYWNldCA9IHRoaXMsIFxuICAgICAgICAgICAgc21hbGxlckZhY2V0ID0gc21hbGxlckZhY2V0RnJvbVBvc2l0aW9uc0luZGV4ZXNBbmRGYWNldChwb3NpdGlvbnMsIGluZGV4ZXMsIGZhY2V0KTtcblxuICAgICAgaWYgKHNtYWxsZXJGYWNldCAhPT0gbnVsbCkge1xuICAgICAgICBzbWFsbGVyRmFjZXRzLnB1c2goc21hbGxlckZhY2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2V0O1xuXG5mdW5jdGlvbiBzbWFsbGVyRmFjZXRGcm9tUG9zaXRpb25zSW5kZXhlc0FuZEZhY2V0KHBvc2l0aW9ucywgaW5kZXhlcywgZmFjZXQpIHtcbiAgY29uc3QgdmVydGljZXMgPSBpbmRleGVzLm1hcCgoaW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQgcG9zaXRpb24gPSBwb3NpdGlvbnNbaW5kZXhdO1xuICAgIFxuICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24uc2xpY2UoKTsgLy8vXG4gICAgXG4gICAgICAgICAgY29uc3QgdmVydGV4ID0gVmVydGV4LmZyb21Qb3NpdGlvbihwb3NpdGlvbik7XG5cbiAgICAgICAgICByZXR1cm4gdmVydGV4O1xuICAgICAgICB9KSxcbiAgICAgICAgc21hbGxlckZhY2V0ID0gZmFjZXQuZnJvbVZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICByZXR1cm4gc21hbGxlckZhY2V0O1xufVxuIl19